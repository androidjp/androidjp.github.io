<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-smile.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-smile.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="总结 JDK8 的所有新特性，在教你如何使用并深入学习JDK8。">
<meta name="keywords" content="jdk">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK 8">
<meta property="og:url" content="http:&#x2F;&#x2F;jpuneng.cn&#x2F;JDK-8&#x2F;index.html">
<meta property="og:site_name" content="jpuneng技术栈">
<meta property="og:description" content="总结 JDK8 的所有新特性，在教你如何使用并深入学习JDK8。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-09-27T03:15:04.258Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jpuneng.cn/JDK-8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>JDK 8 | jpuneng技术栈</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jpuneng技术栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">技术时代，舍我其谁</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jpuneng.cn/JDK-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jasper Wu">
      <meta itemprop="description" content="醒目点、自觉点、速度点，努力奋斗下去，走好自己的路！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jpuneng技术栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JDK 8
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-23 21:18:50" itemprop="dateCreated datePublished" datetime="2019-10-23T21:18:50+08:00">2019-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 11:15:04" itemprop="dateModified" datetime="2020-09-27T11:15:04+08:00">2020-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>总结 JDK8 的所有新特性，在教你如何使用并深入学习JDK8。</p>
</blockquote>
<a id="more"></a>

<h1 id="新特性总览"><a href="#新特性总览" class="headerlink" title="新特性总览"></a>新特性总览</h1><ul>
<li>lambda表达式</li>
<li>Stream操作数组</li>
<li>Optional取代null</li>
<li>简洁的并发编程</li>
<li>LocalDateTime新的时间API</li>
</ul>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul>
<li>概念：Lambda表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应其中的Lambda抽象（lambda abstraction），是一个匿名函数，既没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义的不同）。你也可以理解为，简洁的表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出异常的列表。</li>
<li>作用：既然是匿名函数，那就类比于匿名内部类的用法咯，哪些地方，会用到一些代码量大但实际逻辑不算复杂的方法调用，就可以用到它。<blockquote>
<p>什么是函数式接口？</p>
<p>答：仅仅只有一个抽象方法的接口。</p>
</blockquote>
</li>
<li>语法：<ul>
<li><code>() -&gt; 表达式</code></li>
<li><code>() -&gt; {语句;}</code></li>
<li><code>() -&gt; 对象</code></li>
<li><code>(Class)() -&gt; {语句;}</code>【指定对象类型】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void doSomething(Runnable r) &#123; r.run(); &#125;</span><br><span class="line">public static void doSomething(Task a) &#123; a.execute(); &#125;</span><br><span class="line">....</span><br><span class="line">doSomething(() -&gt; System.out.println(&quot;DDDD&quot;));</span><br><span class="line">// 为了避免隐晦的方法调用，尝试显式地类型转换</span><br><span class="line">doSomething((Runnable)() -&gt; System.out.println(&quot;DDDD&quot;));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用场景（很多特殊场景都包含在内）<br>总的来说，只有在接受函数式接口的地方才可以使用Lambda表达式。<pre class="mermaid">  graph LR
A[如Comparable和Runnable和Callable等函数式接口]
B[自定义的只有一个方法的接口实现]
E[jdk8自带的一些常用的函数式接口]
E1[Predicate]
E2[Function T,R]
E3[Supplier]
E4[Consumer]
E5[BinaryOperatory]
C[Lambda]
A --> C
B --> C
E1 --- E
E2 --- E
E3 --- E
E4 --- E
E5 --- E
E --> C</pre></li>
<li>一些Jdk8的lambda语法糖：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lambda:(Apple a) -&gt; a.getWeight() </span><br><span class="line">方法引用:Apple::getWeight</span><br><span class="line"></span><br><span class="line">Lambda:() -&gt; Thread.currentThread().dumpStack() </span><br><span class="line">方法引用:Thread.currentThread()::dumpStack</span><br><span class="line">  </span><br><span class="line">Lambda:(str, i) -&gt; str.substring(i)</span><br><span class="line">方法引用:String::substring</span><br><span class="line">  </span><br><span class="line">Lambda:(String s) -&gt; System.out.println(s)</span><br><span class="line">方法引用:System.out::println</span><br></pre></td></tr></table></figure></li>
<li>构造函数引用<ul>
<li>无参构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple apple = c1.get();</span><br><span class="line">// 等价于</span><br><span class="line">Supplier&lt;Apple&gt; c2 = () -&gt; new Apple();</span><br></pre></td></tr></table></figure></li>
<li>一参构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple apple = c1.apply(123);</span><br></pre></td></tr></table></figure></li>
<li>两参构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, String, Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple apple = c2.apply(120, &quot;red&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>简化的数组排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apples.sort(comparing(Apple::getWeight));</span><br><span class="line">// 其中：</span><br><span class="line">// ArrayList.sort() since：1.2</span><br><span class="line">// Comparator.comparing(Function&lt;Apple, Integer&gt;) since: 1.8</span><br></pre></td></tr></table></figure></li>
<li>更复杂的数组排序<ul>
<li>倒序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apples.sort(Comparator.comparing(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure></li>
<li>多条件排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apples.sort(Comparator.comparing(Apple::getWeight).reversed()</span><br><span class="line">            .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Predicate的复合<blockquote>
<p>以下三个基本谓词，可以配合已有的谓词（Predicate），来制造出更加复杂的谓词。</p>
</blockquote>
<ul>
<li>negate：“非”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; predicate) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (T t : list) &#123;</span><br><span class="line">        if (predicate.test(t)) &#123;</span><br><span class="line">            result.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">// 红苹果</span><br><span class="line">Predicate&lt;Apple&gt; redApplePd = a -&gt; &quot;red&quot;.equals(a.getColor());</span><br><span class="line">// 不是红苹果</span><br><span class="line">Predicate&lt;Apple&gt; notRedApplePd = a -&gt; redApplePd.negate();</span><br><span class="line">// 过滤</span><br><span class="line">List&lt;Apple&gt; redApple = filter(rawApples, redApplePd);</span><br><span class="line">List&lt;Apple&gt; notRedApple = filter(rawApples, notRedApplePd);</span><br></pre></td></tr></table></figure></li>
<li>and：“与”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redHeavyApplePd = ((Predicate&lt;Apple&gt;) apple -&gt; apple.color.equals(&quot;red&quot;)).and(apple -&gt; false);</span><br></pre></td></tr></table></figure></li>
<li>or：“或”（同理）</li>
</ul>
</li>
<li>Function的复合<ul>
<li>andThen<br><code>f.andThen(g)</code>相当于 <code>g(f())</code>，先执行<code>f()</code>，后执行<code>g()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; dbSelf = x -&gt; x * 2;</span><br><span class="line">Function&lt;Integer, Integer&gt; oppositeNum = x -&gt; -1 * x;</span><br><span class="line">Function&lt;Integer, String&gt; toStr = String::valueOf;</span><br><span class="line">String result = dbSelf.andThen(oppositeNum).andThen(toStr).apply(1); // &quot;-2&quot;</span><br></pre></td></tr></table></figure></li>
<li>compose<br><code>f.compose(g)</code>相当于 <code>f(g())</code>，先执行<code>g()</code>，后执行<code>f()</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; toStr = x -&gt; &quot;ToString:&quot; + x;</span><br><span class="line">Function&lt;String, String&gt; split = x -&gt; x.split(&quot;:&quot;)[1];</span><br><span class="line">Function&lt;String, Integer&gt; toInt = Integer::valueOf;</span><br><span class="line">int result = toInt.compose(split.compose(toStr)).apply(123); // 123</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul>
<li><p>概念：流是Java API新成员，它允许你以声明性方式处理数据集合。</p>
</li>
<li><p>特点：</p>
<ul>
<li>流水线：类似“链式调用”，一步接一步。</li>
<li>内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>减少for循环</li>
<li>减少数组操作中可能声明的垃圾变量的数量</li>
<li>直观、提高可读性</li>
</ul>
</li>
<li><p>流和集合的区别：</p>
<ul>
<li>类似于看视频，无论点到视频的哪一段，它都能很快加载出来，这就是流。而集合相当于我要把整部电影down下来，才能点哪看哪。</li>
<li>集合是内存中的数据结构，它包含数据结构中目前所有的值，集合中每个元素都需要事先计算好，才被放入集合。</li>
<li>流是在概念上固定的数据结构，其元素时按需计算的（懒加载）。需要多少就给多少。换一个角度，流像是一个延迟创建的集合：只有在消费者要求的时候才会生成值。</li>
</ul>
</li>
<li><p>看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Apple&gt; filterApple(List&lt;Apple&gt; apples, Predicate&lt;Apple&gt; criteria) &#123;</span><br><span class="line">      List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">      apples.forEach(apple -&gt; &#123;</span><br><span class="line">          if (criteria.test(apple)) &#123;</span><br><span class="line">              result.add(apple);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果只用Lambda表达式，那操作数组起来，也还是需要一些for循环的加持。<br>而有了Stream，写起code就简单很多了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; redHeavyApples = apples.stream()</span><br><span class="line">  .filter(apple -&gt; &quot;red&quot;.equals(apple.color))</span><br><span class="line">  .filter(apple -&gt; apple.weight &gt; 120)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li><p>相关包、类、方法</p>
<ul>
<li>包：<code>java.util.stream</code></li>
<li>接口：<ul>
<li><code>BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable</code></li>
<li><code>Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt;</code></li>
<li><code>DoubleStream extends BaseStream&lt;Double, DoubleStream&gt;</code></li>
<li><code>IntStream extends BaseStream&lt;Integer, IntStream&gt;</code></li>
<li><code>LongStream extends BaseStream&lt;Long, LongStream&gt;</code></li>
</ul>
</li>
<li>方法：<ul>
<li><code>filter(Predicate&lt;? super T&gt;):Stream&lt;T&gt;</code></li>
<li><code>map(Function&lt;? super T, ? extends R&gt;):Stream&lt;R&gt;</code></li>
<li><code>mapToInt(ToIntFunction&lt;? super T&gt;):LongStream</code></li>
<li><code>mapToDouble(ToDoubleFunction&lt;? super T&gt;):DoubleStream</code></li>
<li><code>mapToLong</code></li>
<li><code>flatMap(Function&lt;? super T, ? super Stream&lt;? extends R&gt;&gt;):Stream&lt;R&gt;</code></li>
<li><code>flatMapToInt()</code></li>
<li><code>flatMapToLong()</code></li>
<li><code>flatMapToDouble()</code></li>
<li><code>distinct():Stream&lt;T&gt;</code></li>
<li><code>sorted():Stream&lt;T&gt;</code></li>
<li><code>sorted(Comparator&lt;? super T&gt;):Stream&lt;T&gt;</code></li>
<li><code>peek(Consumer&lt;? super T&gt;):Stream&lt;T&gt;</code></li>
<li><code>limit(long):Stream&lt;T&gt;</code></li>
<li><code>skip(long):Stream&lt;T&gt;</code></li>
<li><code>forEach(Consumer&lt;? super T&gt;):void</code></li>
<li><code>forEachOrdered()</code></li>
<li><code>toArray():Object[]</code></li>
<li><code>toArray(IntFunction&lt;A[]&gt;):Object[]</code></li>
<li><code>reduce(T, BinaryOperator&lt;T&gt;):T</code></li>
<li><code>reduce(BinaryOperator&lt;T&gt;):Optional&lt;T&gt;</code></li>
<li><code>reduce(U, BiFunction&lt;U, ? super T, U&gt;, BinaryOperator&lt;U&gt;):U</code></li>
<li><code>collect(Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R,R&gt;):R</code></li>
<li><code>collect(Collector&lt;? super T,A,R&gt;):R</code></li>
<li><code>min(Comparator&lt;? super T&gt;):Optional&lt;T&gt;</code></li>
<li><code>max</code></li>
<li><code>count():long</code></li>
<li><code>anyMatch(Predicate&lt;? super T&gt;):boolean</code></li>
<li><code>allMatch</code></li>
<li><code>noneMatch</code></li>
<li><code>findFirst():Optional&lt;T&gt;</code></li>
<li><code>findAny</code></li>
<li><code>builder():Builder&lt;T&gt;</code></li>
<li><code>empty():Stream&lt;T&gt;</code></li>
<li><code>of(T...):Stream&lt;T&gt;</code></li>
<li><code>iterate(T, UnaryOperator&lt;T&gt;):Steram&lt;T&gt;</code></li>
<li><code>generate(Supplier&lt;T&gt;):Stream&lt;T&gt;</code></li>
<li><code>concat(Stream&lt;? extends T&gt;, Stream&lt;? extends T&gt;):Stream&lt;T&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>例子：取重的绿苹果，然后升序排序，取它的重量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; greenHeavyAppleWeight = apples.stream()</span><br><span class="line">      .filter(apple -&gt; apple.weight &gt; 120)</span><br><span class="line">      .filter(apple -&gt; &quot;green&quot;.equals(apple.color))</span><br><span class="line">      .sorted(comparing(Apple::getWeight)) // Comparator.comparing()</span><br><span class="line">      .map(apple -&gt; apple.weight)</span><br><span class="line">      .collect(toList()); // Collectors.toList()</span><br></pre></td></tr></table></figure></li>
<li><p>流只能被消费一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Java8&quot;, &quot;Lambdas&quot;, &quot;In&quot;, &quot;Action&quot;);</span><br><span class="line">  Stream&lt;String&gt; s = names.stream();</span><br><span class="line">  s.forEach(System.out::println);</span><br><span class="line">  // 再继续执行一次，则会抛出异常</span><br><span class="line">  s.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>用<code>flatMap()</code>实现流的扁平化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; streamOfWords = Arrays.stream(words);</span><br><span class="line"></span><br><span class="line">// 没有打平，是两个 String[]，我需要两个嵌套for 循环来打印内容</span><br><span class="line">List&lt;String[]&gt; a = streamOfWords.map(w -&gt; w.split(&quot;&quot;)).collect(toList());</span><br><span class="line">for (String[] itemStrings: a) &#123;</span><br><span class="line">    System.out.println(&quot;item.length: &quot; + itemStrings.length);</span><br><span class="line">    for (String item: itemStrings) &#123;</span><br><span class="line">        System.out.print(item);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有打平，出来的是两个String[]，我需要两个嵌套for 循环来打印内容。而如果用flatMap：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; streamOfWords = Arrays.stream(words);</span><br><span class="line"></span><br><span class="line">// 打平，一个for循环就搞定</span><br><span class="line">List&lt;String&gt; chars = streamOfWords</span><br><span class="line">        .map(w -&gt; w.split(&quot;&quot;))</span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .collect(toList());</span><br><span class="line">for (String item: chars) &#123;</span><br><span class="line">    System.out.print(item + &quot;-&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打平之后，直接操作一个数组就好。</p>
</li>
<li><p>例子：求最大最小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(2, 5, 3, 4, 1, 6, 3, 5);</span><br><span class="line">// way 1</span><br><span class="line">Integer max = numbers.stream().max(Integer::compareTo).orElse(null);</span><br><span class="line">// way 2</span><br><span class="line">max = numbers.stream().reduce(Integer::max).orElse(null);</span><br></pre></td></tr></table></figure></li>
<li><p>原始类型流的特化（Stream转IntStream/LongStream/DoubleStream）</p>
<blockquote>
<p>作用：直接特化为原始类型：int、long、double，避免暗含的装箱成本。以及，有了一些额外的计算方法。</p>
</blockquote>
<ul>
<li>映射到数值流：<code>mapToInt/mapToLong/mapToDouble</code></li>
<li>转回对象流：<code>boxed</code></li>
</ul>
</li>
<li><p>特化流的一下额外方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获得 1到100 的所有偶数</span><br><span class="line">IntStream.rangeClosed(1, 100).filter(num -&gt; num%2 == 0).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>构建流</p>
<ul>
<li>方式一：由值创建流<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;Java8&quot;, &quot;Lambda&quot;, &quot;In&quot;);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>方式二：由数组创建流<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;2,4,6,7,8,12&#125;;</span><br><span class="line">int sum = Arrays.stream(nums).sum();</span><br></pre></td></tr></table></figure></li>
<li>方式三：由集合创建流<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(1,2,3,4,5);</span><br><span class="line">Stream&lt;Integer&gt; numStream = nums.stream();</span><br><span class="line">Stream&lt;Integer&gt; parallelStream = nums.parallelStream();</span><br></pre></td></tr></table></figure></li>
<li>方式四：文件 + NIO 创建流<blockquote>
<p>利用 <code>java.nio.file.Files</code>中的一些静态方法（静态方法 since JDK1.8）都返回一个流。<code>Files</code>since JDK1.7</p>
<p>一个很有用的方法是 <code>Files.lines</code> ，它会返回一个由指定文件中的各行构成的字符串流。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long uniqueWords;</span><br><span class="line">try (Stream&lt;String&gt; lines = Files.lines(Paths.get(ClassLoader.getSystemResource(&quot;data.txt&quot;).toURI()),</span><br><span class="line">        Charset.defaultCharset())) &#123;</span><br><span class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(&quot; &quot;)))</span><br><span class="line">            .distinct()</span><br><span class="line">            .count();</span><br><span class="line">    System.out.println(&quot;uniqueWords:&quot; + uniqueWords);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.fillInStackTrace();</span><br><span class="line">&#125; catch (URISyntaxException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式五：由函数生成流<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下两个操作，可以创建“无限流”，一般配合limit 使用</span><br><span class="line">Stream.iterate(&lt;初始值&gt;, &lt;值的变化函数&gt;)</span><br><span class="line">Stream.generate(Supplier&lt;? extends Object&gt; s)</span><br></pre></td></tr></table></figure>
不像从固定集合创建的流那样有固定大小的流。由 iterate和 generate 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 迭代：每次返回前一个元素加2的值</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2)</span><br><span class="line">    .limit(10)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 生成：接收一个Supplier类型的函数（有出无入的函数）</span><br><span class="line">Stream.generate(Math::random)</span><br><span class="line">    .limit(5)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
看下面这个例子，对比Lambda表达式（匿名函数）和匿名内部类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// lambda</span><br><span class="line">IntStream twos = IntStream.generate(() -&gt; 2);</span><br><span class="line">// 匿名内部类</span><br><span class="line">IntStream twos = IntStream.generate(new IntSupplier() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getAsInt() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
如果这个<code>IntSupplier</code>中不存在成员变量，那么，两者等价。总的来说，匿名内部类更加灵活，而且其output值不一定唯一不变，较为灵活。</li>
</ul>
</li>
<li><p>收集器的用法</p>
<ul>
<li><p>接口：<code>java.util.stream.Collector</code></p>
</li>
<li><p>作用：对<code>Stream</code>的处理结果做收集。</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = Arrays.asList(</span><br><span class="line">      new Apple(130, &quot;red&quot;),</span><br><span class="line">      new Apple(22, &quot;red&quot;),</span><br><span class="line">      new Apple(60, &quot;green&quot;),</span><br><span class="line">      new Apple(162, &quot;green&quot;),</span><br><span class="line">      new Apple(126, &quot;green&quot;),</span><br><span class="line">      new Apple(142, &quot;green&quot;),</span><br><span class="line">      new Apple(117, &quot;green&quot;)</span><br><span class="line">);</span><br><span class="line">// 根据颜色分组</span><br><span class="line">Map&lt;String, List&lt;Apple&gt;&gt; colorAppleMap = apples.stream().collect(groupingBy(apple -&gt; apple.color));</span><br></pre></td></tr></table></figure></li>
<li><p>多级分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;Dish.CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</span><br><span class="line">menu.stream().collect(</span><br><span class="line">        groupingBy(Dish::getType,</span><br><span class="line">                groupingBy(dish -&gt; &#123;</span><br><span class="line">                    if (dish.getCalories() &lt;= 400) &#123;</span><br><span class="line">                        return Dish.CaloricLevel.DIET;</span><br><span class="line">                    &#125; else if (dish.getCalories() &lt;= 700) &#123;</span><br><span class="line">                        return Dish.CaloricLevel.NORMAL;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return Dish.CaloricLevel.FAT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>分组的一些配合操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stream.collect(groupingBy(Dish::getType, summingInt(Dish::getCalories)));</span><br><span class="line">Stream.collect(groupingBy(Dish::getType, mapping(...)));</span><br><span class="line">// 如：</span><br><span class="line">Map&lt;Dish.Type, Set&lt;Dish.CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">menu.stream().collect(</span><br><span class="line">     groupingBy(Dish::getType, mapping(</span><br><span class="line">          dish -&gt; &#123;</span><br><span class="line">              if (dish.getCalories() &lt;= 400) &#123;</span><br><span class="line">                  return Dish.CaloricLevel.DIET;</span><br><span class="line">              &#125; else if (dish.getCalories() &lt;= 700) &#123;</span><br><span class="line">                  return Dish.CaloricLevel.NORMAL;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  return Dish.CaloricLevel.FAT;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          toSet())));</span><br></pre></td></tr></table></figure></li>
<li><p>计数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long count = apples.size();</span><br><span class="line">long count = apples.stream().collect(Collectors.counting());</span><br><span class="line">long count = apples.stream().count();</span><br></pre></td></tr></table></figure></li>
<li><p>汇总</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 求和</span><br><span class="line">int totalWeight = apples.stream().collect(summingInt(Apple::getWeight));</span><br><span class="line">totalWeight = apples.stream().mapToInt(Apple::getWeight).sum();</span><br><span class="line"></span><br><span class="line">// 平均数</span><br><span class="line">double avgWeight = apples.stream().collect(averagingDouble(Apple::getWeight));</span><br><span class="line">avgWeight = apples.stream().mapToDouble(Apple::getWeight).average().orElse(-1);</span><br><span class="line"></span><br><span class="line">// 汇总</span><br><span class="line">IntSummaryStatistics appleStatistics = apples.stream().collect(summarizingInt(Apple::getWeight));</span><br><span class="line">System.out.println(appleStatistics.getMax());</span><br><span class="line">System.out.println(appleStatistics.getMin());</span><br><span class="line">System.out.println(appleStatistics.getAverage());</span><br><span class="line">System.out.println(appleStatistics.getCount());</span><br><span class="line">System.out.println(appleStatistics.getSum());</span><br></pre></td></tr></table></figure></li>
<li><p>连接字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">String result = Arrays.stream(strs).collect(joining([分隔符]));</span><br></pre></td></tr></table></figure></li>
<li><p>分区</p>
<blockquote>
<p>根据Predicate条件，分成true和false两部分集合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Apple&gt;&gt; partitionApples = apples.stream().collect(partitioningBy(apple -&gt; &quot;green&quot;.equals(apple.color)));</span><br></pre></td></tr></table></figure>
<p>看似没有什么特点，但是其实和grouping类似，有一个<code>downStream:Collector</code>的一个第二参数，这就厉害了，扩展性很强。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先划分了素食和非素食，然后，每一类里面，去热量最高的一个。</span><br><span class="line">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian = menu.stream().collect(</span><br><span class="line">  partitioningBy(Dish::isVegetarian, collectingAndThen(</span><br><span class="line">          maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">          Optional::get</span><br><span class="line">  )));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>自定义流（这个就再说咯）</p>
</li>
<li><p>并行流</p>
<blockquote>
<p>相对于<code>stream()</code>，用<code>parallelStream()</code>就能把集合转换为并行流。</p>
</blockquote>
<ul>
<li>概念：并行流就是一个把内容分成多个数据块，并用不同线程分别处理每个数据块的流。</li>
<li>方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切换为并行流：Stream.parallel()</span><br><span class="line">切换为顺序流：Stream.sequential()</span><br><span class="line">// 注意，谁最后调用，流就apply谁。</span><br></pre></td></tr></table></figure></li>
<li>用并行流之前，要测试性能（如果遇到iterator装包解包等的情况，实际上并行锁会更加慢，能用特化流就尽量用特化流）</li>
<li>Spliterator 定义了并行流如何拆分它要遍历的数据</li>
</ul>
</li>
</ul>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul>
<li>class：<code>java.util.Optional</code></li>
<li>作用：解决和避免NPE异常</li>
<li>Optional对象的方法<ul>
<li><code>get()</code>：不推荐使用。如果变量存在，它直接返回封装的变量值，否则就抛出一个NPE或者NoSuchElementException异常。<table>
<thead>
<tr>
<th>Optional方法</th>
<th>调用get()后抛出异常</th>
</tr>
</thead>
<tbody><tr>
<td>Optional.of(null)</td>
<td>java.lang.NullPointerException</td>
</tr>
<tr>
<td>Optional.ofNullable(null)</td>
<td>java.util.NoSuchElementException</td>
</tr>
</tbody></table>
</li>
<li><code>orElse(T other)</code></li>
<li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：<code>orElse</code>的延迟调用版，<code>Supplier</code>方法只有在Optional对象不含值时才执行。<ul>
<li>适用场景：<ul>
<li>创建默认值是耗时的工作。</li>
<li>或者需要十分确定某个方法仅在Optional为空时才调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = null;</span><br><span class="line">Optional&lt;Person&gt; optP1 = Optional.ofNullable(p1);</span><br><span class="line">Person resultP = optP1.orElseGet(() -&gt; &#123;</span><br><span class="line">    Person p = new Person();</span><br><span class="line">    p.firstName = &quot;Fang&quot;;</span><br><span class="line">    return p;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;resultP.firstName: &quot; + resultP.firstName);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：定制抛出的异常。</li>
<li><code>ifPresent(Consumer&lt;? super T&gt;)</code>：当变量值存在时执行一个作为参数传入的方法，否则不做任何操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">Optional&lt;Person&gt; optP1 = Optional.ofNullable(p1);</span><br><span class="line">optP1.ifPresent(person -&gt; System.out.println(&quot;Haha&quot;));</span><br></pre></td></tr></table></figure></li>
<li><code>filter</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.firstName=&quot;Fang&quot;;</span><br><span class="line">p1.lastName=&quot;Hua&quot;;</span><br><span class="line">Person resP = Optional.ofNullable(p1).filter(person -&gt; &quot;Hua&quot;.equals(person.lastName)).orElseGet(() -&gt; &#123;</span><br><span class="line">    Person newP = new Person();</span><br><span class="line">    newP.firstName= &quot;Ming&quot;;</span><br><span class="line">    return newP;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resP.firstName); // Ming</span><br></pre></td></tr></table></figure></li>
<li>当然，还有一些方法与Stream接口相似，如<code>map</code>和<code>flatMap</code></li>
</ul>
</li>
<li>例子：<ul>
<li>对象嵌套取值<ul>
<li>old<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_optional_1() &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    // 当然从重构角度来看，这里是不对的，我们知道太多这个类内部的东西，是需要重构的</span><br><span class="line">    String name = person.getCar().getInsurance().getName();</span><br><span class="line">&#125;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Car car;</span><br><span class="line">    public Car getCar() &#123; return car; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Insurance insurance;</span><br><span class="line">    public Insurance getInsurance() &#123; return insurance; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>new<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public String getCarInsuranceName(Person person) &#123;</span><br><span class="line">    return Optional.ofNullable(person).flatMap(Person::getCar)</span><br><span class="line">            .flatMap(Car::getInsurance)</span><br><span class="line">            .map(Insurance::getName)</span><br><span class="line">            .orElse(&quot;Unknown&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Optional&lt;Car&gt; car = Optional.empty();</span><br><span class="line">    </span><br><span class="line">    public Optional&lt;Car&gt; getCar() &#123;</span><br><span class="line">        return car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Optional&lt;Insurance&gt; insurance = Optional.empty();</span><br><span class="line">    </span><br><span class="line">    public Optional&lt;Insurance&gt; getInsurance() &#123;</span><br><span class="line">        return insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>封装可能为空的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object value = map.get(&quot;key&quot;);</span><br><span class="line">// 加上 Optional</span><br><span class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(&quot;key&quot;));</span><br><span class="line"></span><br><span class="line">// 如： Map&lt;String, Person&gt; map</span><br><span class="line">String valA = Optional.ofNullable(map.get(&quot;A&quot;)).orElse(new Person()).firstName;</span><br></pre></td></tr></table></figure></li>
<li>异常与Optional 去替代 if-else判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Optional&lt;Integer&gt; stringToInt(String s) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return Optional.of(Integer.parseInt(s));</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>两个Optional对象的组合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Insurance findBestInsurance(Person person, Car car) &#123;</span><br><span class="line">    Insurance insurance = new Insurance();</span><br><span class="line">    insurance.name = person.firstName + person.lastName + &quot; --insurance 01&quot;;</span><br><span class="line">    return insurance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Optional&lt;Insurance&gt; nullSafeFindBestInsurance(Optional&lt;Person&gt; person) &#123;</span><br><span class="line">    if (person.isPresent() &amp;&amp; person.get().getCar().isPresent()) &#123;</span><br><span class="line">        Car car = person.get().getCar().get();</span><br><span class="line">        return Optional.of(findBestInsurance(person.get(), car));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>原理：<ul>
<li>变量存在时，Optional类只是对类简单封装。</li>
<li>变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法<code>Optional.empty()</code>返回。</li>
<li><code>Optional.empty()</code>是一个静态工厂方法，</li>
</ul>
</li>
</ul>
<h1 id="函数式编程（Stream-Lambda）"><a href="#函数式编程（Stream-Lambda）" class="headerlink" title="函数式编程（Stream+Lambda）"></a>函数式编程（Stream+Lambda）</h1><blockquote>
<p>函数式编程 VS 命令式编程</p>
<ul>
<li>命令式编程关注怎么做，而函数式编程关注做什么</li>
<li>函数式编程 可读性强，但运行速度不见得更快。</li>
</ul>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="1-for循环取数组最小值"><a href="#1-for循环取数组最小值" class="headerlink" title="1. for循环取数组最小值"></a>1. for循环取数组最小值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1,3,-1,6,-20&#125;;</span><br><span class="line">int min = Integer.MAX_VALUE;</span><br><span class="line">for (int i:nums) &#123;</span><br><span class="line">    if(i &lt; min) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int min2 = IntStream.of(nums).parallel().min().getAsInt();</span><br></pre></td></tr></table></figure>

<h4 id="2-接口的实现-匿名内部类转Lambda"><a href="#2-接口的实现-匿名内部类转Lambda" class="headerlink" title="2. 接口的实现/匿名内部类转Lambda"></a>2. 接口的实现/匿名内部类转Lambda</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// 接口实现</span><br><span class="line">Object target = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;新建一个线程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread((Runnable) target).start();</span><br><span class="line"></span><br><span class="line">/// 匿名内部类</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;BBB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object target2 = (Runnable)() -&gt; System.out.println(&quot;新建一个线程2&quot;);</span><br><span class="line">Runnable target3 = () -&gt; System.out.println(&quot;新建一个线程3&quot;);</span><br><span class="line">System.out.println(&quot;target2 == target3 ：&quot; + (target2 == target3)); // false</span><br><span class="line">new Thread((Runnable) target2).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;BBB&quot;)).start()</span><br></pre></td></tr></table></figure>
<h4 id="3-Lambda创建自定义接口的实例对象"><a href="#3-Lambda创建自定义接口的实例对象" class="headerlink" title="3. Lambda创建自定义接口的实例对象"></a>3. Lambda创建自定义接口的实例对象</h4><p>必备条件:</p>
<ol>
<li>该接口中只能有一个抽象方法</li>
<li>在接口上加上@FunctionalInterface注解（可选：为了编译器的校验，有这个注解的接口，当存在多个抽象方法时，是会编译报错的。）<blockquote>
<p>JDK8 中，接口中可以定义静态方法和默认方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface1 &#123;</span><br><span class="line">    int doubleNum(int i);</span><br><span class="line"></span><br><span class="line">    default int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int sub(int x, int y) &#123;</span><br><span class="line">        return x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface2 &#123;</span><br><span class="line">    int doubleNum(int i);</span><br><span class="line"></span><br><span class="line">    default int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface3 extends Interface1, Interface2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    default int add(int x, int y) &#123;</span><br><span class="line">        return Interface1.super.add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test_lambda_1() &#123;</span><br><span class="line">    Interface1 i1 = (i) -&gt; i * 2;</span><br><span class="line">    System.out.println(&quot;Interface1.sub(10, 3): &quot; + Interface1.sub(10, 3));</span><br><span class="line">    System.out.println(&quot;i1.add(3，7)：&quot; + i1.add(3, 7));</span><br><span class="line">    System.out.println(&quot;i1.doubleNum(20)：&quot; + i1.doubleNum(20));</span><br><span class="line"></span><br><span class="line">    Interface2 i2 = i -&gt; i * 2;</span><br><span class="line">    Interface3 i3 = (int i) -&gt; i * 2;</span><br><span class="line">    Interface3 i4 = (int i) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;.....&quot;);</span><br><span class="line">        return i * 2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Lambda与Function"><a href="#4-Lambda与Function" class="headerlink" title="4. Lambda与Function"></a>4. Lambda与Function</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String cityName= &quot;HongKong&quot;;</span><br><span class="line">int stateCode=237;</span><br><span class="line">String street = &quot;东岸村黄皮树下街1号&quot;;</span><br><span class="line"></span><br><span class="line">String locationID = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; locationIDBuilder = locId -&gt; locId + cityName; // Step 1</span><br><span class="line">locationID = locationIDBuilder</span><br><span class="line">        .andThen(locId -&gt; locId + &quot;，区号：&quot; + stateCode) // Step 2</span><br><span class="line">        .andThen(locId -&gt; locId+&quot;，街道：&quot; + street).apply(locationID); // Step 3</span><br><span class="line">System.out.println(&quot;locationID:&quot; + locationID);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<blockquote>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上</p>
</blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>Consumer&lt; T &gt;</td>
<td>接收T对象，不返回值</td>
</tr>
<tr>
<td>Predicate</td>
<td>Predicate&lt; T &gt;</td>
<td>接收T对象并返回boolean</td>
</tr>
<tr>
<td>Function</td>
<td>Function&lt; T, R &gt;</td>
<td>接收T对象，返回R对象</td>
</tr>
<tr>
<td>Supplier</td>
<td>Supplier&lt; T &gt;</td>
<td>提供T对象（例如工厂），不接收值</td>
</tr>
<tr>
<td>UnaryOperator</td>
<td>UnaryOperator</td>
<td>接收T对象，返回T对象</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>BinaryOperator</td>
<td>接收两个T对象，返回T对象</td>
</tr>
</tbody></table>
<h1 id="Lambda-与-设计模式"><a href="#Lambda-与-设计模式" class="headerlink" title="Lambda 与 设计模式"></a>Lambda 与 设计模式</h1><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface ValidationStrategy &#123;</span><br><span class="line">    boolean execute(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class IsAllLowerCase implements ValidationStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean execute(String s) &#123;</span><br><span class="line">        return s.matches(&quot;[a-z]+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class IsNumeric implements ValidationStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean execute(String s) &#123;</span><br><span class="line">        return s.matches(&quot;\\d+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Validator &#123;</span><br><span class="line">    private final ValidationStrategy validationStrategy;</span><br><span class="line"></span><br><span class="line">    public Validator(ValidationStrategy validationStrategy) &#123;</span><br><span class="line">        this.validationStrategy = validationStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean validate(String s) &#123;</span><br><span class="line">        return validationStrategy.execute(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常来说，要new一些策略来当参数传。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IsNumeric isNumeric = new IsNumeric();</span><br><span class="line">IsAllLowerCase isAllLowerCase = new IsAllLowerCase();</span><br><span class="line"></span><br><span class="line">Validator validatorA = new Validator(isNumeric);</span><br><span class="line">Validator validatorB = new Validator(isAllLowerCase);</span><br></pre></td></tr></table></figure>
<p>使用lambda，让<code>new</code>尽量少出现在code中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Validator validatorA = new Validator(s -&gt; s.matches(&quot;\\d+&quot;));</span><br><span class="line">Validator validatorB = new Validator(s -&gt; s.matches(&quot;[a-z]+&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="模板模式（抽象类的应用）"><a href="#模板模式（抽象类的应用）" class="headerlink" title="模板模式（抽象类的应用）"></a>模板模式（抽象类的应用）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractOnlineBank &#123;</span><br><span class="line">    public void processCustomer(int id) &#123;</span><br><span class="line">        Customer customer = Database.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void makeCustomerHappy(Customer customer);</span><br><span class="line"></span><br><span class="line">    static class Customer &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Database &#123;</span><br><span class="line">        static Customer getCustomerWithId(int id) &#123;</span><br><span class="line">            return new Customer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">AbstractOnlineBank bank = new AbstractOnlineBank() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void makeCustomerHappy(Customer customer) &#123;</span><br><span class="line">        System.out.println(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bank.processCustomer(1);</span><br><span class="line">bank.processCustomer(2);</span><br></pre></td></tr></table></figure>
<p>用了Lambda，抽象方法都用不着了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractOnlineBank &#123;</span><br><span class="line">    public void processCustomer(int id, Consumer&lt;Customer&gt; makeCustomerHappy) &#123;</span><br><span class="line">        Customer customer = Database.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy.accept(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Customer &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Database &#123;</span><br><span class="line">        static Customer getCustomerWithId(int id) &#123;</span><br><span class="line">            return new Customer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">AbstractOnlineBank bank = new AbstractOnlineBank();</span><br><span class="line">bank.processCustomer(1, customer -&gt; System.out.println(&quot;Hello&quot;));</span><br><span class="line">bank.processCustomer(2, customer -&gt; System.out.println(&quot;Hi&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">interface Observer&#123;</span><br><span class="line">        void inform(String tweet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private static class NYTimes implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inform(String tweet) &#123;</span><br><span class="line">        if (tweet != null &amp;&amp; tweet.contains(&quot;money&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Breaking news in NY!&quot; + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Guardian implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inform(String tweet) &#123;</span><br><span class="line">        if (tweet != null &amp;&amp; tweet.contains(&quot;queen&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Yet another news in London... &quot; + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class LeMonde implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inform(String tweet) &#123;</span><br><span class="line">        if(tweet != null &amp;&amp; tweet.contains(&quot;wine&quot;))&#123;</span><br><span class="line">            System.out.println(&quot;Today cheese, wine and news! &quot; + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void registerObserver(Observer o);</span><br><span class="line"></span><br><span class="line">    void notifyObserver(String tweet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Feed implements Subject &#123;</span><br><span class="line">    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer o) &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObserver(String tweet) &#123;</span><br><span class="line">        observers.forEach(o -&gt; o.inform(tweet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，看到了有一个观察者接口，并且只有一个方法<code>inform</code>，那么，我们是不是就可以少声明这几个实现类呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Feed feedLambda = new Feed();</span><br><span class="line">feedLambda.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">    if (tweet != null &amp;&amp; tweet.contains(&quot;money&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;Breaking news in NY!&quot; + tweet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">feedLambda.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">    if (tweet != null &amp;&amp; tweet.contains(&quot;queen&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;Yet another news in London... &quot; + tweet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">feedLambda.notifyObserver(&quot;Money money money, give me money!&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private static abstract class AbstractProcessingObject&lt;T&gt; &#123;</span><br><span class="line">    protected AbstractProcessingObject&lt;T&gt; successor;</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(AbstractProcessingObject&lt;T&gt; successor) &#123;</span><br><span class="line">        this.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T handle(T input) &#123;</span><br><span class="line">        T r = handleWork(input);</span><br><span class="line">        if (successor != null) &#123;</span><br><span class="line">            return successor.handle(r);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract T handleWork(T input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一看到，又是抽象类加不同的实现，那就想到是不是可以用匿名函数实现，而这里，我们使用<code>UnaryOperator</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 流程A</span><br><span class="line">UnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;</span><br><span class="line">// 流程B</span><br><span class="line">UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);</span><br><span class="line">// A --&gt; B</span><br><span class="line">Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);</span><br><span class="line">String result2 = pipeline.apply(&quot;Aren&apos;t labdas really sexy?!!&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class ProductFactory &#123;</span><br><span class="line">    public static Product createProduct(String name) &#123;</span><br><span class="line">        switch (name) &#123;</span><br><span class="line">            case &quot;loan&quot;:</span><br><span class="line">                return new Loan();</span><br><span class="line">            case &quot;stock&quot;:</span><br><span class="line">                return new Stock();</span><br><span class="line">            case &quot;bond&quot;:</span><br><span class="line">                return new Bond();</span><br><span class="line">            default:</span><br><span class="line">                throw new RuntimeException(&quot;No such product &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static private class Loan implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static private class Stock implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static private class Bond implements Product &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单情况下，可以用<code>Supplier</code>去实现引用方法式的构造器调用，并且减少switch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static class ProductFactory &#123;</span><br><span class="line">    private static final Map&lt;String, Supplier&lt;Product&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(&quot;loan&quot;, Loan::new);</span><br><span class="line">        map.put(&quot;stock&quot;, Stock::new);</span><br><span class="line">        map.put(&quot;bond&quot;, Bond::new);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Product createProduct(String name) &#123;</span><br><span class="line">        Supplier&lt;Product&gt; productSupplier = map.get(name);</span><br><span class="line">        if (productSupplier != null) &#123;</span><br><span class="line">            return productSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;No such product &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果工厂方法 createProduct 需要接收多个传递给产品构造方法的参数，这种方式的扩展性不是很好。</p>
<h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h1><h3 id="Jdk8开始支持的东西"><a href="#Jdk8开始支持的东西" class="headerlink" title="Jdk8开始支持的东西"></a>Jdk8开始支持的东西</h3><p>Jdk8中的接口支持在声明方法的同时提供实现。</p>
<ul>
<li>Jdk8支持接口中有静态方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface IBoy &#123;</span><br><span class="line">      static String getCompany() &#123;</span><br><span class="line">          return &quot;OOL&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>Jdk8支持接口中有默认方法。【jdk8 新功能】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// List.sort()</span><br><span class="line">default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">      Object[] a = this.toArray();</span><br><span class="line">      Arrays.sort(a, (Comparator) c);</span><br><span class="line">      ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">      for (Object e : a) &#123;</span><br><span class="line">          i.next();</span><br><span class="line">          i.set((E) e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// Collection.stream()</span><br><span class="line">default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">      return StreamSupport.stream(spliterator(), false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>为接口定义默认的方法实现</strong>：默认方法提供了接口的这个方法的默认实现，那么，在使用Lambda匿名地构造接口实现时，就不需要显示重写接口的这个方法，默认方法自动就会继承过来。</li>
<li><strong>新增的接口，只要加上<code>default</code>修饰符，就可以不被显式继承，因此，别的地方的代码是不用改动的！！</strong><blockquote>
<p>看个例子：jdk8以前的<code>Iterator</code>接口，实际上用户是不在乎<code>remove()</code>方法的，而且当时是没有<code>forEachRemaining()</code>方法的，那么，当时的做法，就是每次实现这个接口的时候，都需要显式继承并重写<code>remove()</code>方法，很烦。</p>
<p>到了jdk8， 有了<code>default</code>修饰符，那么，我们不想显式重写的<code>remove()</code>方法就可以不用重写了，然后，jdk8新增了<code>forEachRemaining()</code>方法，也不需要其他实现类再去修改code了，因为它压根不需要你显式重写。</p>
</blockquote>
</li>
</ul>
<h3 id="解决继承链上的冲突的规则"><a href="#解决继承链上的冲突的规则" class="headerlink" title="解决继承链上的冲突的规则"></a>解决继承链上的冲突的规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    default void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello from A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface B extends A &#123;</span><br><span class="line">    default void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello from B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C implements A, B &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 猜猜打印的是什么？</span><br><span class="line">        new C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上问题，就是菱形继承问题，如果父子接口有同名的default方法，那么，以上代码编译不通过。<br>我们需要重写这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class C implements A, B &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new C().hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">       A.super.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OR</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">       B.super.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OR</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">       System.out.println(&quot;Hello from C!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组合式异步编程"><a href="#组合式异步编程" class="headerlink" title="组合式异步编程"></a>组合式异步编程</h1><ul>
<li>术语： CompletableFuture</li>
<li>背景：<ul>
<li>Jdk 7 中引入了“并行/合并框架”<blockquote>
<p>注意：并行和并发的区别：</p>
<ul>
<li>并行（parallellism）：<ul>
<li>并行指的是同一个时刻，多个任务确实真的在同时运行。多个任务不抢对方资源。</li>
<li>例子：两个人，各自一边吃水果，吃完就吃pizza。【有多个CPU内核时，每个内核各自不占对方的资源，各做各的事，是可以达到真正意义上的“同时”的。】</li>
</ul>
</li>
<li>并发（concurrency）：<ul>
<li>并发是指在一段时间内宏观上多个程序同时运行。多个任务互相抢资源。</li>
<li>例子：一个人，同时做多件事情。【单核计算器中，是不可能“同时”做两件事的，只是时间片在进程间的切换很快，我们感觉不到而已。】</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>Jdk 8 中引入了并行流</li>
<li>Jdk 8 中改进了<code>Future</code>接口，并且，新增了<code>CompletableFuture</code>接口。</li>
<li>如果我们现在有一个大的耗时任务要处理，我们可以将其拆分为多个小任务，让其并行处理，最终再将处理的结果统计合并起来， 那么，我们可以结合 并行/合并框架 + 并行流 来快速实现。</li>
</ul>
</li>
</ul>
<h3 id="RecursiveTask（JDK-1-7）"><a href="#RecursiveTask（JDK-1-7）" class="headerlink" title="RecursiveTask（JDK 1.7）"></a>RecursiveTask（JDK 1.7）</h3><p>例子：实现一个100000个自然数的求和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class SumTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">public static final int Flag = 50;</span><br><span class="line">long[] arr;</span><br><span class="line">int start;</span><br><span class="line">int end;</span><br><span class="line"></span><br><span class="line">public SumTask(long[] arr, int start, int end) &#123;</span><br><span class="line">    this.arr = arr;</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SumTask(long[] arr) &#123;</span><br><span class="line">    this.arr = arr;</span><br><span class="line">    this.start = 0;</span><br><span class="line">    this.end = arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Long compute() &#123;</span><br><span class="line">    // 如果不能进行更小粒度的任务分配</span><br><span class="line">    int length = end - start;</span><br><span class="line">    if (length &lt;= Flag) &#123;</span><br><span class="line">        return processSequentially();</span><br><span class="line">    &#125;</span><br><span class="line">    //分治</span><br><span class="line">    int middle = (start + end) / 2;</span><br><span class="line">    SumTask sumTaskOne = new SumTask(arr, start, middle);</span><br><span class="line">    SumTask sumTaskTwo = new SumTask(arr, middle, end);</span><br><span class="line">    invokeAll(sumTaskOne, sumTaskTwo);</span><br><span class="line">    Long join1 = sumTaskOne.join();</span><br><span class="line">    Long join2 = sumTaskTwo.join();</span><br><span class="line">    return join1 + join2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 小任务具体是做什么</span><br><span class="line">private long processSequentially() &#123;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">  long[] arr = new long[1000];</span><br><span class="line">  for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      arr[i] = (long) (Math.random() * 10 + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  // 线程池（since 1.7）</span><br><span class="line">  ForkJoinPool forkJoinPool = new ForkJoinPool(5);</span><br><span class="line">  ForkJoinTask&lt;Long&gt; forkJoinTask = new SumTask(arr);</span><br><span class="line">  long result = forkJoinPool.invoke(forkJoinTask);</span><br><span class="line">  System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结： 分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果。</li>
</ul>
<h3 id="Spliterator（可分迭代器-JDK-1-8）"><a href="#Spliterator（可分迭代器-JDK-1-8）" class="headerlink" title="Spliterator（可分迭代器 JDK 1.8）"></a>Spliterator（可分迭代器 JDK 1.8）</h3><h4 id="（一）背景"><a href="#（一）背景" class="headerlink" title="（一）背景"></a>（一）背景</h4><ul>
<li>jdk 1.8 加入，和Iterator一样，也用于遍历数据源元素，但它是为了并行执行而设计的。</li>
<li>jdk8已经为集合框架中的所有数据结构提供了一个默认的Spliterator实现。</li>
<li>目的：<ul>
<li>为了优化在并行流做任务处理时的数据源拆分遍历时，使用Iterator的装包和解包的性能开销。</li>
<li>配合并行流更快地遍历和处理元素。</li>
</ul>
</li>
<li>内部方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Spliterator&lt;T&gt; &#123;</span><br><span class="line">  // 如果还有元素要遍历， 返回true</span><br><span class="line">  boolean tryAdvance(Consumer&lt;? super T&gt; action);</span><br><span class="line">  // 把一些元素拆分给第二个Spliterator,不断对 Spliterator 调用 trySplit直到它返回 null ，表明它处理的数据结构不能再分割</span><br><span class="line">  Spliterator&lt;T&gt; trySplit();</span><br><span class="line">  // 估计剩下多少元素要遍历</span><br><span class="line">  long estimateSize();</span><br><span class="line">  // 用于影响开分过程的配置参数</span><br><span class="line">  int characteristics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>延迟绑定的Spliterator：Spliterator可以在第一次遍历、第一次拆分或第一次查询估计大小时绑定元素的数据源，而不是在创建时就绑定。这种情况下，它称为延迟绑定（late-binding）的 Spliterator 。<h4 id="（二）例子"><a href="#（二）例子" class="headerlink" title="（二）例子"></a>（二）例子</h4>例子：一个自定义的并行迭代器，用于处理单词数量统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 首先，我们有一个英文句子，我们要统计它的单词数量</span><br><span class="line">public static final String SENTENCE =</span><br><span class="line">        &quot; Nel   mezzo del cammin  di nostra  vita &quot; +</span><br><span class="line">                &quot;mi  ritrovai in una  selva oscura&quot; +</span><br><span class="line">                &quot; che la  dritta via era   smarrita &quot;;</span><br></pre></td></tr></table></figure></li>
<li>方法一：通常手段，写一个方法，直接实现统计逻辑<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int countWords1(String s) &#123;</span><br><span class="line">      int counter = 0;</span><br><span class="line">      boolean lastSpace = true;</span><br><span class="line">      for (char c : s.toCharArray()) &#123;</span><br><span class="line">          if (Character.isWhitespace(c)) &#123;</span><br><span class="line">              lastSpace = true;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              if (lastSpace) &#123;</span><br><span class="line">                  counter ++;</span><br><span class="line">              &#125;</span><br><span class="line">              lastSpace = Character.isWhitespace(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return counter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：利用jdk8 stream的函数声明式来简化代码，但是要实现辅助对象了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class WordCounter &#123;</span><br><span class="line">      private final int counter;</span><br><span class="line">      private final boolean lastSpace;</span><br><span class="line"></span><br><span class="line">      public WordCounter(int counter, boolean lastSpace) &#123;</span><br><span class="line">          this.counter = counter;</span><br><span class="line">          this.lastSpace = lastSpace;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如何改变WordCounter的属性状态</span><br><span class="line">      public WordCounter accumulate(Character c) &#123;</span><br><span class="line">          if (Character.isWhitespace(c)) &#123;</span><br><span class="line">              return lastSpace ? this : new WordCounter(counter, true);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return lastSpace ? new WordCounter(counter + 1, false):this;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 调用此方法时，会把两个子counter的部分结果进行汇总。</span><br><span class="line">      // 其实就是 把内部计数器相加</span><br><span class="line">      public WordCounter combine(WordCounter wordCounter) &#123;</span><br><span class="line">          return new WordCounter(counter + wordCounter.counter, wordCounter.lastSpace);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public int getCounter() &#123;</span><br><span class="line">          return counter;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
实现了辅助对象后，实现一个传stream处理的方法，去调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int countWords2(Stream&lt;Character&gt; stream) &#123;</span><br><span class="line">      WordCounter wordCounter = stream.reduce(new WordCounter(0, true),WordCounter::accumulate, WordCounter::combine);</span><br><span class="line">      return wordCounter.getCounter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
用以上这种方式，就只能实现串行的处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_2() &#123;</span><br><span class="line">     Stream&lt;Character&gt; stream = IntStream.range(0, SENTENCE.length())</span><br><span class="line">            .mapToObj(SENTENCE::charAt);</span><br><span class="line">    System.out.println(&quot;Found &quot; + countWords2(stream) + &quot; words&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法三：使用jdk8中的可分迭代器，模拟jdk7的拆分/合并模式去实现并行迭代处理过程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class WordCounterSpliterator implements Spliterator&lt;Character&gt; &#123;</span><br><span class="line">      private final String string;</span><br><span class="line">      private int currentChar = 0;</span><br><span class="line">  </span><br><span class="line">      public WordCounterSpliterator(String string) &#123;</span><br><span class="line">          this.string = string;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 把String中当前位置的char 传给 Consumer，并让其位置+1，</span><br><span class="line">       * 作为参数传递的Consumer是一个java内部类，在遍历流时将要处理的char传给一系列要对其执行的函数。</span><br><span class="line">       * 这里只有一个归约函数，即 WordCounter 类的 accumulate方法。</span><br><span class="line">       * 如果新的指针位置小于 String 的总长，且还有要遍历的 Character ，则tryAdvance 返回 true 。</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public boolean tryAdvance(Consumer&lt;? super Character&gt; action) &#123;</span><br><span class="line">          action.accept(string.charAt(currentChar++));</span><br><span class="line">          return currentChar &lt; string.length();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public Spliterator&lt;Character&gt; trySplit() &#123;</span><br><span class="line">          // 像 RecursiveTask 的 compute 方法一样（分支/合并框架的使用方式）</span><br><span class="line">  </span><br><span class="line">          int currentSize = string.length() - currentChar;</span><br><span class="line">  </span><br><span class="line">          // 定义不再拆分的界限（不断拆分，直到返回null）</span><br><span class="line">          if (currentSize &lt; 10) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">          for (int splitPos = currentSize / 2 + currentChar;</span><br><span class="line">               splitPos &lt; string.length(); splitPos++) &#123;</span><br><span class="line">              if (Character.isWhitespace(string.charAt(splitPos))) &#123;</span><br><span class="line">                  // 类似RecursiveTask那样，递归拆分</span><br><span class="line">                  Spliterator&lt;Character&gt; spliterator =</span><br><span class="line">                          new WordCounterSpliterator(string.substring(currentChar,</span><br><span class="line">                                  splitPos));</span><br><span class="line">                  currentChar = splitPos;</span><br><span class="line">                  return spliterator;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public long estimateSize() &#123;</span><br><span class="line">          return string.length() - currentChar;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public int characteristics() &#123;</span><br><span class="line">          return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有了自定义的可分迭代器，我们就可以用并行的处理方式了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_3() &#123;</span><br><span class="line">      Spliterator&lt;Character&gt; spliterator = new WordCounterSpliterator(SENTENCE);</span><br><span class="line">      Stream&lt;Character&gt; stream = StreamSupport.stream(spliterator, true);</span><br><span class="line">      System.out.println(&quot;Found &quot; + countWords2(stream.parallel()) + &quot; words&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompletableFuture（Jdk-1-8）"><a href="#CompletableFuture（Jdk-1-8）" class="headerlink" title="CompletableFuture（Jdk 1.8）"></a>CompletableFuture（Jdk 1.8）</h3></li>
<li>翻译：可完备的Future</li>
<li>简单来说，就是写法更灵活、code可读性更好的Future。</li>
<li>是除了并行流之外的另一种并行方式，只是使用场景不同。</li>
</ul>
<h4 id="（一）一个商店商品报价的例子"><a href="#（一）一个商店商品报价的例子" class="headerlink" title="（一）一个商店商品报价的例子"></a>（一）一个商店商品报价的例子</h4><p>普通的方法去写一个同步的计算报价的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static class Shop &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final Random random;</span><br><span class="line"></span><br><span class="line">    public Shop(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        random = new Random(name.charAt(0) * name.charAt(1) * name.charAt(2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice(String product) &#123;</span><br><span class="line">        return calculatePrice(product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private double calculatePrice(String product) &#123;</span><br><span class="line">        delay(1000);</span><br><span class="line">        return random.nextDouble()*product.charAt(0) + product.charAt(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">@Test</span><br><span class="line">public void test_1() &#123;</span><br><span class="line">    Shop nike = new Shop(&quot;nike&quot;);</span><br><span class="line">    Shop adidas = new Shop(&quot;adidas&quot;);</span><br><span class="line">    System.out.println(&quot;nike Kobe1 price : &quot;+ nike.getPrice(&quot;Kobe1&quot;));</span><br><span class="line">    System.out.println(&quot;nike Rose3 price : &quot;+ adidas.getPrice(&quot;Rose3&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先用<code>CompletableFuture</code>来让计算变成异步。</p>
<ul>
<li>首先，用一个线程去执行对应逻辑，并且返回一个<code>CompletableFuture</code>实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static class Shop &#123;</span><br><span class="line">     ............</span><br><span class="line">      public Future&lt;Double&gt; getPriceAsync(String product) &#123;</span><br><span class="line">          CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();</span><br><span class="line">          new Thread(() -&gt; &#123;</span><br><span class="line">              double price = calculatePrice(product);</span><br><span class="line">              futurePrice.complete(price);</span><br><span class="line">          &#125;).start();</span><br><span class="line">          return futurePrice;</span><br><span class="line">      &#125;</span><br><span class="line">      ............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>好，然后我们在执行此方法时，就实现了异步。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">      Shop nike = new Shop(&quot;nike&quot;);</span><br><span class="line">      Shop adidas = new Shop(&quot;adidas&quot;);</span><br><span class="line">      Future&lt;Double&gt; price1 = nike.getPriceAsync(&quot;Kobe1&quot;);</span><br><span class="line">      Future&lt;Double&gt; price2 = adidas.getPriceAsync(&quot;Kobe1&quot;);</span><br><span class="line">      System.out.printf(&quot;nike Kobe1 price :%.2f%n&quot;,price1.get());</span><br><span class="line">      System.out.printf(&quot;nike Kobe1 price :%.2f%n&quot;, price2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="（二）Future的局限性"><a href="#（二）Future的局限性" class="headerlink" title="（二）Future的局限性"></a>（二）Future的局限性</h4><p>看到上面，我们发现，其实，和用<code>Future</code>去handle结果返回，好像差不多。</p>
<ul>
<li>我们可以用<code>Future.get(timeout, TimeUnit)</code> 来防止一直拿不到值而等待的情况。</li>
<li>可以用<code>Future.isDone()</code>来判断当前任务是否跑完，然后做不同的handle逻辑。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_1() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;Double&gt; future = executor.submit(this::doSthAsync);</span><br><span class="line">    System.out.println(&quot;好，任务起来了，我去干别的先了&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">        System.out.println(&quot;主线程正在干活。。&quot;);</span><br><span class="line">        Thread.sleep(500L);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;异步任务返回了： &quot; + future.get(2, TimeUnit.SECONDS));</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        System.out.println(&quot;异步任务出了异常！！！&quot;);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里，就要说一下<code>Future</code>的<strong>局限性</strong>了。</li>
</ul>
<ol>
<li><strong>我们很难表述<code>Future</code>结果之间的依赖性</strong>。比如这样一个案例：“当长时间计算任务完成时，请将该计算的结果通知到另一个长时间运行的计算任务，这两个计算任务都完成后，将计算的结果与另一个查询操作结果合并”。</li>
<li><strong>以下场景，<code>Future</code>都难以表述：</strong><ul>
<li>将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。</li>
<li>等待Future集合中的所有任务都完成。</li>
<li>仅等待Future集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。</li>
<li>通过编程方式完成一个Future任务的执行（即以手工设定异步操作结果的方式）。</li>
<li>应对Future的完成事件（即当Future的完成事件发生时会收到通知，并能使用Future计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）。</li>
</ul>
</li>
</ol>
<h4 id="（三）CompetableFuture与Future间的关系"><a href="#（三）CompetableFuture与Future间的关系" class="headerlink" title="（三）CompetableFuture与Future间的关系"></a>（三）CompetableFuture与Future间的关系</h4><p><code>CompetableFuture</code>之于<code>Future</code>，相当于<code>Stream</code>之于<code>Collection</code>。</p>
<h4 id="（四）CompetableFuture的一些用法"><a href="#（四）CompetableFuture的一些用法" class="headerlink" title="（四）CompetableFuture的一些用法"></a>（四）CompetableFuture的一些用法</h4><ul>
<li><p>CompetableFuture的一些静态方法，直接简化创建Thread的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;Double&gt; getPriceAsync(String product) &#123;</span><br><span class="line">      CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();</span><br><span class="line">      new Thread(() -&gt; &#123;</span><br><span class="line">          double price = calculatePrice(product);</span><br><span class="line">          futurePrice.complete(price);</span><br><span class="line">      &#125;).start();</span><br><span class="line">      return futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接变成一句话</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;Double&gt; getPriceAsync(String product) &#123;</span><br><span class="line">    return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>supplyAsync方法接受一个生产者（Supplier）作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。生产者方法会交由ForkJoinPool池中的某个执行线程（Executor）运行，但是你也可以使用supplyAsync方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。</p>
</blockquote>
</li>
<li><p>再来一个例子，之前是一家Shop做异步处理，这还不能发挥此接口的最大效用，所以，这次，来一打Shops，比较最佳售价。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;Shop&gt; shops = Lists.newArrayList(new Shop(&quot;BestPrice&quot;),</span><br><span class="line">      new Shop(&quot;LetsSaveBig&quot;),</span><br><span class="line">      new Shop(&quot;MyFavoriteShop&quot;),</span><br><span class="line">      new Shop(&quot;BuyItAll&quot;));</span><br></pre></td></tr></table></figure>
<p>一般情况下，用并行流和CompletableFuture的异步效果是半斤八两的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// 并行流的方式</span><br><span class="line">public List&lt;String&gt; findPricesParallel(String product) &#123;</span><br><span class="line">      return shops.parallelStream()</span><br><span class="line">              .map(shop -&gt; String.format(&quot;%s 价格 %.2f&quot;, shop.getName() , shop.getPrice(product)))</span><br><span class="line">              .collect(toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CompletableFuture的方式</span><br><span class="line">public List&lt;String&gt; findPricesFuture(String product) &#123;</span><br><span class="line">      List&lt;CompletableFuture&lt;String&gt;&gt; completableFutures = shops.stream()</span><br><span class="line">                  .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; String.format(&quot;%s 价格 %.2f&quot;, shop.getName(), shop.getPrice(product))))</span><br><span class="line">                  .collect(toList());</span><br><span class="line">      return completableFutures</span><br><span class="line">              .stream()</span><br><span class="line">              .map(CompletableFuture::join)</span><br><span class="line">              .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认<code>CompletableFuture.supplyAsyn()</code>内部使用的线程池和<code>ParallelStream</code>使用的是同一个线程池，是默认的固定线程数量的线程池，这个线程数由CPU、JVM配置等决定。</p>
<blockquote>
<p>具体线程数取决于<code>Runtime.getRuntime().availableProcessors()</code>的返回值</p>
</blockquote>
<p><strong>但是，<code>CompletableFuture</code>是可以配置<code>supplyAsyn()</code>中使用的ThreadFactory的，而<code>ParallelStream</code>是不能的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 使用自定义的线程池</span><br><span class="line">  private final Executor executor = Executors.newFixedThreadPool(100, new ThreadFactory() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Thread newThread(Runnable runnable) &#123;</span><br><span class="line">          Thread t = new Thread(runnable);</span><br><span class="line">          t.setDaemon(true);</span><br><span class="line">          return t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">public List&lt;String&gt; findPricesFuture(String product) &#123;</span><br><span class="line">      return shops.stream()</span><br><span class="line">              .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;&quot; + shop.getPrice(), executor))</span><br><span class="line">              .collect(toList())</span><br><span class="line">              .stream()</span><br><span class="line">              .map(CompletableFuture::join)</span><br><span class="line">              .collect(toList());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发，用并行流还是CompletableFuture？"><a href="#并发，用并行流还是CompletableFuture？" class="headerlink" title="并发，用并行流还是CompletableFuture？"></a>并发，用并行流还是CompletableFuture？</h3><p>情况 | 推荐 | 原因</p>
</li>
</ul>
<p>— | — | —<br>如果你进行的是计算密集型的操作，并且没有I/O | Stream | 实现简单<br>如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待）| CompletableFuture | 高灵活性</p>
<h1 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>Java 1.0<ul>
<li>特点：只有java.util.Date类</li>
<li>缺点：这个类无法表示日期，只能以毫秒的精度表示时间。而且，易用性差，如：<code>Date date = new Date(114, 2, 18);</code>居然表示2014年3月18日。</li>
</ul>
</li>
<li>Java 1.1<ul>
<li>更新：Date类中的很多方法被废弃了，取而代之的是java.util.Calendar类</li>
<li>缺点：Calendar类同样很难用，比如：<ul>
<li>月份依旧是从0开始计算（不过，至少Calendar类拿掉了由1900年开始计算年份这一设计）</li>
<li>DateFormat方法也有它自己的问题，它不是线程安全的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a>LocalDate和LocalTime</h3><p>相关类：</p>
<ul>
<li><code>java.time.LocalDate</code></li>
<li><code>java.time.LocalTime</code></li>
<li><code>java.time.LocalDateTime</code></li>
</ul>
<p>三个类都实现了各种基本计算方法、parse方法、比较方法， 以及各种静态方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2018, 11, 25);</span><br><span class="line">int year = localDate.getYear();// 2018</span><br><span class="line">Month month = localDate.getMonth(); // 11</span><br><span class="line">int day = localDate.getDayOfMonth(); // 25</span><br><span class="line">DayOfWeek dow = localDate.getDayOfWeek(); // SUNDAY</span><br><span class="line">int len = localDate.lengthOfMonth(); // 本月总天数： 30</span><br><span class="line">boolean leap = localDate.isLeapYear(); // 是不是闰年： false</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">int year = localDate.get(ChronoField.YEAR);</span><br><span class="line">int month = localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">int day = localDate.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">int hour = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">int minute = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">int second = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime); // 2018-11-25T22:10:08.721</span><br><span class="line">System.out.println(localDateTime.atZone(ZoneId.of(&quot;GMT&quot;))); // 2018-11-25T22:11:08.778Z[GMT]</span><br><span class="line">System.out.println(localDateTime.atOffset(ZoneOffset.UTC)); // 2018-11-25T22:11:44.362Z</span><br></pre></td></tr></table></figure>

<h3 id="机器的日期和时间格式"><a href="#机器的日期和时间格式" class="headerlink" title="机器的日期和时间格式"></a>机器的日期和时间格式</h3><blockquote>
<p>从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。</p>
</blockquote>
<ul>
<li><p>相关类：</p>
<ul>
<li><code>java.time.Instant</code></li>
</ul>
</li>
<li><p>建模方式：以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
</li>
<li><p>作用：适用于计算机做高精度运算。</p>
</li>
<li><p>用法实例</p>
<ul>
<li>Instant.ofEpochSecond(秒/long, 纳秒/long)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant.ofEpochSecond(3); // 1970-01-01T00:00:03Z</span><br><span class="line">Instant.ofEpochSecond(3, 0);</span><br><span class="line">Instant.ofEpochSecond(2, 1_000_000_000); // 2 秒之后再加上100万纳秒（1秒）</span><br><span class="line">Instant.ofEpochSecond(4, -1_000_000_000); // 4秒之前的100万纳秒（1秒）</span><br></pre></td></tr></table></figure>
<h3 id="Duration-Period"><a href="#Duration-Period" class="headerlink" title="Duration/Period"></a>Duration/Period</h3><h4 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h4></li>
</ul>
</li>
<li><p>作用：Duration类主要用于以秒和纳秒衡量时间的长短</p>
</li>
<li><p>注意：不要用机器时间相关API来计算Duration，你看不懂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time1 = LocalTime.of(21, 50, 10);</span><br><span class="line">LocalTime time2 = LocalTime.of(22, 50, 10);</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.of(2018, 11, 17, 21, 50, 10);</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(2018, 11, 17, 23, 50, 10);</span><br><span class="line">Instant instant1 = Instant.ofEpochSecond(1000 * 60 * 2);</span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(1000 * 60 * 3);</span><br><span class="line"></span><br><span class="line">// 可用工厂方法定义</span><br><span class="line">Duration threeMinutes = Duration.ofMinutes(3);</span><br><span class="line">Duration fourMinutes = Duration.of(4, ChronoUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d2 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d3 = Duration.between(instant1, instant2);</span><br><span class="line">// PT1H 相差1小时</span><br><span class="line">System.out.println(&quot;d1:&quot; + d1);</span><br><span class="line">// PT2H 相差2小时</span><br><span class="line">System.out.println(&quot;d2:&quot; + d2);</span><br><span class="line">// PT16H40M 相差16小时40分钟</span><br><span class="line">System.out.println(&quot;d3:&quot; + d3);</span><br></pre></td></tr></table></figure>
<p>而且，不要试图在这两类对象之间创建duration，会触发一个DateTimeException异常。而且，不要放一个LocalDate对象作为参数，不合适。</p>
</li>
</ul>
<h4 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h4><ul>
<li>作用：以年、月或者日的方式对多个时间单位建模</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可用工厂方法定义</span><br><span class="line">Period tenDay = Period.ofDays(10);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(3);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1);</span><br><span class="line"></span><br><span class="line">Period period = Period.between(LocalDate.of(2018, 11, 7), LocalDate.of(2018, 11, 17));</span><br><span class="line">System.out.println(&quot;Period between:&quot; + period); // P10D 相差10天</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改、构造时间"><a href="#修改、构造时间" class="headerlink" title="修改、构造时间"></a>修改、构造时间</h3><p>简单来说，API给我们划分了读取和修改两类方法：</p>
<ul>
<li>读：<code>get</code></li>
<li>修改：<code>with</code></li>
</ul>
<p>下面这些方法都会生成一个新的时间对象，不会修改源对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 2018-11-17</span><br><span class="line">LocalDate date1 = LocalDate.of(2018, 11, 17);</span><br><span class="line">// 2019-11-17</span><br><span class="line">LocalDate date2 = date1.withYear(2019);</span><br><span class="line">// 2019-11-25</span><br><span class="line">LocalDate date3 = date2.withDayOfMonth(25);</span><br><span class="line">// 2019-09-25</span><br><span class="line">LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, 9);</span><br></pre></td></tr></table></figure>
<h4 id="特别：用TemporalAdjuster实现复杂操作"><a href="#特别：用TemporalAdjuster实现复杂操作" class="headerlink" title="特别：用TemporalAdjuster实现复杂操作"></a>特别：用TemporalAdjuster实现复杂操作</h4><p>利用重写各种<code>withXX</code>方法，并自定义<code>TemporalAdjuster</code>参数，就能实现复杂的时间操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 2018-11-17</span><br><span class="line">LocalDate date1 = LocalDate.of(2018, 11, 17);</span><br><span class="line">// 2018-11-19</span><br><span class="line">LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">// 2018-11-30</span><br><span class="line">LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure>
<p>我们看看这个<code>用TemporalAdjuster</code>接口，其实要自定义很简单，因为它只有一个接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface TemporalAdjuster &#123;</span><br><span class="line">    Temporal adjustInto(Temporal temporal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><ul>
<li>相关类：<ul>
<li><code>java.time.format.DateTimeFormatter</code></li>
<li><code>java.time.format.DateTimeFormatterBuilder</code>：用于实现更加复杂的格式化</li>
</ul>
</li>
<li>特点：<ul>
<li>所有的<code>DateTimeFormatter</code>实例都是<strong>线程安全</strong>的。（所以，你能够以单例模式创建格式器实例，就像DateTimeFormatter所定义的那些常量，并能在多个线程间共享这些实例。）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Date 转 String</span><br><span class="line">LocalDate date1 = LocalDate.of(2018, 11, 17);</span><br><span class="line">String s1 = date1.format(DateTimeFormatter.BASIC_ISO_DATE); // 20181117</span><br><span class="line">String s2 = date1.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2018-11-17</span><br><span class="line">// String 转 Date</span><br><span class="line">LocalDate date2 = LocalDate.parse(&quot;20181117&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date3 = LocalDate.parse(&quot;2018-11-17&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line">DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(&quot;d. MMMM yyyy&quot;, Locale.ITALIAN);</span><br><span class="line">LocalDate date5 = LocalDate.of(2018, 11, 16);</span><br><span class="line">// 16. novembre 2018</span><br><span class="line">String formattedDate2 = date5.format(italianFormatter);</span><br><span class="line">// 2018-11-16</span><br><span class="line">LocalDate date6 = LocalDate.parse(formattedDate2, italianFormatter);</span><br></pre></td></tr></table></figure>
<p>用<code>DateTimeFormatterBuilder</code>实现细粒度格式化控制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder()</span><br><span class="line">                .appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">                .appendLiteral(&quot;. &quot;)</span><br><span class="line">                .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">                .appendLiteral(&quot; &quot;)</span><br><span class="line">                .appendText(ChronoField.YEAR)</span><br><span class="line">                .parseCaseInsensitive()</span><br><span class="line">                .toFormatter(Locale.ITALIAN);</span><br><span class="line"></span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">// 17. novembre 2018</span><br><span class="line">String s1 = now.format(italianFormatter);</span><br></pre></td></tr></table></figure>

<h3 id="处理不同的时区和历法"><a href="#处理不同的时区和历法" class="headerlink" title="处理不同的时区和历法"></a>处理不同的时区和历法</h3><ul>
<li>相关类：<ul>
<li><code>java.time.ZoneId</code> </li>
<li><code>java.time.ZoneOffset</code></li>
</ul>
</li>
<li>特点：<ul>
<li>新的<code>java.time.ZoneId</code>类是老版<code>java.util.TimeZone</code>的替代品。</li>
<li>更容易处理日光时（Daylight Saving Time，DST）这种问题。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> // 地区ID都为“&#123;区域&#125;/&#123;城市&#125;”的格式</span><br><span class="line">ZoneId shanghaiZone = ZoneId.of(&quot;Asia/Shanghai&quot;);</span><br><span class="line"></span><br><span class="line">LocalDate date = LocalDate.of(2018, 11, 17);</span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(2018, 11, 27, 18, 13, 15);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// LocalDateTime 转 Instant</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(2018, 11, 17, 18, 45);</span><br><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(&quot;-05:00&quot;);</span><br><span class="line">Instant instantFromDateTime = dateTime2.toInstant(newYorkOffset);</span><br><span class="line"></span><br><span class="line">// 通过反向的方式得到LocalDateTime对象</span><br><span class="line">Instant instant2 = Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant2, shanghaiZone);</span><br><span class="line"></span><br><span class="line">// OffsetDateTime，它使用ISO-8601的历法系统，以相对于UTC/格林尼治时间的偏差方式表示日期时间。</span><br><span class="line">LocalDateTime dateTime3 = LocalDateTime.of(2018, 11, 17, 18, 45);</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime3, newYorkOffset);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.png" alt="Jasper Wu wechat" style="width: 200px; max-width: 100%;">
  <div>喜欢的朋友可以关注 "JP技术栈" 微信公众号，每周更新笔者最新分享技术文章~</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/jdk/" rel="tag"># jdk</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/Spring%20Boot%20%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%20--%20@Component%20%E4%B8%8E%20@Configuration/" rel="next" title="Spring Boot 深入源码 -- @Component 与 @Configuration">
                  <i class="fa fa-chevron-left"></i> Spring Boot 深入源码 -- @Component 与 @Configuration
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/JDK9-JDK11%E7%89%B9%E6%80%A7%E7%AE%80%E8%AF%BB/" rel="prev" title="JDK9~JDK11特性简读">
                  JDK9~JDK11特性简读 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#新特性总览"><span class="nav-number">1.</span> <span class="nav-text">新特性总览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">2.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">3.</span> <span class="nav-text">Stream</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Optional"><span class="nav-number">4.</span> <span class="nav-text">Optional</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式编程（Stream-Lambda）"><span class="nav-number">5.</span> <span class="nav-text">函数式编程（Stream+Lambda）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">5.0.1.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-for循环取数组最小值"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">1. for循环取数组最小值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-接口的实现-匿名内部类转Lambda"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">2. 接口的实现/匿名内部类转Lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Lambda创建自定义接口的实例对象"><span class="nav-number">5.0.1.3.</span> <span class="nav-text">3. Lambda创建自定义接口的实例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Lambda与Function"><span class="nav-number">5.0.1.4.</span> <span class="nav-text">4. Lambda与Function</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda-与-设计模式"><span class="nav-number">6.</span> <span class="nav-text">Lambda 与 设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#策略模式"><span class="nav-number">6.0.1.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板模式（抽象类的应用）"><span class="nav-number">6.0.2.</span> <span class="nav-text">模板模式（抽象类的应用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者模式"><span class="nav-number">6.0.3.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#责任链模式"><span class="nav-number">6.0.4.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂模式"><span class="nav-number">6.0.5.</span> <span class="nav-text">工厂模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#默认方法"><span class="nav-number">7.</span> <span class="nav-text">默认方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Jdk8开始支持的东西"><span class="nav-number">7.0.1.</span> <span class="nav-text">Jdk8开始支持的东西</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">7.0.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决继承链上的冲突的规则"><span class="nav-number">7.0.3.</span> <span class="nav-text">解决继承链上的冲突的规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合式异步编程"><span class="nav-number">8.</span> <span class="nav-text">组合式异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RecursiveTask（JDK-1-7）"><span class="nav-number">8.0.1.</span> <span class="nav-text">RecursiveTask（JDK 1.7）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spliterator（可分迭代器-JDK-1-8）"><span class="nav-number">8.0.2.</span> <span class="nav-text">Spliterator（可分迭代器 JDK 1.8）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（一）背景"><span class="nav-number">8.0.2.1.</span> <span class="nav-text">（一）背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二）例子"><span class="nav-number">8.0.2.2.</span> <span class="nav-text">（二）例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture（Jdk-1-8）"><span class="nav-number">8.0.3.</span> <span class="nav-text">CompletableFuture（Jdk 1.8）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（一）一个商店商品报价的例子"><span class="nav-number">8.0.3.1.</span> <span class="nav-text">（一）一个商店商品报价的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（二）Future的局限性"><span class="nav-number">8.0.3.2.</span> <span class="nav-text">（二）Future的局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（三）CompetableFuture与Future间的关系"><span class="nav-number">8.0.3.3.</span> <span class="nav-text">（三）CompetableFuture与Future间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（四）CompetableFuture的一些用法"><span class="nav-number">8.0.3.4.</span> <span class="nav-text">（四）CompetableFuture的一些用法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发，用并行流还是CompletableFuture？"><span class="nav-number">8.0.4.</span> <span class="nav-text">并发，用并行流还是CompletableFuture？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#新的日期和时间API"><span class="nav-number">9.</span> <span class="nav-text">新的日期和时间API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背景"><span class="nav-number">9.0.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalDate和LocalTime"><span class="nav-number">9.0.2.</span> <span class="nav-text">LocalDate和LocalTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#机器的日期和时间格式"><span class="nav-number">9.0.3.</span> <span class="nav-text">机器的日期和时间格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Duration-Period"><span class="nav-number">9.0.4.</span> <span class="nav-text">Duration/Period</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Duration"><span class="nav-number">9.0.4.1.</span> <span class="nav-text">Duration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Period"><span class="nav-number">9.0.4.2.</span> <span class="nav-text">Period</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改、构造时间"><span class="nav-number">9.0.5.</span> <span class="nav-text">修改、构造时间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特别：用TemporalAdjuster实现复杂操作"><span class="nav-number">9.0.5.1.</span> <span class="nav-text">特别：用TemporalAdjuster实现复杂操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Format"><span class="nav-number">9.0.6.</span> <span class="nav-text">Format</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理不同的时区和历法"><span class="nav-number">9.0.7.</span> <span class="nav-text">处理不同的时区和历法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Jasper Wu"
    src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jasper Wu</p>
  <div class="site-description" itemprop="description">醒目点、自觉点、速度点，努力奋斗下去，走好自己的路！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/androidjp" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;androidjp" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1049578026@qq.com" title="E-Mail &amp;rarr; mailto:1049578026@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jasper Wu</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'default',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  

  

</body>
</html>
