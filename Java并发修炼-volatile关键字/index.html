<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-smile.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-smile.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="如何理解volatile关键字被 volatile 修饰的共享变量，会满足以下两个性质： 保证了不同线程对该变量操作的内存可见性; 禁止指令重排序 什么是内存可见性我们先回顾以下JMM（Java内存模型）。Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快">
<meta name="keywords" content="java,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发修炼--volatile关键字">
<meta property="og:url" content="http:&#x2F;&#x2F;jpuneng.cn&#x2F;Java%E5%B9%B6%E5%8F%91%E4%BF%AE%E7%82%BC-volatile%E5%85%B3%E9%94%AE%E5%AD%97&#x2F;index.html">
<meta property="og:site_name" content="jpuneng技术栈">
<meta property="og:description" content="如何理解volatile关键字被 volatile 修饰的共享变量，会满足以下两个性质： 保证了不同线程对该变量操作的内存可见性; 禁止指令重排序 什么是内存可见性我们先回顾以下JMM（Java内存模型）。Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;s2.ax1x.com&#x2F;2020&#x2F;01&#x2F;12&#x2F;loAC2d.png">
<meta property="og:image" content="https:&#x2F;&#x2F;s2.ax1x.com&#x2F;2020&#x2F;01&#x2F;12&#x2F;loAC2d.png">
<meta property="og:updated_time" content="2020-09-27T03:15:04.260Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;s2.ax1x.com&#x2F;2020&#x2F;01&#x2F;12&#x2F;loAC2d.png">

<link rel="canonical" href="http://jpuneng.cn/Java%E5%B9%B6%E5%8F%91%E4%BF%AE%E7%82%BC-volatile%E5%85%B3%E9%94%AE%E5%AD%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Java并发修炼--volatile关键字 | jpuneng技术栈</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jpuneng技术栈</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">技术时代，舍我其谁</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jpuneng.cn/Java%E5%B9%B6%E5%8F%91%E4%BF%AE%E7%82%BC-volatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jasper Wu">
      <meta itemprop="description" content="醒目点、自觉点、速度点，努力奋斗下去，走好自己的路！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jpuneng技术栈">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发修炼--volatile关键字
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 09:51:43" itemprop="dateCreated datePublished" datetime="2019-10-12T09:51:43+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 11:15:04" itemprop="dateModified" datetime="2020-09-27T11:15:04+08:00">2020-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="如何理解volatile关键字"><a href="#如何理解volatile关键字" class="headerlink" title="如何理解volatile关键字"></a>如何理解volatile关键字</h1><p>被 <code>volatile</code> 修饰的共享变量，会满足以下两个性质：</p><ul>
<li>保证了不同线程对该变量操作的内存可见性;</li>
<li>禁止指令重排序</li>
</ul><h1 id="什么是内存可见性"><a href="#什么是内存可见性" class="headerlink" title="什么是内存可见性"></a>什么是内存可见性</h1><p>我们先回顾以下JMM（Java内存模型）。</p><p>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级（就速度而言：CPU高速缓存 &gt;&gt; 内存 &gt;&gt; 磁盘），所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</p><a id="more"></a>



<p>JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p>
<blockquote>
<p>相当于：我和妈妈分别在各自手机中缓存我的vlog，虽然vlog在网络上是大家共享的资源，但是还是缓存在各自的手机上，想看不用等。看完后我和妈妈都可以修改我的vlog，修改好可以立即上传到网络，也可以等一会再上传。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/01/12/loAC2d.png" alt="loAC2d.png"></p>
<p>线程执行时：</p>
<ol>
<li>首先会从主存中read变量值；</li>
<li>再将变量值load到工作内存中的副本中；</li>
<li>然后再传给处理器执行；</li>
<li>在执行完毕后再给工作内存中的副本赋值；</li>
<li>随后工作内存再把值传回给主内存，此时，主存更新</li>
</ol>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i = 1;</span><br></pre></td></tr></table></figure>
<p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>load i from 主存（i = 0）</td>
<td></td>
</tr>
<tr>
<td>i+1（i = 1）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>load i from 主存（i = 0）</td>
</tr>
<tr>
<td></td>
<td>i+1（i = 1）</td>
</tr>
<tr>
<td>save i to 主存（i = 1）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>save i to 主存（i = 1）</td>
</tr>
</tbody></table>
<p>这样一来，就可能出现 “少加” 的情况，如果最后的写回生效的慢，你再读取i的值，都可能是0，也就是<strong>缓存不一致问题</strong>。</p>
<p>JMM主要就是围绕着如何在并发过程中如何处理<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而<code>volatile</code>跟<strong>可见性</strong>和<strong>有序性</strong>都有关。</p>
<blockquote>
<p>注意，这里说的几个特征，是说的JMM要解决和保证的特征，类似的，事务也有几大特性：ACID</p>
<ul>
<li>Atomicity 原子性</li>
<li>Consistency 一致性</li>
<li>Isolcation 隔离性</li>
<li>Durability 持久性</li>
</ul>
<p>这两者所说的，也就只有 “原子性”可以相提并论。所以，不要搞混！</p>
</blockquote>
<h2 id="1-原子性（Atomicty）"><a href="#1-原子性（Atomicty）" class="headerlink" title="1. 原子性（Atomicty）"></a>1. 原子性（Atomicty）</h2><p>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 2;     // 原子性操作</span><br><span class="line">j = i;     // 2步操作：先读取i的值，然后赋值给j</span><br><span class="line">i++;       // 3步操作：先读取i的值，然后加1，最后写回主内存</span><br><span class="line">i = i + 1; // 3步操作：同上</span><br></pre></td></tr></table></figure>
<p>所以，严格来说，只有<code>i = 2;</code> 满足原子性。</p>
<blockquote>
<p>有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</p>
</blockquote>
<p>JMM只实现了基本的原子性，像上面<code>i++</code>那样的操作，必须借助于<code>synchronized</code>和<code>Lock</code>来保证整块代码的原子性了。线程在释放锁之前，必然会把 <code>i</code> 的值刷回到主存的。</p>
<h2 id="2-可见性（Visibility）"><a href="#2-可见性（Visibility）" class="headerlink" title="2. 可见性（Visibility）"></a>2. 可见性（Visibility）</h2><p>说到可见性，Java就是利用volatile来提供可见性的。<br>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。<br>其实通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是<code>synchronized</code>和<code>Lock</code>的开销都更大。</p>
<p>综上所述，我们得有一个认识：<code>volatile</code>和<code>synchronized</code>所说的“可见性”，实际上都是基于锁，或者一种约定，这个在后面会说。</p>
<h2 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3. 有序性（Ordering）"></a>3. 有序性（Ordering）</h2><p>JMM是允许编译器和处理器对指令重排序的，但是规定了<strong>as-if-serial</strong>语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;    //A</span><br><span class="line">double r = 1;        //B</span><br><span class="line">double s= pi * r * r;//C</span><br></pre></td></tr></table></figure>
<p>以上代码，可以是 <code>A -&gt; B -&gt; C</code>，也可以是 <code>B -&gt; A -&gt; C</code>，因为A和B相互不依赖，而C则依赖A和B，所以，A和B随便怎么换，但是C不能排到A或B前面。<strong>JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题</strong>。</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，如果单线程执行<code>write() -&gt; multiply()</code> 是完全没问题的。但是，如果线程A执行<code>write</code>，线程B执行<code>multiply</code>，那就可能出现<strong>多线程时指令重排序问题（无法保证多线程时的结果最终一致性）</strong></p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>flag = true;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>if(flag)</td>
</tr>
<tr>
<td></td>
<td>int ret = a * a;</td>
</tr>
<tr>
<td>a = 2;</td>
<td></td>
</tr>
</tbody></table>
<p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p>
<h1 id="JMM具备一些先天的有序性"><a href="#JMM具备一些先天的有序性" class="headerlink" title="JMM具备一些先天的有序性"></a>JMM具备一些先天的有序性</h1><p>JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。<code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code>定义了如下happens-before规则：</p>
<blockquote>
<ol>
<li><strong>程序顺序规则</strong>： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li><strong>监视器锁规则</strong>：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li><strong>volatile变量规则</strong>： 对一个volatile域的<strong>写</strong>，happens-before于后续对这个volatile域的<strong>读</strong></li>
<li><strong>传递性</strong>：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li><strong>start()规则</strong>： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li><strong>join()原则</strong>： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li><strong>interrupt()原则</strong>： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li><strong>finalize()原则</strong>：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ol>
</blockquote>
<p>第1条规则—程序顺序规则，是说在一个线程里，所有的操作都是按顺序的，<strong>但是</strong>在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p>
<p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p>
<p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
<p>第4条规则，就是happens-before的传递性。<br>后面几条就不再一一赘述了。</p>
<h1 id="volatile关键字如何保证可见性和有序性"><a href="#volatile关键字如何保证可见性和有序性" class="headerlink" title="volatile关键字如何保证可见性和有序性"></a>volatile关键字如何保证可见性和有序性</h1><p>那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。<br>这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p>
<p>如果这样不能理解，或者我们重看文章开头的图：<br><img src="https://s2.ax1x.com/2020/01/12/loAC2d.png" alt="loAC2d.png"><br>volatile的特殊性在于：</p>
<ol>
<li>操作 <code>use</code> 之前必须先执行 <code>read</code>和<code>load</code>操作。</li>
<li>操作 <code>assign</code> 之后必须执行 <code>store</code>和<code>write</code>操作。</li>
</ol>
<p>由特性性保证了read、load和use的操作连续性，assign、store和write的操作连续性，从而达到工作内存读取前必须刷新主存最新值；工作内存写入后必须同步到主存中。读取的连续性和写入的连续性，看上去像线程直接操作了主存，又因为主存实际是多线程可见的，于是可见性就体现了出来。</p>
<blockquote>
<p> 扩展：<br>上图的lock和unlock操作并不直接开放给用户使用，而是提供给像Synchronize关键字指定monitorenter和monitorexit隐式使用。关于Synchronize的监听器锁monitor，javac编译后会在作用的方法前后增加monitorenter和monitorexit指令，详细的可以查看Synchronize原理。</p>
</blockquote>
<p>继续看回上面提到的case代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种正常在多线程情况下，除了指令重排序的风险，也会有线程执行先后顺序的问题。也就是说，即使<code>1 --&gt; 2</code> 不会变成<code>2 --&gt; 1</code>，<code>2</code>和<code>3</code>的执行顺序也不一定就是<code>2--&gt;3</code>，因为是多个线程在跑。</p>
<p>我们让<code>flag</code>加上<code>volatile</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么线程A先执行<code>write</code>,线程B再执行<code>multiply</code>。根据happens-before原则，这个过程会满足以下3类规则：</p>
<ol>
<li>程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在 2 之前执行)</li>
<li>volatile规则：2 happens-before 3</li>
<li>传递性规则：1 happens-before 4</li>
</ol>
<p>从内存语义上来看:</p>
<ul>
<li><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</strong></li>
<li><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量</strong></li>
</ul>
<h1 id="volatile关键字能否保证原子性"><a href="#volatile关键字能否保证原子性" class="headerlink" title="volatile关键字能否保证原子性"></a>volatile关键字能否保证原子性</h1><p><strong>不能</strong>。</p>
<p>硬要说能，就是得看角度了。前面我们说单个变量的读/写操作，具有原子性，这个性质在Java里头是基本规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(6000L);</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你很容易得到一个小于10000的值。</p>
<p>有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p>
<p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p>
<p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p>
<p>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</p>
<p>有人说，<code>volatile不是会使缓存行无效的吗？</code>但是这里线程A读取时，线程B还没有进行修改操作，所以并没有修改inc值，并不会触发volatile功能，所以线程B读取的时候，还是读的10，因为B不知道A要修改inc。</p>
<p>又有人说，线程B将11写回主存，<code>不会把线程A的缓存行设为无效吗？</code>但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p>
<p>因此，要想保证原子性，只能借助于<code>synchronized</code>,<code>Lock</code>以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<h1 id="volatile底层实现机制"><a href="#volatile底层实现机制" class="headerlink" title="volatile底层实现机制"></a>volatile底层实现机制</h1><p>通过在volatile变量的操作前后插入<strong>内存屏障</strong>的方式，控制后置指令排序无法排到屏障之前，并且使得CPU的Cache写入内存，写入动作也会触发别的CPU或内核无效化其Cache。</p>
<p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p>
<p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p>
<ol>
<li>重排序时不能把后面的指令重排序到内存屏障之前的位置；</li>
<li>使得本CPU的Cache写入内存；</li>
<li>写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</li>
</ol>
<h1 id="volatile-与-synchronized-的关系"><a href="#volatile-与-synchronized-的关系" class="headerlink" title="volatile 与 synchronized 的关系"></a>volatile 与 synchronized 的关系</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>volatile 与 synchronized 都属于关键字。</p>
<p>volatile 与 synchronized 都能保证可见性和有序性。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>只是分别对应的有序性规则不同，且实现方式也不同：</p>
<ul>
<li>volatile角度的有序性偏向于对目标对象的“写”操作必须保证在“读”操作之前，并通过内存屏障去保证目标对象相关代码的执行顺序。</li>
<li>synchronized 角度来看并不是说代码连执行顺序都不能变，而是想要保证最终结果一致性，然后，相关可优化的代码还是可以被重排序的。并通过加锁机制，并不是锁定代码执行顺序，而是锁定“厕所门”，同一时间片下，只能也给一个线程执行这一段被“锁”住的代码。</li>
</ul>
<blockquote>
<p>synchronized是无法禁止指令重排和处理器优化的。那么他是如何保证的有序性呢？</p>
<p>答： 这和as-if-serial语义有关。as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。简单说就是，as-if-serial语义保证了单线程中，不管指令怎么重排，最终的执行结果是不能被改变的。</p>
</blockquote>
<p>volatile关键字是无法保证原子性的，而synchronized通过monitorenter和monitorexit两个指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，即可保证不会出现CPU时间片在多个线程间切换，即可保证原子性。</p>
<h2 id="synchronized-比-volatile-重"><a href="#synchronized-比-volatile-重" class="headerlink" title="synchronized 比 volatile 重"></a>synchronized 比 volatile 重</h2><p>synchronized其实是一种加锁机制，那么既然是锁，天然就具备以下几个缺点：</p>
<ol>
<li><p>有性能损耗</p>
<blockquote>
<p>虽然在JDK 1.6中对synchronized做了很多优化，如如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等，但是他毕竟还是一种锁。</p>
<p>以上这几种优化，都是尽量想办法避免对Monitor进行加锁，但是，并不是所有情况都可以优化的，况且就算是经过优化，优化的过程也是有一定的耗时的。</p>
<p>所以，无论是使用同步方法还是同步代码块，在同步操作之前还是要进行加锁，同步操作之后需要进行解锁，这个加锁、解锁的过程是要有性能损耗的。</p>
<p>关于二者的性能对比，由于虚拟机对锁实行的许多消除和优化，使得我们很难量化这两者之间的性能差距，但是我们可以确定的一个基本原则是：volatile变量的读操作的性能小号普通变量几乎无差别，但是写操作由于需要插入内存屏障所以会慢一些，即便如此，volatile在大多数场景下也比锁的开销要低。</p>
</blockquote>
</li>
<li><p>产生阻塞</p>
<blockquote>
<p>无论是同步方法还是同步代码块，无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的。</p>
<p>基于Monitor对象，当多个线程同时访问一段同步代码时，首先会进入Entry Set，当有一个线程获取到对象的锁之后，才能进行The Owner区域，其他线程还会继续在Entry Set等待。并且当某个线程调用了wait方法后，会释放锁并进入Wait Set等待。</p>
</blockquote>
</li>
</ol>
<p>所以，synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。</p>
<p>而volatile是Java虚拟机提供的一种轻量级同步机制，他是基于内存屏障实现的。说到底，他并不是锁，所以他不会有synchronized带来的阻塞和性能损耗的问题。</p>
<h1 id="为什么DSL的单例模式中，instance要有volatile？"><a href="#为什么DSL的单例模式中，instance要有volatile？" class="headerlink" title="为什么DSL的单例模式中，instance要有volatile？"></a>为什么DSL的单例模式中，instance要有volatile？</h1><p>看看以下这个单例，一个典型的不完善的DSL（双重锁检查）单例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    privat Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized(Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么说它不完善呢？ 虽然在<code>synchronized</code>同步代码块内，能够保证同一时刻只会有一个线程执行，但是，<code>instance = new Singleton();</code> 始终是一个复合操作，相当于 2个步骤：</p>
<ol>
<li>JVM为对象分配一块内存M；</li>
<li>在内存M上为对象进行初始化<code>new Singleton()</code>；</li>
<li>将内存M的地址复制给instance变量：<code>instance = addr</code></li>
</ol>
<p>所以可能会出现 <code>1 --&gt; 3 --&gt; 2</code>这样的指令重排序情况，最终拿到了一个不完整的singleton对象，极有可能发生NPE异常，所以，加上<code>volatile</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    privat Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized(Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center;">
  <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.png" alt="Jasper Wu wechat" style="width: 200px; max-width: 100%;">
  <div>喜欢的朋友可以关注 "JP技术栈" 微信公众号，每周更新笔者最新分享技术文章~</div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># 多线程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/" rel="next" title="如何让线程顺序执行">
                  <i class="fa fa-chevron-left"></i> 如何让线程顺序执行
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/Spring%20Boot%20%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%20--%20@Import/" rel="prev" title="Spring Boot 深入源码 -- @Import">
                  Spring Boot 深入源码 -- @Import <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#如何理解volatile关键字"><span class="nav-number">1.</span> <span class="nav-text">如何理解volatile关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是内存可见性"><span class="nav-number">2.</span> <span class="nav-text">什么是内存可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-原子性（Atomicty）"><span class="nav-number">2.1.</span> <span class="nav-text">1. 原子性（Atomicty）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-可见性（Visibility）"><span class="nav-number">2.2.</span> <span class="nav-text">2. 可见性（Visibility）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-有序性（Ordering）"><span class="nav-number">2.3.</span> <span class="nav-text">3. 有序性（Ordering）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMM具备一些先天的有序性"><span class="nav-number">3.</span> <span class="nav-text">JMM具备一些先天的有序性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile关键字如何保证可见性和有序性"><span class="nav-number">4.</span> <span class="nav-text">volatile关键字如何保证可见性和有序性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile关键字能否保证原子性"><span class="nav-number">5.</span> <span class="nav-text">volatile关键字能否保证原子性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile底层实现机制"><span class="nav-number">6.</span> <span class="nav-text">volatile底层实现机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile-与-synchronized-的关系"><span class="nav-number">7.</span> <span class="nav-text">volatile 与 synchronized 的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相同点"><span class="nav-number">7.1.</span> <span class="nav-text">相同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区别"><span class="nav-number">7.2.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-比-volatile-重"><span class="nav-number">7.3.</span> <span class="nav-text">synchronized 比 volatile 重</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么DSL的单例模式中，instance要有volatile？"><span class="nav-number">8.</span> <span class="nav-text">为什么DSL的单例模式中，instance要有volatile？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Jasper Wu"
    src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jasper Wu</p>
  <div class="site-description" itemprop="description">醒目点、自觉点、速度点，努力奋斗下去，走好自己的路！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/androidjp" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;androidjp" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1049578026@qq.com" title="E-Mail &amp;rarr; mailto:1049578026@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jasper Wu</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  






  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'default',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>



  

  

  

  

</body>
</html>
