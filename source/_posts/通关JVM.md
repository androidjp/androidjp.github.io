---
title: 通关JVM
date: 2019-11-03 18:26:00
categories:
- Java
- JVM
tags:
- JVM
---
![](/images/jvm/1.png)
<!--more-->
# 程序计数器
作用：记录下一条jvm指令的执行地址

![](/images/jvm/2.png)

首先，程序计数器会读取第一条待执行指令的地址。

然后，程序会将从程序计数器上读取这个地址，拿到第一条指令给到解释器，让解释器解释成机器码，最终将机器码给CPU去执行，与此同时，会更新程序计数器，为下一条待执行指令的地址。

通过**寄存器**来实现程序计数器。是CPU里读取速度最快的单元，因为Java中用于读取程序指令地址的操作相当频繁，所以，物理上，JVM将寄存器作为程序计数器。

特点：
* 线程私有：Java支持多线程，那如果多个线程同时执行某个方法，那么，会怎么样呢？ 会通过CPU时间片交替给时间片各个线程，去让每个线程继续执行它的下一个指令。那么，就需要每个线程专属的程序计数器去进行计数。所以，每个线程都有自己私有的程序计数器。
* JVM中唯一不存在内存溢出的区域。

# 虚拟机栈
Java Virtual Machine Stacks

![](/images/jvm/3.png)
* 虚拟机栈：每个线程运行需要的内存空间。
* 栈帧：
  * 是每一个栈由多个栈帧（Frame）组成；
  * 对应一次方法的调用。在程序运行时，每个方法运行是需要的内存，就是一个栈帧。
* 每个线程只能有一个活动栈帧，对应着正在执行的那个方法。
* 每一个方法在被调用完毕后，其栈帧会出栈，从而释放掉其占用的内存。

![](/images/jvm/4.png)

## 相关问题
1. 垃圾回收是否涉及栈内存？
   > 不涉及。因为方法执行完毕后，会自动出栈，并被自动内存回收，所以，垃圾回收不需要管栈内存。
2. 栈内存是否越大越好？
   > 不是。
   >
   > 首先，栈内存越大，对应的可使用线程数，就越少。因为物理内存的大小是一定的。如：一共有500MB内存，如果给栈内存设置1MB，那么，就是每个线程拥有1MB的栈内存空间，所以，最多可以同时启动500个线程。
3. 方法内的局部变量是否是线程安全的？
   > 可能是。如果这个局部变量既不是入参传入的，也不是最终会返回出去的（换句话说，就是局部变量没有逃离方法的作用范围），那么，它就是线程私有的。
   >
   > 方法每次被调用，都会生成一个栈帧，那么，方法内的局部变量，都会在这个栈帧中初始化，所以，无论N个线程调用N次同一个方法，方法局部变量都会被重新创建被暂存在线程栈帧中，所以，不会有线程安全问题。

## 栈内存溢出
### 异常
```
java.lang.StackOverflowError
```

### 例子
1. 栈帧过多（方法不断递归调用，栈帧不断只增不减，入栈，挤爆了栈）
2. 栈帧过大（方法内部的局部变量、参数、返回值等过大，一个栈帧就将栈内存挤爆了）

### 如何设定栈内存
```
xXss256k
```
可以在IDEA的运行配置上，设置：
![](/images/jvm/5.png)

## 线程运行诊断
### 案例1：CPU占用很高
定位：
* 用 `top`命令 定位哪个进程对cpu的占用过高
* `ps H -eo pid,tid,%cpu | grep进程id` (用 `ps -fe | grep java`命令进一步定位是哪个线程引起的cpu占用过高)
* `jstack 进程id`：列出这个Java进程背后，所有正在JVM后台运行的线程信息。
   > 注意： 我们cmd 打印的进程中的线程编号是十进制，但是用 jstack 得到的线程编号是十六进制，所以，要定位哪个线程出了问题，要先进行进制转换。

nohup 命令： 将程序以忽略挂起信号的方式运行起来，如：`nohup java com.example.demo.App &`


### 案例2：程序运行很长时间没有结果
定位问题的步骤：
1. `ps -fe | grep java`
2. `nohup java com.example.demo.App &`
3. `jstack 进程id`
4. 看到发生死锁
5. 看代码


# 本地方法栈
不是由java 代码编写的方法。带有`native`的方法，去调用到底层的操作系统相关操作的logic。

本地方法栈：为本地方法运行提供所需的内存空间。


# 堆