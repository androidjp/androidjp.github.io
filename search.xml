<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go测试系列二：Mock实践</title>
    <url>/Go%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9AMock/</url>
    <content><![CDATA[<blockquote>
<p>上一篇文章将带大家入门Golang单元测试，接下来，就是怎么Mock。<code>Mock</code>也就是‘模拟’，也就是模拟一些上下文环境，来制造你想要的某个特定条件，来看看你的待测逻辑，是否在此特定条件下，正确运行了你认为的逻辑。</p>
</blockquote>
<a id="more"></a>

<p>以下就不说太多Golang和Java等其他语言的Mock测试环境的对比等等，我们直接上干货（附上Demo，每个分支都有对应的Mock案例）。</p>
<p>Demo Github 地址：<a href="https://github.com/androidjp/go-mock-best-practice" target="_blank" rel="noopener">https://github.com/androidjp/go-mock-best-practice</a></p>
<h1 id="gomock-mockgen"><a href="#gomock-mockgen" class="headerlink" title="gomock + mockgen"></a>gomock + mockgen</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>接口打桩。对某个可赋值的依赖成员对象进行mock（比如 <code>ServiceA</code> 依赖 <code>RepositoryA</code>，那么，在测试 <code>ServiceA.MethodA</code>方法时，可以mock了<code>RepositoryA</code>）</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><ol>
<li><p>拉取安装gomock 和 mockgen</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -v -u github.com/golang/mock/gomock</span><br></pre></td></tr></table></figure>
<p> 得到 $GOPATH/src/github.com/golang/mock 目录下，有GoMock包和mockgen工具 两个子目录。<br> 第2，3，4步看你的$GOPATH/bin目录有没有已经安装好的mockgen可执行文件，有则可忽略后续步骤。</p>
</li>
<li><p>进入mockgen子目录，执行build命令，即生成了可执行程序mockgen；</p>
</li>
<li><p>将mockgen拷贝到$GOPATH/bin目录下；</p>
</li>
<li><p>指定环境变量Path包含$GOPATH/bin目录；</p>
</li>
<li><p>最后，尝试敲一下命令行：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mockgen help</span><br></pre></td></tr></table></figure>
<p> 如果出现<code>-bash: mockgen: command not found</code>，表示你的环境变量PATH中没有配置<code>$GOPATH/bin</code>。</p>
</li>
</ol>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go doc github.com/golang/mock/gomock</span><br></pre></td></tr></table></figure>

<p><a href="https://link.jianshu.com/?t=http://godoc.org/github.com/golang/mock/gomock" target="_blank" rel="noopener">在线参考文档</a></p>
<h2 id="mockgen使用"><a href="#mockgen使用" class="headerlink" title="mockgen使用"></a>mockgen使用</h2><ol>
<li><p>在项目根目录打开命令行</p>
</li>
<li><p>找到对应目录下的某个将你要mock的接口所在的.go文件，生成对应的mock文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mockgen -source=1_gomock/db/repository.go  &gt; test/1_gomock/db/mock_repository.go</span><br></pre></td></tr></table></figure>
<p> 当然，前提是你这个 <code>test/1_gomock/db/</code>目录已经存在。</p>
</li>
<li><p>然后，使用这个mock文件中的 <code>MockXxx(t)</code> 方法</p>
</li>
</ol>
<h2 id="关键用法"><a href="#关键用法" class="headerlink" title="关键用法"></a>关键用法</h2><h3 id="1-接口打桩步骤"><a href="#1-接口打桩步骤" class="headerlink" title="1. 接口打桩步骤"></a>1. 接口打桩步骤</h3><ol>
<li><p>首先，使用mockgen工具，将对应的接口生成mock文件</p>
</li>
<li><p>然后，开始打桩</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化 mock控制器</span></span><br><span class="line">ctrl := gomock.NewController(t)</span><br><span class="line"><span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 初始化mock对象，并注入控制器</span></span><br><span class="line">mockRepo := mock_gomock_db.NewMockRepository(ctrl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设定mock对象的返回值</span></span><br><span class="line">mockRepo.EXPECT().Create(<span class="string">"name"</span>, []<span class="keyword">byte</span>(<span class="string">"jasper"</span>)).Return(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，测你要测的逻辑</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// when</span></span><br><span class="line">demoSvr := &amp;gomock_service.DemoService&#123;Repo: mockRepo&#125;</span><br><span class="line">data, err := demoSvr.InsertData(<span class="string">"name"</span>, <span class="string">"jasper"</span>)</span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">assert.Equal(t, <span class="string">"success"</span>, data)</span><br><span class="line">assert.Nil(t, err)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-接口打桩定义前N次返回值"><a href="#2-接口打桩定义前N次返回值" class="headerlink" title="2. 接口打桩定义前N次返回值"></a>2. 接口打桩定义前N次返回值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前两次返回错误</span></span><br><span class="line">mockRepo.EXPECT().Create(<span class="string">"name"</span>, []<span class="keyword">byte</span>(<span class="string">"jasper"</span>)).Return(errors.New(<span class="string">"db connection error"</span>)).Times(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 第三次正常</span></span><br><span class="line">mockRepo.EXPECT().Create(<span class="string">"name"</span>, []<span class="keyword">byte</span>(<span class="string">"jasper"</span>)).Return(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-断言接口调用顺序"><a href="#3-断言接口调用顺序" class="headerlink" title="3. 断言接口调用顺序"></a>3. 断言接口调用顺序</h3><p>方式一：<code>After</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retrieve 先执行</span></span><br><span class="line">retrieveName := mockRepo.EXPECT().Retrieve(<span class="string">"name"</span>).Return([]<span class="keyword">byte</span>(<span class="string">"jasper"</span>), <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// update 在 retrieve 之后</span></span><br><span class="line">mockRepo.EXPECT().Update(<span class="string">"name"</span>, []<span class="keyword">byte</span>(<span class="string">"mike"</span>)).Return(<span class="literal">nil</span>).After(retrieveName)</span><br></pre></td></tr></table></figure>

<p>方式二：<code>InOrder</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gomock.InOrder(</span><br><span class="line">    <span class="comment">// retrieve 先执行</span></span><br><span class="line">    mockRepo.EXPECT().Retrieve(<span class="string">"name"</span>).Return([]<span class="keyword">byte</span>(<span class="string">"jasper"</span>), <span class="literal">nil</span>),</span><br><span class="line">    <span class="comment">// update 在 retrieve 之后</span></span><br><span class="line">    mockRepo.EXPECT().Update(<span class="string">"name"</span>, []<span class="keyword">byte</span>(<span class="string">"mike"</span>)).Return(<span class="literal">nil</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Demo示例"><a href="#Demo示例" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/1_gomock_1_basic" target="_blank" rel="noopener">https://github.com/androidjp/go-mock-best-practice/tree/1_gomock_1_basic</a></p>
<h1 id="gostub打桩"><a href="#gostub打桩" class="headerlink" title="gostub打桩"></a>gostub打桩</h1><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><ul>
<li><p>全局变量打桩</p>
</li>
<li><p>函数打桩</p>
</li>
<li><p>过程打桩</p>
</li>
<li><p>第三方库打桩</p>
</li>
</ul>
<h2 id="安装与配置-1"><a href="#安装与配置-1" class="headerlink" title="安装与配置"></a>安装与配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -v -u github.com/prashantv/gostub</span><br></pre></td></tr></table></figure>

<h2 id="关键用法-1"><a href="#关键用法-1" class="headerlink" title="关键用法"></a>关键用法</h2><h3 id="1-全局变量打桩"><a href="#1-全局变量打桩" class="headerlink" title="1. 全局变量打桩"></a>1. 全局变量打桩</h3><p>对于全局变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  GlobalCount <span class="keyword">int</span></span><br><span class="line">  Host        <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以这样打桩：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量 GlobalCount int 打桩</span></span><br><span class="line"><span class="comment">// 全局变量 Host string 打桩</span></span><br><span class="line">stubs := gostub.Stub(&amp;GlobalCount, <span class="number">10</span>).</span><br><span class="line">  Stub(&amp;Host, <span class="string">"https://www.bing.cn"</span>)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>

<h3 id="2-函数打桩"><a href="#2-函数打桩" class="headerlink" title="2. 函数打桩"></a>2. 函数打桩</h3><p>假设有个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exec</span><span class="params">(cmd <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，首先我要先变成这样的写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Exec = <span class="function"><span class="keyword">func</span><span class="params">(cmd <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上写法不影响业务逻辑使用。</p>
<p>然后再进行打桩：</p>
<p>方式一：<code>StubFunc</code> 直接设置返回结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stubs := gostub.StubFunc(&amp;gomock_service.Exec, <span class="string">"xxx-vethName100-yyy"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>

<p>方式二：<code>Stub</code> 还能设置具体逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stubs := gostub.Stub(&amp;Exec, <span class="function"><span class="keyword">func</span><span class="params">(cmd <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"xxx-vethName100-yyy"</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>

<h3 id="3-过程打桩"><a href="#3-过程打桩" class="headerlink" title="3. 过程打桩"></a>3. 过程打桩</h3><p>对于一些没有返回值的函数，我们称为“过程”：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> DestroyResource = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"清理资源等工作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打桩开始：</p>
<p>方式一：<code>StubFunc</code> 直接设置返回结果（当你想这个过程啥都不做时，可以这样）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stubs := gostub.StubFunc(&amp;gomock_service.DestroyResource)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>

<p>方式二：<code>Stub</code> 还能设置具体逻辑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stubs := gostub.Stub(&amp;gomock_service.DestroyResource, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// do sth</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>

<h3 id="4-第三方库打桩"><a href="#4-第三方库打桩" class="headerlink" title="4. 第三方库打桩"></a>4. 第三方库打桩</h3><p>很多第三方库的函数（注意，是函数，不是某个对象的某个成员方法），我们会经常使用，而在单元测试时不是我们的关注点，或者想他报错等，就可以选择打桩。</p>
<ol>
<li><p>假如，我想打桩json的序列化和反序列化函数，那么，先在<code>adapter</code>包下定义<code>json.go</code>文件，然后声明对象：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Marshal = json.Marshal</span><br><span class="line"><span class="keyword">var</span> UnMarshal = json.Unmarshal</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元测试中，就可以直接使用<code>gostub.StubFunc</code>来进行打桩了：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// given</span></span><br><span class="line"><span class="keyword">var</span> mikeStr = <span class="string">`&#123;"name":"Jasper", "age":18&#125;`</span></span><br><span class="line">stubs := gostub.StubFunc(&amp;adapter.Marshal, []<span class="keyword">byte</span>(mikeStr), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br><span class="line"></span><br><span class="line">stu := &amp;entity.Student&#123;Name: <span class="string">"Mike"</span>, Age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when</span></span><br><span class="line">res, err := stu.Print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">assert.Equal(t, <span class="string">"&#123;\"name\":\"Jasper\", \"age\":18&#125;"</span>, res)</span><br><span class="line">assert.Nil(t, err)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Demo示例-1"><a href="#Demo示例-1" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/1_gomock_2_gostub" target="_blank" rel="noopener">https://github.com/androidjp/go-mock-best-practice/tree/1_gomock_2_gostub</a></p>
<h1 id="goconvey更优化的断言"><a href="#goconvey更优化的断言" class="headerlink" title="goconvey更优化的断言"></a>goconvey更优化的断言</h1><h2 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h2><ul>
<li><p>更优雅地写测试用例</p>
</li>
<li><p>更好地可视化界面，实时更新当前所有测试情况和覆盖率</p>
</li>
</ul>
<h2 id="安装与配置-2"><a href="#安装与配置-2" class="headerlink" title="安装与配置"></a>安装与配置</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -v -u github.com/smartystreets/goconvey</span><br></pre></td></tr></table></figure>

<h2 id="如何跑测试"><a href="#如何跑测试" class="headerlink" title="如何跑测试"></a>如何跑测试</h2><p>cd到测试文件所在目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go test -v</span><br></pre></td></tr></table></figure>

<p>或者，cd到项目根目录，全跑整个项目的测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test ./... -v -cover</span><br></pre></td></tr></table></figure>

<p>或者执行以下命令，弹出web页面（默认：<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goconvey</span><br></pre></td></tr></table></figure>

<p>其中，<code>goconvey -help</code> 能出来相关的命令行选项说明，一般常用是这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">goconvey -port 8112 -excludedDirs &quot;vendor,mock,proto,conf&quot;</span><br></pre></td></tr></table></figure>

<p>表示：web页面在 <a href="http://127.0.0.1:8112" target="_blank" rel="noopener">http://127.0.0.1:8112</a>，并且忽略当前上下文目录下的vendor目录、mock目录、proto目录。</p>
<p>图示：</p>
<p><img src="/images/20210323/2.png" alt=""></p>
<h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestXxxService_XxxMethod</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  Convey(<span class="string">"should return 情况A"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Convey(<span class="string">"when 某逻辑 return `xxxx`"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// given</span></span><br><span class="line">            ..........各种准备逻辑（mock、stub、声明、初始化、造数据等）</span><br><span class="line">            <span class="comment">// when</span></span><br><span class="line">            res, err := xxxService.XxxMethod(....)</span><br><span class="line">            <span class="comment">// then</span></span><br><span class="line">            So(res, ShouldEqual, <span class="string">"情况A"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        Convey(<span class="string">"when 传入了参数 keyA=`valA`, keyB=`valB`"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Convey(<span class="string">"should return 情况B"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Convey(<span class="string">"when .................."</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">........</span><br><span class="line">Convey(&quot;should return `解析响应体失败：response is empty`&quot;, t, func() &#123;</span><br><span class="line">    Convey(&quot;when proxy response with statusCode 200 and empty body is returned&quot;, func() &#123;</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<h2 id="IDE-快速生成单元测试代码"><a href="#IDE-快速生成单元测试代码" class="headerlink" title="IDE 快速生成单元测试代码"></a>IDE 快速生成单元测试代码</h2><p><img src="/images/20210323/3.png" alt=""></p>
<p>以下的本人实践使用的模板：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Convey(<span class="string">"should $FIRST$"</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Convey(<span class="string">"when $SECOND$"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//---------------------------------------</span></span><br><span class="line">        <span class="comment">// given</span></span><br><span class="line">        <span class="comment">//---------------------------------------</span></span><br><span class="line">        $END$</span><br><span class="line">        <span class="comment">//---------------------------------------</span></span><br><span class="line">        <span class="comment">// when</span></span><br><span class="line">        <span class="comment">//---------------------------------------</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//---------------------------------------</span></span><br><span class="line">        <span class="comment">// then</span></span><br><span class="line">        <span class="comment">//---------------------------------------</span></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>设置完毕后，写测试时，直接键入 <code>swg</code>然后点击 <code>tab</code>键，即可生成这段模板代码。</p>
<blockquote>
<p>注意：测试代码当然需要引入convey库：<code>import . &quot;github.com/smartystreets/goconvey/convey&quot;</code></p>
</blockquote>
<h2 id="Demo示例-2"><a href="#Demo示例-2" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/1_gomock_3_gostub_gocovey" target="_blank" rel="noopener">androidjp/go-mock-best-practice</a></p>
<h1 id="GoMonkey"><a href="#GoMonkey" class="headerlink" title="GoMonkey"></a>GoMonkey</h1><h2 id="需求-3"><a href="#需求-3" class="headerlink" title="需求"></a>需求</h2><ul>
<li><p>为一个函数打桩</p>
</li>
<li><p>为一个过程打桩</p>
</li>
<li><p>为一个方法打桩</p>
</li>
<li><p>特殊场景：桩中桩的一个案例</p>
</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><p>基本场景：为一个函数打桩</p>
</li>
<li><p>基本场景：为一个过程打桩</p>
</li>
<li><p>基本场景：为一个方法打桩</p>
</li>
<li><p>特殊场景：桩中桩的一个案例</p>
</li>
</ul>
<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul>
<li><p>Monkey不是线程安全的，不要将Monkey用于并发的测试</p>
</li>
<li><p>对inline函数打桩无效（一般需要：通过命令行参数<code>-gcflags=-l</code>禁止inline）</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像这种函数，很简单短小，在源码层面来看时有函数结构的，但是编译后却不具备函数的性质。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsEqual</span><span class="params">(a, b <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a == b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Monkey只能为首字母大写的方法/函数打桩（当然，这样其实更符合编码规范）。</p>
</li>
<li><p>API不够简洁优雅，同时不支持多次调用桩函数（方法）而呈现不同行为的复杂情况。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -v bou.ke/monkey</span><br></pre></td></tr></table></figure>

<h2 id="运行单元测试"><a href="#运行单元测试" class="headerlink" title="运行单元测试"></a>运行单元测试</h2><p>方式一：命令行运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -gcflags=-l -v</span><br></pre></td></tr></table></figure>

<p>方式二：IDE 运行：在 Go tool Arguments 栏加上这一个选项：<code>-gcflags=-l</code></p>
<p>注意：在运行测试时，可能出现运行报错的问题，</p>
<p>原因：由于它是在运行时替换了函数的指针，所以如果遇到一些简单的函数，例如 rand.Int63n 和 time.Now，编译器可能会直接将这种函数内联到调用实际发生的代码处并不会调用原有的方法，所以使用这种方式往往需要我们在测试时额外指定 -gcflags=-l 禁止编译器的内联优化。</p>
<p>这时，几种运行方式：</p>
<ol>
<li>命令行运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">test</span> -gcflags=-l -v</span><br></pre></td></tr></table></figure></li>
<li>IDE运行，加上<code>-gcflags=-l</code><br> <img src="/images/20210323/4.png" alt=""></li>
</ol>
<h2 id="关键用法-2"><a href="#关键用法-2" class="headerlink" title="关键用法"></a>关键用法</h2><h3 id="1-函数打桩"><a href="#1-函数打桩" class="headerlink" title="1. 函数打桩"></a>1. 函数打桩</h3><ol>
<li><p>假设目前有这样一个函数 <code>Exec</code>：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exec</span><span class="params">(cmd <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们直接可以使用<code>monkey.Patch</code>将其打桩，不需要声明什么变量：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打桩</span></span><br><span class="line">guard := Patch(service.Exec, <span class="function"><span class="keyword">func</span><span class="params">(cmd <span class="keyword">string</span>, args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"sss"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> guard.Unpatch()</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">output, err := service.Exec(<span class="string">"cmd01"</span>, <span class="string">"--conf"</span>, <span class="string">"conf/app_test.yaml"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-过程打桩"><a href="#2-过程打桩" class="headerlink" title="2. 过程打桩"></a>2. 过程打桩</h3><p>和函数一样，相较于<code>gostub</code>好的一点，就是不需要声明变量去指向这个函数，从而减少业务代码的修改。</p>
<ol>
<li>假设有这样一个过程： <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InternalDoSth</span><span class="params">(mData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    mData[<span class="string">"keyA"</span>] = <span class="string">"valA"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一样方式进行打桩 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">patchGuard := Patch(service.InternalDoSth, <span class="function"><span class="keyword">func</span><span class="params">(mData <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    mData[<span class="string">"keyA"</span>] = <span class="string">"valB"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> patchGuard.Unpatch()</span><br><span class="line"></span><br><span class="line">..............</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-方法打桩"><a href="#3-方法打桩" class="headerlink" title="3. 方法打桩"></a>3. 方法打桩</h3><p>注意：只能打Public方法的桩，也就是首字母大写的方法</p>
<ol>
<li><p>假设有这样一个类以及它的方法定义：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Etcd <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Etcd)</span> <span class="title">Get</span><span class="params">(id <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    names := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">switch</span> id &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        names = <span class="built_in">append</span>(names, <span class="string">"A"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        names = <span class="built_in">append</span>(names, <span class="string">"B"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> names</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Etcd)</span> <span class="title">Save</span><span class="params">(vals []<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"存储DB成功"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Etcd)</span> <span class="title">GetAndSave</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    vals := e.Get(id)</span><br><span class="line">    <span class="keyword">if</span> vals[<span class="number">0</span>] == <span class="string">"A"</span> &#123;</span><br><span class="line">        vals[<span class="number">0</span>] = <span class="string">"C"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.Save(vals)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>PatchInstanceMethod</code>即可打桩，然后直接调用:</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打桩</span></span><br><span class="line"><span class="keyword">var</span> e = &amp;service.Etcd&#123;&#125;</span><br><span class="line">guard := PatchInstanceMethod(reflect.TypeOf(e), <span class="string">"Get"</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *service.Etcd, id <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">string</span>&#123;<span class="string">"Jasper"</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> guard.Unpatch()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">res := e.Get(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我想要一个测试用例里打多个成员方法的桩，这样即可：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e = &amp;service.Etcd&#123;&#125;</span><br><span class="line"><span class="comment">// stub Get</span></span><br><span class="line">theVals := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">theVals = <span class="built_in">append</span>(theVals, <span class="string">"A"</span>)</span><br><span class="line">PatchInstanceMethod(reflect.TypeOf(e), <span class="string">"Get"</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *service.Etcd, id <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> theVals</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// stub Save</span></span><br><span class="line">PatchInstanceMethod(reflect.TypeOf(e), <span class="string">"Save"</span>, <span class="function"><span class="keyword">func</span><span class="params">(e *service.Etcd, vals []<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"occurs error"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一键删除所有补丁</span></span><br><span class="line"><span class="keyword">defer</span> UnpatchAll()</span><br><span class="line"></span><br><span class="line">.............</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="4-配合gomock（桩中桩）"><a href="#4-配合gomock（桩中桩）" class="headerlink" title="4. 配合gomock（桩中桩）"></a>4. 配合gomock（桩中桩）</h3><p>当我需要mock一个接口，并且，重新定义这个mock对象的某个方法时，使用。</p>
<p>详情看demo例子<code>repo_test.go</code></p>
<h2 id="Demo示例-3"><a href="#Demo示例-3" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/3_monkey" target="_blank" rel="noopener">androidjp/go-mock-best-practice</a></p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>由于使用GoMonkey Patch后导致GoConvey命令不能正常运行测试用例</p>
<p>解决方案：<br><a href="https://blog.csdn.net/scun_cg/article/details/88395041" target="_blank" rel="noopener">https://blog.csdn.net/scun_cg/article/details/88395041</a></p>
<h1 id="原生http服务接口测试"><a href="#原生http服务接口测试" class="headerlink" title="原生http服务接口测试"></a>原生http服务接口测试</h1><h2 id="需求-4"><a href="#需求-4" class="headerlink" title="需求"></a>需求</h2><ul>
<li>原生<code>net/http</code>写的web服务，http接口需要单元测试。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们不用任何web框架（Gin、Beego、Echo等），使用原生的golang <code>net/http</code> 库编写一个RESTful接口服务，这样写：</p>
<ol>
<li><p>定义controller</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  instanceDemoController *DemoController</span><br><span class="line">  initDemoControllerOnce sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DemoController <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDemoController</span><span class="params">()</span> *<span class="title">DemoController</span></span> &#123;</span><br><span class="line">  initDemoControllerOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    instanceDemoController = &amp;DemoController&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instanceDemoController</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DemoController)</span> <span class="title">GetMessage</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()       <span class="comment">// 解析参数，默认是不会解析的</span></span><br><span class="line">  fmt.Println(r.Form) <span class="comment">// 这些信息是输出到服务器端的打印信息</span></span><br><span class="line">  fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">  fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">  fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">    fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">    fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Fprintf(w, <span class="string">"Hello Mike!"</span>) <span class="comment">// 这个写入到 w 的是输出到客户端的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>main方式直接使用http包的<code>HandleFunc</code>和<code>ListenAndServe</code>方法即可完成监听并启动服务：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 设置访问的路由</span></span><br><span class="line">  http.HandleFunc(<span class="string">"/message"</span>, controller.GetDemoController().GetMessage)</span><br><span class="line">  <span class="comment">// 设置监听的端口</span></span><br><span class="line">  fmt.Println(<span class="string">"Start listening 9090, 尝试请求：http://localhost:9090/message?keyA=valA&amp;url_long=123456"</span>)</span><br><span class="line">  <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"ListenAdnServe: "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 那，如果我要单元测试测这个接口怎么办？原生的<code>net/http/httptest</code> 就能帮到你：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// given</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">demoCtrl := &amp;controller.DemoController&#123;&#125;</span><br><span class="line">ts := httptest.NewServer(http.HandlerFunc(demoCtrl.GetMessage))</span><br><span class="line"><span class="keyword">defer</span> ts.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// when</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">resp, err := http.Get(ts.URL)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">bodyBytes, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// then</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"Hello Mike!"</span>, <span class="keyword">string</span>(bodyBytes))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Demo示例-4"><a href="#Demo示例-4" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/2_web_2_raw_http_httptest" target="_blank" rel="noopener">androidjp/go-mock-best-practice</a></p>
<h1 id="Gin接口测试"><a href="#Gin接口测试" class="headerlink" title="Gin接口测试"></a>Gin接口测试</h1><p>gin官方文档：<a href="https://github.com/gin-gonic/gin#quick-start" target="_blank" rel="noopener">https://github.com/gin-gonic/gin#quick-start</a></p>
<h2 id="需求-5"><a href="#需求-5" class="headerlink" title="需求"></a>需求</h2><ul>
<li>测试基于Gin框架写的API接口。</li>
</ul>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>我们可以使用原生的httptest来测试接口，当然也可以使用其他的库，如：<a href="https://apitest.dev/" target="_blank" rel="noopener">apitest</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gin</span></span><br><span class="line"><span class="keyword">go</span> get -v -u github.com/gin-gonic/gin</span><br><span class="line"><span class="comment">// testify 断言库</span></span><br><span class="line"><span class="keyword">go</span> get -v -u github.com/stretchr/testify</span><br></pre></td></tr></table></figure>

<h2 id="原生测试写法"><a href="#原生测试写法" class="headerlink" title="原生测试写法"></a>原生测试写法</h2><ol>
<li><p>首先，我们DemoController代码逻辑基本没变，只是需要采用<code>*gin.Context</code> ，启动函数只是变得更简洁而已：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 设置访问的路由</span></span><br><span class="line">  r := gin.Default()</span><br><span class="line">  r.GET(<span class="string">"/message"</span>, controller.GetDemoController().GetMessage)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置监听的端口</span></span><br><span class="line">  fmt.Println(<span class="string">"Start listening 9090, 尝试请求：http://localhost:9090/message?keyA=valA&amp;url_long=123456"</span>)</span><br><span class="line">  <span class="keyword">if</span> err := r.Run(<span class="string">":9090"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"ListenAdnServe: "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么，测试用例写法，也只是前期准备gin测试环境的逻辑有所不同罢了：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// given</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">gin.SetMode(gin.TestMode)</span><br><span class="line">router := gin.New()</span><br><span class="line">demoCtrl := &amp;controller.DemoController&#123;&#125;</span><br><span class="line"><span class="comment">//待测试的接口</span></span><br><span class="line">router.GET(<span class="string">"/message"</span>, demoCtrl.GetMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// when</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// 构建返回值</span></span><br><span class="line">w := httptest.NewRecorder()</span><br><span class="line"><span class="comment">// 构建请求</span></span><br><span class="line">req, _ := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"/message?keyA=valA&amp;url_long=123456"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//调用请求接口</span></span><br><span class="line">router.ServeHTTP(w, req)</span><br><span class="line"></span><br><span class="line">resp := w.Result()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// then</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">assert.Nil(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"Hello Mike!"</span>, <span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Demo示例-5"><a href="#Demo示例-5" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/2_web_3_gin_httptest" target="_blank" rel="noopener">androidjp/go-mock-best-practice</a></p>
<h1 id="apitest"><a href="#apitest" class="headerlink" title="apitest"></a>apitest</h1><h2 id="需求-6"><a href="#需求-6" class="headerlink" title="需求"></a>需求</h2><ul>
<li>对golang原生http或者Gin等框架下的RESTFul API接口进行更简洁的测试</li>
</ul>
<h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><p>官网：<a href="https://apitest.dev/" target="_blank" rel="noopener">https://apitest.dev/</a></p>
<p>github地址：<a href="https://github.com/steinfletcher/apitest" target="_blank" rel="noopener">https://github.com/steinfletcher/apitest</a></p>
<p><code>go get -u github.com/steinfletcher/apitest</code></p>
<h2 id="用apitest测试Gin接口"><a href="#用apitest测试Gin接口" class="headerlink" title="用apitest测试Gin接口"></a>用apitest测试Gin接口</h2><p>各种apitest详细用法可以参考官方文档，这里只说说也前面使用原生httptest的最大区别：更简洁了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// given</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">gin.SetMode(gin.TestMode)</span><br><span class="line">router := gin.New()</span><br><span class="line">demoCtrl := &amp;controller.DemoController&#123;&#125;</span><br><span class="line"><span class="comment">//待测试的接口</span></span><br><span class="line">router.GET(<span class="string">"/message"</span>, demoCtrl.GetMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="comment">// when then</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">apitest.New().</span><br><span class="line">  Handler(router).</span><br><span class="line">  Getf(<span class="string">"/message?keyA=%s&amp;url_long=1%s"</span>, <span class="string">"valA"</span>, <span class="string">"123456"</span>).</span><br><span class="line">  Header(<span class="string">"Client-Type"</span>, <span class="string">"pc"</span>).</span><br><span class="line">  Cookie(<span class="string">"sid"</span>, <span class="string">"id001"</span>).</span><br><span class="line">  JSON(<span class="literal">nil</span>).</span><br><span class="line">  Expect(t).</span><br><span class="line">  Status(http.StatusOK).</span><br><span class="line">  Assert(jsonPath.Equal(<span class="string">`$.code`</span>, <span class="keyword">float64</span>(<span class="number">2000</span>))).</span><br><span class="line">  Assert(jsonPath.Equal(<span class="string">`$.msg`</span>, <span class="string">"Hello Mike!"</span>)).</span><br><span class="line">  Body(<span class="string">`&#123;"code":2000,"msg":"Hello Mike!"&#125;`</span>).</span><br><span class="line">  End()</span><br></pre></td></tr></table></figure>

<h2 id="Demo示例-6"><a href="#Demo示例-6" class="headerlink" title="Demo示例"></a>Demo示例</h2><p><a href="https://github.com/androidjp/go-mock-best-practice/tree/2_web_4_gin_apitest" target="_blank" rel="noopener">androidjp/go-mock-best-practice</a></p>
<h1 id="Beego-接口测试"><a href="#Beego-接口测试" class="headerlink" title="Beego 接口测试"></a>Beego 接口测试</h1><p>参考文章：<a href="https://blog.csdn.net/qq_38959696/article/details/106567212" target="_blank" rel="noopener">https://blog.csdn.net/qq_38959696/article/details/106567212</a></p>
<h1 id="SqlMock使用"><a href="#SqlMock使用" class="headerlink" title="SqlMock使用"></a>SqlMock使用</h1><p>github：<a href="https://github.com/DATA-DOG/go-sqlmock" target="_blank" rel="noopener">https://github.com/DATA-DOG/go-sqlmock</a></p>
<h2 id="需求-7"><a href="#需求-7" class="headerlink" title="需求"></a>需求</h2><ul>
<li>测试自己写的sql脚本等与DB存取息息相关的细节逻辑有没有问题</li>
</ul>
<h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -v -u github.com/DATA-DOG/<span class="keyword">go</span>-sqlmock</span><br></pre></td></tr></table></figure>

<h2 id="关键用法-3"><a href="#关键用法-3" class="headerlink" title="关键用法"></a>关键用法</h2><h3 id="情况一：直接将db对象作为入参"><a href="#情况一：直接将db对象作为入参" class="headerlink" title="情况一：直接将db对象作为入参"></a>情况一：直接将db对象作为入参</h3><p>假设有这样的一个函数，直接传入的是<code>*sql.DB</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *DemoService)</span> <span class="title">AddStudentDirectly</span><span class="params">(db *sql.DB, name <span class="keyword">string</span>)</span> <span class="params">(stu *entities.Student, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 启动事务</span></span><br><span class="line">  tx, err := db.Begin()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">      err = tx.Commit()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      tx.Rollback()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 先新增一个学生信息</span></span><br><span class="line">  result, err := db.Exec(<span class="string">"insert into students(name) values(?)"</span>, name)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  id, err := result.LastInsertId()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 然后，给教室1 添加这个学生</span></span><br><span class="line">  <span class="keyword">if</span> _, err = db.Exec(<span class="string">"insert into classroom_1(stu_id) values(?)"</span>, id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  stu = &amp;entities.Student&#123;ID: id, Name: name&#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上函数做的事情：开事务、插入students表、将得到的id，插入另一长classroom_1表，最终提交事务。</p>
<p>这种情况，只需要想办法mock掉这个<code>db *sql.DB</code>对象即可：</p>
<ol>
<li><p>sqlmock.New()得到mock掉了的db对象，以及mock记录器对象；</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, mock, err := sqlmock.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatalf(<span class="string">"an error '%s' was not expected when opening a stub database connection"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置即将要发生什么DB操作，并且设置将返回什么值：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) 首先是会 开启事务</span></span><br><span class="line">mock.ExpectBegin()</span><br><span class="line"><span class="comment">// 2) 然后是插入students表，最终返回id=1, 影响行数=1</span></span><br><span class="line">mock.ExpectExec(regexp.QuoteMeta(<span class="string">`insert into students(name) values(?)`</span>)).WithArgs(<span class="string">"mike"</span>).WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 3) 插入classroom_1表</span></span><br><span class="line">mock.ExpectExec(regexp.QuoteMeta(<span class="string">"insert into classroom_1(stu_id) values(?)"</span>)).WithArgs(<span class="number">1</span>).WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 4) 提交事务</span></span><br><span class="line">mock.ExpectCommit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>将mock了的db对象，作为入参：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...........</span><br><span class="line">stu, err := svr.AddStudentDirectly(db, <span class="string">"mike"</span>)</span><br><span class="line">...........</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="情况二：有自己的repository层对象，去封装db的相关操作"><a href="#情况二：有自己的repository层对象，去封装db的相关操作" class="headerlink" title="情况二：有自己的repository层对象，去封装db的相关操作"></a>情况二：有自己的repository层对象，去封装db的相关操作</h3><p>一般我们写项目代码，职责单一，分层明确，很多时候，会是另一种写法：repository层的某个XxxRepository类拥有DB连接对象，然后，有一系列对应的DB相关操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MySQLRepository <span class="keyword">struct</span> &#123;</span><br><span class="line">  db *sql.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMySQLRepository</span><span class="params">()</span> *<span class="title">MySQLRepository</span></span> &#123;</span><br><span class="line">  db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:root@tcp(192.168.200.128:3307)/test?charset=utf8mb4"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  db.SetConnMaxLifetime(time.Minute * <span class="number">2</span>)</span><br><span class="line">  db.SetMaxOpenConns(<span class="number">10</span>)</span><br><span class="line">  db.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;MySQLRepository&#123;</span><br><span class="line">    db: db,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MySQLRepository)</span> <span class="title">CreateStudent</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(stu *entities.Student, err error)</span></span> &#123;</span><br><span class="line">    ..........................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，如果想要更好地达到mock的目的，那么，需要配置gostub框架：</p>
<ol>
<li><p>首先，源码需要稍微做一些调整，加上adapter适配一下<code>sql.Open</code>为<code>adapter.Open</code>：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Open = sql.Open</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，同样是通过sqlmock定义mock的db对象：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db, mock, err := sqlmock.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatalf(<span class="string">"an error '%s' was not expected when opening a stub database connection"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">mock.ExpectBegin()</span><br><span class="line">mock.ExpectExec(regexp.QuoteMeta(<span class="string">`insert into students(name) values(?)`</span>)).WithArgs(<span class="string">"mike"</span>).WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">mock.ExpectExec(regexp.QuoteMeta(<span class="string">"insert into classroom_1(stu_id) values(?)"</span>)).WithArgs(<span class="number">1</span>).WillReturnResult(sqlmock.NewResult(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">mock.ExpectCommit()</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，gostub让adapter.Open打桩，让其返回我们mock的db对象：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">stubs := gostub.StubFunc(&amp;adapter.Open, db, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">defer</span> stubs.Reset()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终实际跑逻辑进行测试：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sqlRepository := repository.NewMySQLRepository()</span><br><span class="line">student, err := sqlRepository.CreateStudent(<span class="string">"mike"</span>)</span><br></pre></td></tr></table></figure>
<p> 当然，对于不同的ORM框架，有一些不同的封装逻辑，获取到的db操作对象也可能不是<code>*sql.DB</code> 类型，这里详细可以看Demo示例，这里目前只实践了MySQL gorm和xorm两个ORM框架的mock实践。</p>
</li>
</ol>
<h2 id="Demo示例-7"><a href="#Demo示例-7" class="headerlink" title="Demo示例"></a>Demo示例</h2><ul>
<li><p>MySQL 原生 sql-driver 的mock：<a href="https://github.com/androidjp/go-mock-best-practice/tree/4_db_1_sqlmock_sqldriver" target="_blank" rel="noopener">https://github.com/androidjp/go-mock-best-practice/tree/4_db_1_sqlmock_sqldriver</a></p>
</li>
<li><p>MySQL gorm ORM框架mock：<a href="https://github.com/androidjp/go-mock-best-practice/tree/4_db_2_sqlmock_gorm" target="_blank" rel="noopener">https://github.com/androidjp/go-mock-best-practice/tree/4_db_2_sqlmock_gorm</a></p>
</li>
<li><p>MySQL xorm ORM框架mock：<a href="https://github.com/androidjp/go-mock-best-practice/tree/4_db_3_sqlmock_xorm" target="_blank" rel="noopener">https://github.com/androidjp/go-mock-best-practice/tree/4_db_3_sqlmock_xorm</a></p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="一、Gin的-gin-Context-怎么mock？"><a href="#一、Gin的-gin-Context-怎么mock？" class="headerlink" title="一、Gin的*gin.Context 怎么mock？"></a>一、Gin的<code>*gin.Context</code> 怎么mock？</h2><ol>
<li><p>首先，在测试文件中定义一个MockResponseWriter结构体：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MockResponseWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockResponseWriter)</span> <span class="title">Header</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Header</span></span> &#123;</span><br><span class="line">  h := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">  h[<span class="string">"Client-Type"</span>] = []<span class="keyword">string</span>&#123;<span class="string">"wps-pc"</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockResponseWriter)</span> <span class="title">Write</span><span class="params">([]<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockResponseWriter)</span> <span class="title">WriteHeader</span><span class="params">(statusCode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用gin.CreateTestContext，来构造整个gin.Context：</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mockGinContext, _ := gin.CreateTestContext(&amp;MockResponseWriter&#123;&#125;)</span><br><span class="line">mockGinContext.Request = &amp;http.Request&#123;&#125;</span><br><span class="line"><span class="comment">// mock request header</span></span><br><span class="line">mockGinContext.Request.Header = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">mockGinContext.Request.Header[<span class="string">"Client-Type"</span>] = []<span class="keyword">string</span>&#123;<span class="string">"wps-pc"</span>&#125;</span><br><span class="line">mockGinContext.Request.Header[<span class="string">"Client-Chan"</span>] = []<span class="keyword">string</span>&#123;<span class="string">"00050.88888888"</span>&#125;</span><br><span class="line">mockGinContext.Request.Header[<span class="string">"Client-Ver"</span>] = []<span class="keyword">string</span>&#123;<span class="string">"1.0.1"</span>&#125;</span><br><span class="line">mockGinContext.Request.Header[<span class="string">"X-Forwarded-Host"</span>] = []<span class="keyword">string</span>&#123;<span class="string">"test.com"</span>&#125;</span><br><span class="line">mockGinContext.Request.URL = &amp;url.URL&#123;Path: <span class="string">"/api/v2/proofread"</span>&#125;</span><br><span class="line">mockGinContext.Set(<span class="string">"uid"</span>, <span class="string">"123123123"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock request body</span></span><br><span class="line">mockGinContext.Request.Body = ioutil.NopCloser(bytes.NewReader([]<span class="keyword">byte</span>(<span class="string">"&#123;\"key\":\"val\",\"userid\":123123&#125;"</span>)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>ok，这个<code>mockGinContext</code>可以被我们拿来作为参数使用了。</p>
</li>
</ol>
<h2 id="二、POST-data-using-the-Content-Type-multipart-form-data"><a href="#二、POST-data-using-the-Content-Type-multipart-form-data" class="headerlink" title="二、POST data using the Content-Type multipart/form-data"></a>二、<a href="https://stackoverflow.com/questions/20205796/post-data-using-the-content-type-multipart-form-data" target="_blank" rel="noopener">POST data using the Content-Type multipart/form-data</a></h2><p>In short, you’ll need to use the mime/multipart package to build the form.</p>
<p>sample代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"mime/multipart"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/http/httptest"</span></span><br><span class="line">    <span class="string">"net/http/httputil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> client *http.Client</span><br><span class="line">    <span class="keyword">var</span> remoteURL <span class="keyword">string</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//setup a mocked http client.</span></span><br><span class="line">        ts := httptest.NewTLSServer(http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">            b, err := httputil.DumpRequest(r, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(<span class="string">"%s"</span>, b)</span><br><span class="line">        &#125;))</span><br><span class="line">        <span class="keyword">defer</span> ts.Close()</span><br><span class="line">        client = ts.Client()</span><br><span class="line">        remoteURL = ts.URL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prepare the reader instances to encode</span></span><br><span class="line">    values := <span class="keyword">map</span>[<span class="keyword">string</span>]io.Reader&#123;</span><br><span class="line">        <span class="string">"file"</span>:  mustOpen(<span class="string">"main.go"</span>), <span class="comment">// lets assume its this file</span></span><br><span class="line">        <span class="string">"other"</span>: strings.NewReader(<span class="string">"hello world!"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    err := Upload(client, remoteURL, values)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Upload</span><span class="params">(client *http.Client, url <span class="keyword">string</span>, values <span class="keyword">map</span>[<span class="keyword">string</span>]io.Reader)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Prepare a form that you will submit to that URL.</span></span><br><span class="line">    <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">    w := multipart.NewWriter(&amp;b)</span><br><span class="line">    <span class="keyword">for</span> key, r := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">var</span> fw io.Writer</span><br><span class="line">        <span class="keyword">if</span> x, ok := r.(io.Closer); ok &#123;</span><br><span class="line">            <span class="keyword">defer</span> x.Close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Add an image file</span></span><br><span class="line">        <span class="keyword">if</span> x, ok := r.(*os.File); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> fw, err = w.CreateFormFile(key, x.Name()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Add other fields</span></span><br><span class="line">            <span class="keyword">if</span> fw, err = w.CreateFormField(key); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _, err = io.Copy(fw, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't forget to close the multipart writer.</span></span><br><span class="line">    <span class="comment">// If you don't close it, your request will be missing the terminating boundary.</span></span><br><span class="line">    w.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that you have a form, you can submit it to your handler.</span></span><br><span class="line">    req, err := http.NewRequest(<span class="string">"POST"</span>, url, &amp;b)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't forget to set the content type, this will contain the boundary.</span></span><br><span class="line">    req.Header.Set(<span class="string">"Content-Type"</span>, w.FormDataContentType())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit the request</span></span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the response</span></span><br><span class="line">    <span class="keyword">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">"bad status: %s"</span>, res.Status)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustOpen</span><span class="params">(f <span class="keyword">string</span>)</span> *<span class="title">os</span>.<span class="title">File</span></span> &#123;</span><br><span class="line">    r, err := os.Open(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go测试系列一：单元测试</title>
    <url>/Go%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章将带大家入门Golang单元测试，笔者参考不同资料及手动demo，和大家一同看看Golang</p>
</blockquote>
<a id="more"></a>

<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testing <span class="comment">// 系统自带testing库（必备）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/stretchr/testify <span class="comment">// 断言库</span></span><br></pre></td></tr></table></figure>
<p><code>testify</code>库让你写出可读性更好的测试断言：</p>
<p><img src="/images/20210323/1.png" alt=""></p>
<h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><hr>
<p>Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">example/</span><br><span class="line">|--calc.go  </span><br><span class="line">|--calc_test.go</span><br></pre></td></tr></table></figure>

<p>calc.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mul</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>calc_test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">cd到unittest目录，然后直接命令行运行： go test</span></span><br><span class="line"><span class="comment">如果想要显示详细的每个测试方法是否验证成功： go test -v</span></span><br><span class="line"><span class="comment">如果想指定只跑某个测试：go test -run TestAdd -v</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">t.Fatal/t.Fatalf 遇错即停</span></span><br><span class="line"><span class="comment">t.Error/t.Errorf 遇错不停</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ans := Add(<span class="number">1</span>, <span class="number">2</span>); ans != <span class="number">3</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">"1 + 2 expected be 3, but %d got"</span>, ans)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ans := Add(<span class="number">-10</span>, <span class="number">-20</span>); ans != <span class="number">-30</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">"-10 + -20 expected be -30, but %d got"</span>, ans)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMul</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ans := Mul(<span class="number">1</span>, <span class="number">2</span>); ans != <span class="number">2</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">"1 + 2 expected be 2, but %d got"</span>, ans)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ans := Mul(<span class="number">-10</span>, <span class="number">-20</span>); ans != <span class="number">200</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">"-10 + -20 expected be 200, but %d got"</span>, ans)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何运行测试？"><a href="#如何运行测试？" class="headerlink" title="如何运行测试？"></a>如何运行测试？</h2><p>cd到unittest目录，然后直接命令行运行： <code>go test</code><br>如果想要显示详细的每个测试方法是否验证成功： <code>go test -v</code><br>如果想指定只跑某个测试：<code>go test -run TestAdd -v</code></p>
<p>另外：</p>
<ul>
<li><p><code>t.Fatal/t.Fatalf</code> 遇错即停</p>
</li>
<li><p><code>t.Error/t.Errorf</code> 遇错不停</p>
</li>
</ul>
<p>详细命令看这里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go test  // 查找当前目录下的用例文件</span><br><span class="line">go test pkg // pkg包里的所有示例</span><br><span class="line">go test helloworld_test.go //指定用例文件</span><br><span class="line">go test -v -run TestA select_test.go //指定文件的单个单元用例运行。&apos;-v&apos; 打印详细信息</span><br><span class="line">go test -v -bench=. benchmark_test.go // 指定文件的某个性能用例运行。&apos;.&apos; 表示所有性能用例</span><br><span class="line">go test -v -bench=. -benchtime=5s benchmark_test.go // &apos;-benchtime=5s&apos; 指定测试时长，默认1s</span><br><span class="line">go test -v -bench=Alloc -benchmem benchmark_test.go // 指定单个性能用例</span><br><span class="line">go test -cover  //覆盖率</span><br><span class="line">go test ./... -v -cover // 运行当前目录以及子目录的所有的测试文件，并展示详细信息、展示覆盖率</span><br></pre></td></tr></table></figure>

<h1 id="subtest-子测试"><a href="#subtest-子测试" class="headerlink" title="subtest 子测试"></a>subtest 子测试</h1><hr>
<p>cal_test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.....</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMul_SubTests</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  t.Run(<span class="string">"should_return_6_when_Mul_given_2_and_3"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t * testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ans := Mul(<span class="number">2</span>, <span class="number">3</span>); ans != <span class="number">6</span> &#123;</span><br><span class="line">      t.Fatal(<span class="string">"fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  t.Run(<span class="string">"should_return_negative_6_when_Mul_given_2_and_negative_3"</span>, <span class="function"><span class="keyword">func</span><span class="params">(t * testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ans := Mul(<span class="number">2</span>, <span class="number">-3</span>); ans != <span class="number">-6</span> &#123;</span><br><span class="line">      t.Fatal(<span class="string">"fail"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键语句：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t.Run</span><br></pre></td></tr></table></figure>



<h1 id="table-driven-tests-测试"><a href="#table-driven-tests-测试" class="headerlink" title="table-driven tests 测试"></a>table-driven tests 测试</h1><hr>
<p>我们更加推崇这种写法：</p>
<p>demo2.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeString</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo2_test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMergeString</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    X, Y, Expected <span class="keyword">string</span></span><br><span class="line">  &#125;&#123;</span><br><span class="line">    &#123;<span class="string">"should_return_HelloWorld_when_MergeString_given_Hello_and_World"</span>, <span class="string">"Hello"</span>, <span class="string">"World"</span>, <span class="string">"HelloWorld"</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"should_return_aaaBBB_when_MergeString_given_aaa_and_BBB"</span>, <span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"aaaBBB"</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">    t.Run(test.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ans:= MergeString(test.X, test.Y);ans!=test.Expected &#123;</span><br><span class="line">        t.Error(<span class="string">"fail"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有用例的数据组织在切片 <code>cases</code> 中，看起来就像一张表，借助循环创建子测试。这样写的<strong>好处</strong>有：</p>
<ul>
<li><p>新增用例非常简单，只需给 cases 新增一条测试数据即可。</p>
</li>
<li><p>测试代码可读性好，直观地能够看到每个子测试的参数和期待的返回值。</p>
</li>
<li><p>用例失败时，报错信息的格式比较统一，测试报告易于阅读。</p>
</li>
</ul>
<p>如果数据量较大，或是一些二进制数据，推荐使用相对路径从文件中读取</p>
<h1 id="帮助函数Helper"><a href="#帮助函数Helper" class="headerlink" title="帮助函数Helper"></a>帮助函数Helper</h1><hr>
<p>demo3_test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myCase <span class="keyword">struct</span> &#123;</span><br><span class="line">  Str <span class="keyword">string</span></span><br><span class="line">  Expected <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帮助函数：用于将某些 common 的 code，重构出来</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createFirstLetterToUpperCase</span><span class="params">(t *testing.T, c *myCase)</span></span> &#123;</span><br><span class="line">  <span class="comment">// to.Helper() 用于在 运行  go test 时能够打印出报错对应的行号</span></span><br><span class="line">  t.Helper()</span><br><span class="line">  <span class="keyword">if</span> ans := FirstLetterToUpperCase(c.Str); ans != c.Expected &#123;</span><br><span class="line">    t.Errorf(<span class="string">"input is `%s`, expect output is `%s`, but actually output `%s`"</span>, c.Str, c.Expected, ans)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFirstLetterToUpperCase</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  createFirstLetterToUpperCase(t, &amp;myCase&#123;<span class="string">"hello"</span>, <span class="string">"Hello"</span>&#125;)</span><br><span class="line">  createFirstLetterToUpperCase(t, &amp;myCase&#123;<span class="string">"ok"</span>, <span class="string">"Ok"</span>&#125;)</span><br><span class="line">  createFirstLetterToUpperCase(t, &amp;myCase&#123;<span class="string">"Good"</span>, <span class="string">"Good"</span>&#125;)</span><br><span class="line">  createFirstLetterToUpperCase(t, &amp;myCase&#123;<span class="string">"GOOD"</span>, <span class="string">"Good"</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo3.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstLetterToUpperCase</span><span class="params">(x <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strings.ToUpper(x[:<span class="number">1</span>]) + x[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">to.Helper() <span class="comment">// 用于在 运行  go test 时能够打印出报错对应的行号</span></span><br></pre></td></tr></table></figure>

<p>关于 <code>helper</code> 函数的 2 个建议：</p>
<ul>
<li><p>不要返回错误， 帮助函数内部直接使用 <code>t.Error</code> 或 <code>t.Fatal</code> 即可，在用例主逻辑中不会因为太多的错误处理代码，影响可读性。</p>
</li>
<li><p>调用 <code>t.Helper()</code> 让报错信息更准确，有助于定位。</p>
</li>
</ul>
<h1 id="setup-和-teardown"><a href="#setup-和-teardown" class="headerlink" title="setup 和 teardown"></a>setup 和 teardown</h1><hr>
<p>其实就是 一些test 的生命周期相关函数</p>
<p>setup可以做一些初始化操作，teardown可以做一些资源回收工作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Before all tests"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teardown</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"After all tests"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"I'm test1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"I'm test2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">  setup()</span><br><span class="line">  code := m.Run()</span><br><span class="line">  teardown()</span><br><span class="line">  os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>在这个测试文件中，包含有2个测试用例，<code>Test1</code> 和 <code>Test2</code>。</p>
</li>
<li><p>如果测试文件中包含函数 <code>TestMain</code>，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。</p>
</li>
<li><p>调用 <code>m.Run()</code> 触发所有测试用例的执行，并使用 <code>os.Exit()</code> 处理返回的状态码，如果不为0，说明有用例失败。</p>
</li>
<li><p>因此可以在调用 <code>m.Run()</code> 前后做一些额外的准备(setup)和回收(teardown)工作。</p>
</li>
</ul>
<p>执行 <code>go test</code>，将会输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test</span><br><span class="line">Before all tests</span><br><span class="line">I<span class="string">'m test1</span></span><br><span class="line"><span class="string">I'</span>m test2</span><br><span class="line">PASS</span><br><span class="line">After all tests</span><br><span class="line">ok      example <span class="number">0.006</span>s</span><br></pre></td></tr></table></figure>

<h1 id="网络测试-Network"><a href="#网络测试-Network" class="headerlink" title="网络测试(Network)"></a>网络测试(Network)</h1><hr>
<h2 id="TCP-HTTP"><a href="#TCP-HTTP" class="headerlink" title="TCP/HTTP"></a>TCP/HTTP</h2><p>假设需要测试某个 API 接口的 handler 能够正常工作，例如 helloHandler</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们可以创建真实的网络连接进行测试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test code</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"io/ioutil"</span></span><br><span class="line">  <span class="string">"net"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(t *testing.T, err error)</span></span> &#123;</span><br><span class="line">  t.Helper()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Fatal(<span class="string">"failed"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConn</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  ln, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:0"</span>)</span><br><span class="line">  handleError(t, err)</span><br><span class="line">  <span class="keyword">defer</span> ln.Close()</span><br><span class="line"></span><br><span class="line">  http.HandleFunc(<span class="string">"/hello"</span>, helloHandler)</span><br><span class="line">  <span class="keyword">go</span> http.Serve(ln, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  resp, err := http.Get(<span class="string">"http://"</span> + ln.Addr().String() + <span class="string">"/hello"</span>)</span><br><span class="line">  handleError(t, err)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">  body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">  handleError(t, err)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">string</span>(body) != <span class="string">"hello world"</span> &#123;</span><br><span class="line">    t.Fatal(<span class="string">"expected hello world, but got"</span>, <span class="keyword">string</span>(body))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)</code>：监听一个未被占用的端口，并返回 Listener。</p>
</li>
<li><p>调用 <code>http.Serve(ln, nil)</code> 启动 http 服务。</p>
</li>
<li><p>使用 <code>http.Get</code> 发起一个 Get 请求，检查返回值是否正确。</p>
</li>
<li><p>尽量不对 <code>http</code> 和 <code>net</code> 库使用 mock，这样可以覆盖较为真实的场景。</p>
</li>
</ul>
<h2 id="httptest"><a href="#httptest" class="headerlink" title="httptest"></a>httptest</h2><p>针对 http 开发的场景，使用标准库 net/http/httptest 进行测试更为高效。</p>
<p>上述的测试用例改写如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test code</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"io/ioutil"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">  <span class="string">"net/http/httptest"</span></span><br><span class="line">  <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConn</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  req := httptest.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://example.com/foo"</span>, <span class="literal">nil</span>)</span><br><span class="line">  w := httptest.NewRecorder()</span><br><span class="line">  helloHandler(w, req)</span><br><span class="line">  bytes, _ := ioutil.ReadAll(w.Result().Body)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">string</span>(bytes) != <span class="string">"hello world"</span> &#123;</span><br><span class="line">    t.Fatal(<span class="string">"expected hello world, but got"</span>, <span class="keyword">string</span>(bytes))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 httptest 模拟请求对象(req)和响应对象(w)，达到了相同的目的。</p>
<h1 id="Benchmark-基准测试"><a href="#Benchmark-基准测试" class="headerlink" title="Benchmark 基准测试"></a>Benchmark 基准测试</h1><hr>
<p>基准测试用例的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数名必须以 <code>Benchmark</code> 开头，后面一般跟待测试的函数名</p>
</li>
<li><p>参数为 <code>b *testing.B</code>。</p>
</li>
<li><p>执行基准测试时，需要添加 <code>-bench</code> 参数。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHello</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：<code>go test -benchmem -bench .</code><br>得到结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">BenchmarkHello<span class="number">-16</span>   <span class="number">15991854</span>   <span class="number">71.6</span> ns/op   <span class="number">5</span> B/op   <span class="number">1</span> allocs/op</span><br></pre></td></tr></table></figure>

<p>基准测试报告每一列值对应的含义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BenchmarkResult <span class="keyword">struct</span> &#123;  </span><br><span class="line">    N         <span class="keyword">int</span>           <span class="comment">// 迭代次数  </span></span><br><span class="line">    T         time.Duration <span class="comment">// 基准测试花费的时间  </span></span><br><span class="line">    Bytes     <span class="keyword">int64</span>         <span class="comment">// 一次迭代处理的字节数  </span></span><br><span class="line">    MemAllocs <span class="keyword">uint64</span>        <span class="comment">// 总的分配内存的次数  </span></span><br><span class="line">    MemBytes  <span class="keyword">uint64</span>        <span class="comment">// 总的分配内存的字节数  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在运行前基准测试需要一些耗时的配置，则可以使用 <code>b.ResetTimer()</code> 先重置定时器，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkHello</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    ... <span class="comment">// 耗时操作</span></span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>RunParallel</code> 测试并发性能</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    templ := template.Must(template.New(<span class="string">"test"</span>).Parse(<span class="string">"Hello, &#123;&#123;.&#125;&#125;!"</span>))</span><br><span class="line">    b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">    <span class="comment">// 所有 goroutine 一起，循环一共执行 b.N 次</span></span><br><span class="line">    buf.Reset()</span><br><span class="line">    templ.Execute(&amp;buf, <span class="string">"World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> test -benchmem -bench .</span><br><span class="line">...</span><br><span class="line">BenchmarkParallel<span class="number">-16</span>   <span class="number">3325430</span>     <span class="number">375</span> ns/op   <span class="number">272</span> B/op   <span class="number">8</span> allocs/op</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go错误与异常处理实践总结</title>
    <url>/Go%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a><h1 id="我们认识的error"><a href="#我们认识的error" class="headerlink" title="我们认识的error"></a>我们认识的error</h1><p><code>error</code>看着是一个关键字，但本身就是一个接口，位于<code>buildin.go</code>中，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The error built-in interface type is the conventional interface for</span></span><br><span class="line"><span class="comment">// representing an error condition, with the nil value representing no error.</span></span><br><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>而<code>errors.New(string)</code>位于<code>errors/errors.go</code>中，背后返回的是error的最简单实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// errors.New() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单实现：里头就一个错误信息字符串</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">  s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回错误信息字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一般的场景用法"><a href="#一般的场景用法" class="headerlink" title="一般的场景用法"></a>一般的场景用法</h1><p>平常我们写方法的异常处理，一般是这样子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method01</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err:= ConnectDB(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"xxx"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method01</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err:= ConnectDB(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"Connect DB failed!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"xxx"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好一点就把相关的检索用的关键参数一并记录：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Method01</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err:= ConnectDB(url); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Connect DB failed!! url=[%s], %v"</span>, url, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"xxx"</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不妨多理解一下Go中的错误和异常 两者的异同，在实现业务逻辑时，才不会疑惑为何方法要这么写异常处理逻辑，要怎么返回error对象。</p>
<h1 id="再次理解错误与异常"><a href="#再次理解错误与异常" class="headerlink" title="再次理解错误与异常"></a>再次理解错误与异常</h1><p>我们抛开语言特性，如Java中的Error和Exception的角度，而用更为直白的方式去看错误和异常：</p>
<ul>
<li><p>错误【意料之中】：可能出现问题的地方出现了问题，如打开文件失败，连接数据库失败等。</p>
</li>
<li><p>异常【意料之外】：不应该出现问题的地方出现了问题，如引用了空指针。</p>
</li>
</ul>
<p><strong>错误是业务过程的一部分，而异常不是。</strong></p>
<h2 id="Go世界里的错误"><a href="#Go世界里的错误" class="headerlink" title="Go世界里的错误"></a>Go世界里的错误</h2><p>回到Golang的世界，Golang中的<code>error</code>以及以上的几个例子，都是在<strong>错误</strong>这一范畴。Go想要引入error接口作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含error。error的处理过程类似C语言中的错误码，可逐层返回，直到被处理。</p>
<h2 id="Go世界里的异常"><a href="#Go世界里的异常" class="headerlink" title="Go世界里的异常"></a>Go世界里的异常</h2><p>Golang引入两个内置函数：</p>
<ul>
<li><p><code>panic</code>：触发异常处理流程</p>
</li>
<li><p><code>recover</code>：终止异常处理流程</p>
</li>
</ul>
<p>同时引入关键字<code>defer</code>，来延迟执行<code>defer</code>后面的函数，一直等到包含<code>defer</code>语句所在的函数执行完毕，延迟函数（<code>defer</code>后面跟着的函数）才会被执行，而不管包含<code>defer</code>语句的函数时通过return语句正常结束，还是由于<code>panic</code>导致的异常结束。</p>
<p>当发生以下等等情况时：</p>
<ul>
<li><p>引用空指针</p>
</li>
<li><p>下标越界</p>
</li>
<li><p>显示调用<code>panic</code></p>
</li>
<li><p>….</p>
</li>
</ul>
<p>，会先触发<code>panic</code>函数，然后调用延迟函数。调用者继续传递<code>panic</code>，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。如果一路在延迟函数中没有<code>recover</code>函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程，包括主协程（类似于C语言中的主线程，该协程ID为1）。</p>
<h2 id="错误与异常，之于Go"><a href="#错误与异常，之于Go" class="headerlink" title="错误与异常，之于Go"></a>错误与异常，之于Go</h2><p>错误和异常从Golang机制上讲，就是error和panic的区别。</p>
<p>很多其他语言也一样，比如C++/Java，没有error但有errno，没有panic但有throw。</p>
<h2 id="Go错误和异常可以相互转换"><a href="#Go错误和异常可以相互转换" class="headerlink" title="Go错误和异常可以相互转换"></a>Go错误和异常可以相互转换</h2><ul>
<li><p>错误转异常：</p>
</li>
<li><p>比如程序逻辑上尝试请求某个URL，最多尝试三次，前两次请求失败时错误，第三次失败，错误就会被提升为异常；</p>
</li>
<li><p>异常转错误：</p>
</li>
<li><p>比如<code>panic</code>触发的异常被<code>recover</code>恢复后，将返回值中error类型的变量进行赋值，以便上层函数继续走错误处理流程；</p>
</li>
</ul>
<h1 id="看源码，得启发"><a href="#看源码，得启发" class="headerlink" title="看源码，得启发"></a>看源码，得启发</h1><p>重新认识完Golang世界里的错误和异常，让我们一起看个身边源码例子：</p>
<p><code>regexp.go</code>中的两个函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(expr <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> compile(expr, syntax.Perl, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须编译</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span><span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">Regexp</span></span> &#123;</span><br><span class="line">  regexp, err := Compile(str)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">`regexp: Compile(`</span> + quote(str) + <span class="string">`): `</span> + err.Error())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> regexp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然背后都是调用compile()函数，做的都是“编译”，但设计不同：</p>
<ul>
<li><p>Compile函数<strong>基于错误处理设计</strong>，将正则表达式编译成有效的可匹配格式，适用于用户输入场景。当用户输入的正则表达式不合法时，该函数会返回一个错误。</p>
</li>
<li><p>MustCompile函数<strong>基于异常处理设计</strong>，适用于硬编码场景。当调用者明确知道输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，当调用者输入了不应该出现的输入时，就触发panic异常。</p>
</li>
</ul>
<p>于是，我们得到了一个启示：<strong>什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况</strong>。</p>
<h2 id="启发：适用于异常处理的场景"><a href="#启发：适用于异常处理的场景" class="headerlink" title="启发：适用于异常处理的场景"></a>启发：适用于异常处理的场景</h2><p>想一想，我们是否可以归纳出常见得一些场景，这些场景，是需要做异常处理得：</p>
<ol>
<li><p>空指针</p>
</li>
<li><p>下标越界</p>
</li>
<li><p>除数为0</p>
</li>
<li><p>不应该出现得分支，如：default</p>
</li>
<li><p>输入不应该引起函数错误</p>
</li>
</ol>
<p>那么，其他场景，就使用错误处理。</p>
<p>这样，就使得我们在设计接口时更加清晰。</p>
<p>另外，对于异常，我们可以选择在一个合适的上游去recover，并打印堆栈信息，使得部署后的程序不会终止。</p>
<h1 id="实践起来，让代码变漂亮"><a href="#实践起来，让代码变漂亮" class="headerlink" title="实践起来，让代码变漂亮"></a>实践起来，让代码变漂亮</h1><p>看到上面的例子，就知道，我们程序代码中一般处理错误的方式，就是<code>if err != nil {...}</code> 这种方式对实际业务逻辑代码的入侵是很大的，让人看着难受~！</p>
<h2 id="错误处理的正确姿势"><a href="#错误处理的正确姿势" class="headerlink" title="错误处理的正确姿势"></a>错误处理的正确姿势</h2><h3 id="一、失败原因只有一个时，不使用error"><a href="#一、失败原因只有一个时，不使用error" class="headerlink" title="一、失败原因只有一个时，不使用error"></a>一、失败原因只有一个时，不使用error</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *AgentContext)</span> <span class="title">CheckHostType</span><span class="params">(host_type <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> host_type &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"virtual_machine"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"bare_metal"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"CheckHostType ERROR:"</span> + host_type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数的作用其实就是：判断输入是否是某几个值的其中一个，不是就报错。</p>
<p>分析一下：</p>
<ul>
<li><p>方法没有意料之外的事情会发送，最多是属于错误处理场景；</p>
</li>
<li><p>报错只有一种情况，错误没有再分不同情况；</p>
</li>
</ul>
<p>那我用一个bool值不更简单更好被理解？于是变成这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *AgentContext)</span> <span class="title">CheckHostType</span><span class="params">(host_type <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> host_type == <span class="string">"virtual_machine"</span> || host_type == <span class="string">"bare_metal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、没有失败时，不使用error"><a href="#二、没有失败时，不使用error" class="headerlink" title="二、没有失败时，不使用error"></a>二、没有失败时，不使用error</h3><p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">setTargetId</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    self.TargetId = self.Id</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">TryConnect</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">    <span class="comment">// .........</span></span><br><span class="line">    err := c.setTargetId()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// log</span></span><br><span class="line">        <span class="comment">// free resource</span></span><br><span class="line">        <span class="keyword">return</span> errors.New(....)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>不存在报错问题，方法setTargetId不需要返回error；</p>
</li>
<li><p>由于setTargetId返回的error，调用方需要做error的处理；</p>
</li>
</ul>
<p>重构一下，得到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">setTargetId</span><span class="params">()</span></span> &#123;</span><br><span class="line">    self.TargetId = self.Id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">TryConnect</span><span class="params">()</span> <span class="title">error</span></span> &#123; </span><br><span class="line">    <span class="comment">// .........</span></span><br><span class="line">    c.setTargetId()</span><br><span class="line">    <span class="comment">// .........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、error应放在返回值类型列表的最后"><a href="#三、error应放在返回值类型列表的最后" class="headerlink" title="三、error应放在返回值类型列表的最后"></a>三、error应放在返回值类型列表的最后</h3><p>这个应该是一大基本规范了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nill, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，bool作为返回值类型时，也一样，放在返回列表最后：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := cache.Lookup(key) </span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// ...cache[key] does not exist… </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、错误值统一定义，而不是跟着感觉走"><a href="#四、错误值统一定义，而不是跟着感觉走" class="headerlink" title="四、错误值统一定义，而不是跟着感觉走"></a>四、错误值统一定义，而不是跟着感觉走</h3><p>项目中，到处都是 return errors.New(value)，已经让人有些烦躁了，错误内容还要花样多多且意思雷同，过分了！：</p>
<ol>
<li><p>“record is not existed.”</p>
</li>
<li><p>“record is not exist!”</p>
</li>
<li><p>“###record is not existed！！！”</p>
</li>
<li><p>…</p>
</li>
</ol>
<p>不良影响：</p>
<ol>
<li><p>调用方无法统一标准来handle这些error；</p>
</li>
<li><p>万一又新增了一个奇奇怪怪的error，调用方handle不了，又得上代码；</p>
</li>
</ol>
<p>所以，我们可以定义错误码文件，将错误对象定义在一个相对公共的文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ERR_EOF = errors.New(<span class="string">"EOF"</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_CLOSED_PIPE = errors.New(<span class="string">"io: read/write on closed pipe"</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_NO_PROGRESS = errors.New(<span class="string">"multiple Read calls return no data or error"</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_SHORT_BUFFER = errors.New(<span class="string">"short buffer"</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_SHORT_WRITE = errors.New(<span class="string">"short write"</span>)</span><br><span class="line"><span class="keyword">var</span> ERR_UNEXPECTED_EOF = errors.New(<span class="string">"unexpected EOF"</span>)</span><br></pre></td></tr></table></figure>

<p>当然，命名方式可以跟随团队规范。</p>
<h3 id="五、错误逐层传递时，层层都加日志"><a href="#五、错误逐层传递时，层层都加日志" class="headerlink" title="五、错误逐层传递时，层层都加日志"></a>五、错误逐层传递时，层层都加日志</h3><p>目的：方便故障定位</p>
<h3 id="六、错误处理使用defer"><a href="#六、错误处理使用defer" class="headerlink" title="六、错误处理使用defer"></a>六、错误处理使用defer</h3><p>例子：我想要创建4个资源，任何一个资源创建失败，就得回滚并销毁先前创建的资源。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := createResource1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    err = createResource2()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        destroyResource1()</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = createResource3()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        destroyResource1()</span><br><span class="line">        destroyResource2()</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = createResource4()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        destroyResource1()</span><br><span class="line">        destroyResource2()</span><br><span class="line">        destroyResource3()</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE4_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><p>上述方法的异常处理很容易写错；</p>
</li>
<li><p>完全可以利用defer“先进后出”的特性，配合闭包，就做到回滚的效果；</p>
</li>
<li><p>对闭包来说，参数是值传递，对于外部变量却是引用传递，所以闭包中的外部变量err的值就变成外部函数返回时最新的err值；</p>
</li>
</ul>
<p>于是，重构后，得到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferDemo</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    err := createResource1()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE1_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            destroyResource1()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    err = createResource2()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE2_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            destroyResource2()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = createResource3()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE3_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            destroyResource3()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err = createResource4()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ERR_CREATE_RESOURCE4_FAILED</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、尝试几次可以避免失败时，不要立即返回错误"><a href="#七、尝试几次可以避免失败时，不要立即返回错误" class="headerlink" title="七、尝试几次可以避免失败时，不要立即返回错误"></a>七、尝试几次可以避免失败时，不要立即返回错误</h3><p>像请求URL、连接或访问DB等场景，都适用。</p>
<h3 id="八、当上层函数不关心错误时，建议不返回error"><a href="#八、当上层函数不关心错误时，建议不返回error" class="headerlink" title="八、当上层函数不关心错误时，建议不返回error"></a>八、当上层函数不关心错误时，建议不返回error</h3><p>对于一些资源清理相关的函数（destroy/delete/clear），如果子函数出错，打印日志即可，而无需将错误进一步反馈到上层函数，因为一般情况下，上层函数是不关心执行结果的，或者即使关心也无能为力，于是我们建议将相关函数设计为不返回error。</p>
<h3 id="九、当发生错误时，不忽略有用的返回值"><a href="#九、当发生错误时，不忽略有用的返回值" class="headerlink" title="九、当发生错误时，不忽略有用的返回值"></a>九、当发生错误时，不忽略有用的返回值</h3><p>像 <code>func Exec() (int64, error)</code> 这样的DB命令执行函数，返回值是：</p>
<ul>
<li><p>修改成功数量：int64</p>
</li>
<li><p>执行报错：error</p>
</li>
</ul>
<p>这样一来，我们就得关注一下返回值中的这些有用参数，而非只关注error。</p>
<h2 id="异常处理的正确姿势"><a href="#异常处理的正确姿势" class="headerlink" title="异常处理的正确姿势"></a>异常处理的正确姿势</h2><h3 id="一、程序开发阶段，坚持速错"><a href="#一、程序开发阶段，坚持速错" class="headerlink" title="一、程序开发阶段，坚持速错"></a>一、程序开发阶段，坚持速错</h3><p>在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。</p>
<p>这下知道为何我们IDE帮忙实现interface函数，都长这样了吧~</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">DoSthA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"implement me"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、程序部署后，应恢复异常避免程序终止"><a href="#二、程序部署后，应恢复异常避免程序终止" class="headerlink" title="二、程序部署后，应恢复异常避免程序终止"></a>二、程序部署后，应恢复异常避免程序终止</h3><p>要想想，如果不恢复，那么最终异常会终止包括主协程在内的所有协程，最终终止整个进程。</p>
<p>所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。</p>
<p>我们在调用recover的延迟函数中以最合理的方式响应该异常：</p>
<ol>
<li><p>打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；</p>
</li>
<li><p>将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。</p>
</li>
</ol>
<p>看个简单例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"panic recover! p: %v"</span>, p)</span><br><span class="line">            debug.PrintStack()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> funcB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// simulation</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"foo"</span>)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := funcA()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"err is nil\\n"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"err is %v\\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们期望输出：<code>err is foo</code></p>
<p>但是实际输出：<code>err is nil</code></p>
<p>原因：panic异常处理机制不会自动将错误信息传递给error，所以要在funcA函数中进行显式地传递：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"panic recover! p:"</span>, p)</span><br><span class="line">            str, ok := p.(<span class="keyword">string</span>)</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                err = errors.New(str)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = errors.New(<span class="string">"panic"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            debug.PrintStack()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> funcB()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、对于不应该出现的分支，使用异常处理"><a href="#三、对于不应该出现的分支，使用异常处理" class="headerlink" title="三、对于不应该出现的分支，使用异常处理"></a>三、对于不应该出现的分支，使用异常处理</h3><p>如，程序到达了某条逻辑上不可能到达的路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> s := suit(drawCard()); s &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Spades"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Hearts"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Diamonds"</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Clubs"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"invalid suit %v"</span>, s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、针对入参不应该有问题的函数，使用异常"><a href="#四、针对入参不应该有问题的函数，使用异常" class="headerlink" title="四、针对入参不应该有问题的函数，使用异常"></a>四、针对入参不应该有问题的函数，使用异常</h3><p>入参不应该有问题一般指的是硬编码，而非用户输入。（换句话说，程序员自己写下的配置或者代码，不应该有错）</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>在Golang看来，错误是业务过程的一部分，而异常不是；</li>
<li>Golang中，错误处理看<code>error</code>，异常处理看<code>panic</code>、<code>recover</code>；</li>
<li>划分好错误处理和异常处理的使用场景，很关键；</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/f30da01eea97" target="_blank" rel="noopener">https://www.jianshu.com/p/f30da01eea97</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>再看Go变量初始化</title>
    <url>/%E5%86%8D%E7%9C%8BGo%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>我们通过几个小例子快速重温Golang变量初始化过程。</p>
</blockquote>
<a id="more"></a>

<h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>让我们先看看这两个例子，对比一下：</p>
<p>case 1:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span> = b + <span class="number">1</span></span><br><span class="line">    b <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case 2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        a <span class="keyword">int</span> = b + <span class="number">1</span></span><br><span class="line">        b <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哈哈， 两个case一对比，仅仅是变量从包内可见，变成局部变量，但输出结果却是不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 1 -----正常</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">case 2 -----报错</span><br><span class="line">xxx.go:7: undefined: b</span><br></pre></td></tr></table></figure>



<p><strong>原因</strong>：不同作用域类型的变量初始化顺序不同。</p>
<ul>
<li><p>case 2中的a,b 是局部变量（作用域：方法），初始化顺序：从左到右、从上到下；</p>
</li>
<li><p>case 1中package级别的变量，初始化顺序与<strong>初始化依赖</strong>有关；</p>
</li>
</ul>
<p>看看这个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = c - <span class="number">2</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  c = f()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"inside f and b = %d\n"</span>, b)</span><br><span class="line">  <span class="keyword">return</span> b + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(a)</span><br><span class="line">  fmt.Println(b)</span><br><span class="line">  fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inside f and b = 2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>a依赖c，c依赖b，于是，初始化顺序：</p>
<ol>
<li><p>b = 2</p>
</li>
<li><p>c = f() = 3</p>
</li>
<li><p>a = c - 2 = 1</p>
</li>
</ol>
<h2 id="变量循环依赖"><a href="#变量循环依赖" class="headerlink" title="变量循环依赖"></a>变量循环依赖</h2><p>基于这个变量依赖的规则，就可能存在这个变量循环依赖的问题：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a = b</span><br><span class="line">    b = c</span><br><span class="line">    c = f()</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误：“initialization loop”</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go的init函数浅析</title>
    <url>/Go%E7%9A%84init%E5%87%BD%E6%95%B0%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>go中除了 返回即终止的main函数之外，还有一个init函数。</p>
</blockquote>
<a id="more"></a>

<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ul>
<li>初始化不能采用初始化表达式初始化的变量；</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> initArg [<span class="number">20</span>]<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   initArg[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(initArg); i++ &#123;</span><br><span class="line">       initArg[i] = initArg[i<span class="number">-1</span>] * <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序运行前的注册；</p>
</li>
<li><p>实现sync.Once功能；</p>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>运行程序时，先于main函数执行；</p>
</li>
<li><p>不能被其他函数调用；</p>
</li>
<li><p>没有入参、没有返回值；</p>
</li>
<li><p>每个包可以用N个init函数；</p>
</li>
<li><p>每个.go文件中可以用N个init函数；</p>
</li>
<li><p>同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。</p>
</li>
<li><p>不同包的init函数按照包导入的依赖关系决定执行顺序。</p>
</li>
</ul>
<h2 id="golang程序初始化过程"><a href="#golang程序初始化过程" class="headerlink" title="golang程序初始化过程"></a>golang程序初始化过程</h2><p>golang程序初始化先于main函数执行，由runtime进行初始化，初始化顺序如下：</p>
<ol>
<li><p>初始化导入的包（包的初始化顺序并不是按导入顺序（“从上到下”）执行的，runtime需要解析包依赖关系，没有依赖的包最先初始化，与变量初始化依赖关系类似）；</p>
</li>
<li><p>初始化包作用域的变量（该作用域的变量的初始化也并非按照“从上到下、从左到右”的顺序，runtime解析变量依赖关系，没有依赖的变量最先初始化）；</p>
</li>
<li><p>执行包的init函数；</p>
</li>
</ol>
<h3 id="例子：变量初始化-gt-init-gt-main"><a href="#例子：变量初始化-gt-init-gt-main" class="headerlink" title="例子：变量初始化&gt;init()&gt;main()"></a>例子：变量初始化&gt;init()&gt;main()</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                                                                                                     </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span>              </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> T <span class="keyword">int64</span> = a()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"init in main.go"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"calling a()"</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;                  </span><br><span class="line">   fmt.Println(<span class="string">"calling main"</span>)     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calling a()</span><br><span class="line">init in main.go</span><br><span class="line">calling main</span><br></pre></td></tr></table></figure>

<p>初始化顺序：<strong>变量初始化</strong>-&gt;<strong>init()</strong>-&gt;<strong>main()</strong></p>
<h3 id="例子：多个包之间，被依赖的先初始化"><a href="#例子：多个包之间，被依赖的先初始化" class="headerlink" title="例子：多个包之间，被依赖的先初始化"></a>例子：多个包之间，被依赖的先初始化</h3><p>pack/pack.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"demo01/util"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Pack <span class="keyword">int</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := util.Util</span><br><span class="line">  fmt.Println(<span class="string">"init pack "</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>util/util.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Util <span class="keyword">int</span> = a()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"util a()"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"init util"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"init util time2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"init util time3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>util/util2.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"init util2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>util/autil.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"init autil"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B <span class="keyword">int</span> = b()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"autil b()"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"demo01/pack"</span></span><br><span class="line">  <span class="string">"demo01/util"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"main()"</span>, pack.Pack)</span><br><span class="line">  fmt.Println(<span class="string">"main()"</span>, util.Util)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autil b()</span><br><span class="line">util a()</span><br><span class="line">init autil</span><br><span class="line">init util</span><br><span class="line">init util time2</span><br><span class="line">init util time3</span><br><span class="line">init util2</span><br><span class="line">init pack  5</span><br><span class="line">main() 6</span><br><span class="line">main() 5</span><br></pre></td></tr></table></figure>

<p>初始化顺序：</p>
<ol>
<li><p>被依赖的包的所有变量初始化操作，按同包中源文件命名字典序依次执行；</p>
</li>
<li><p>被依赖的包的所有init函数，按同包中源文件命名字典序依次执行；</p>
</li>
<li><p>依赖别包的当前包的init函数；</p>
</li>
</ol>
<h3 id="例子：只想跑init，不想导出变量或方法"><a href="#例子：只想跑init，不想导出变量或方法" class="headerlink" title="例子：只想跑init，不想导出变量或方法"></a>例子：只想跑init，不想导出变量或方法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure>

<p><strong>golang对没有使用的导入包会编译报错，但是有时我们只想调用该包的init函数，不使用包导出的变量或者方法，这时就采用上面的导入方案。</strong></p>
<p>执行上述导入后，init函数会启动一个异步协程采集该进程实例的资源占用情况，并以http服务接口方式提供给用户查询。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>初步了解RBAC</title>
    <url>/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3RBAC/</url>
    <content><![CDATA[<blockquote>
<p>RBAC（Role-Based Access Control）基于角色的权限控制，接下来让我们进一步了解它的前世今生。</p>
</blockquote>
<a id="more"></a>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>RBAC（Role-Based Access Control）基于角色的访问控制。</p>
<p>RBAC96模型：在20世纪90年代期间，大量的专家学者和专门研究单位对RBAC的概念进行了深入研究，先后提出了许多类型的RBAC模型，其中以美国George Mason大学信息安全技术实验室（LIST）提出的RBAC96模型最具有系统性，得到普遍的公认。</p>
<h2 id="授权的过程"><a href="#授权的过程" class="headerlink" title="授权的过程"></a>授权的过程</h2><p>RBAC认为权限的过程可以抽象概括为：判断【Who是否可以对What进行How的访问操作（Operator）】这个逻辑表达式的值是否为True的求解过程。</p>
<p>权限问题 → Who,What,How的问题，三者组成三元组。</p>
<ul>
<li>Who：权限的拥有者或主体（如：User，Role）</li>
<li>What：操作or对象（Operation，Object）</li>
<li>How：具体的权限（可访问、可修改 等等）</li>
</ul>
<h2 id="安全原则"><a href="#安全原则" class="headerlink" title="安全原则"></a>安全原则</h2><p>RBAC支持公认的安全原则：</p>
<ul>
<li>最小特权原则【分配给某人的角色和权限尽量要细分，不要一个权限可以做N件事】</li>
<li>在RBAC模型中可以通过限制分配给角色权限的多少和大小来实现，分配给到某用户对应的角色的权限只要不超过该用户完成其任务的需要，即可；</li>
<li>责任分离原则【一个动作的允许，可以由不止一个角色来决定】</li>
<li>在RBAC模型中可以通过在完成敏感任务过程中分配两个责任上互相约束的两个角色来实现，例如在清查账目时，只需要设置财务管理员和会计两个角色参加就可以了。</li>
<li>数据抽象原则【在权限细分层面，不要直接用”用户表可读”这样的具体字眼，而是抽象得更加易懂】</li>
<li>数据抽象是借助于抽象许可权这样的概念实现的，如在账目管理活动中，可以使用信用、借方等抽象许可权，而不是使用操作系统提供的读、写、执行等具体的许可权。但RBAC并不强迫实现这些原则，安全管理员可以允许配置RBAC模型使它不支持这些原则。因此，RBAC支持数据抽象的程度与RBAC模型的实现细节有关。</li>
</ul>
<h2 id="RBAC是一个种族"><a href="#RBAC是一个种族" class="headerlink" title="RBAC是一个种族"></a>RBAC是一个种族</h2><p>RBAC96是一个模型族，其中包括RBAC0~RBAC3四个概念性模型。<br><img src="/images/20200927/5.png" alt=""></p>
<ol>
<li>基本模型RBAC0定义了完全支持RBAC概念的任何系统的最低需求。</li>
<li>RBAC1和RBAC2两者都包含RBAC0，但各自都增加了独立的特点，它们被称为高级模型。<ol>
<li><strong>RBAC1中增加了角色分级的概念，一个角色可以从另一个角色继承许可权</strong>。</li>
<li><strong>RBAC2中增加了一些限制，强调在RBAC的不同组件中在配置方面的一些限制</strong>。</li>
</ol>
</li>
<li>RBAC3称为统一模型，它包含了RBAC1和RBAC2，利用传递性，也把RBAC0包括在内。这些模型构成了RBAC96模型族。</li>
</ol>
<h2 id="RBAC0"><a href="#RBAC0" class="headerlink" title="RBAC0"></a>RBAC0</h2><p>作为RBAC的核心，四个部分组成：</p>
<ol>
<li>用户（User）</li>
<li>角色（Role）</li>
<li>许可（Permission）</li>
<li>会话（Session）</li>
</ol>
<p><img src="/images/20200927/0.png" alt=""></p>
<p>每个角色至少具备一个权限，每个用户至少扮演一个角色；</p>
<p>可以对两个完全不同的角色分配完全相同的访问权限；</p>
<p>会话由用户控制，一个用户可以创建会话并激活多个用户角色，从而获取相应的访问权限，用户可以在会话中更改激活角色，并且用户可以主动结束一个会话；</p>
<p>用户和角色是<strong>多对多</strong>关系，我和你都可以同时是酒店服务员；</p>
<p>角色和许可（权限）是<strong>多对多</strong>关系，一个权利可以授予多个角色，一个角色也可拥有N个权利；</p>
<h2 id="RBAC1"><a href="#RBAC1" class="headerlink" title="RBAC1"></a>RBAC1</h2><p>相比RBAC0，多了什么：角色间的继承关系（角色分层模型，角色之间有了上下级的区别）。<br><img src="/images/20200927/1.png" alt=""></p>
<h2 id="RBAC2"><a href="#RBAC2" class="headerlink" title="RBAC2"></a>RBAC2</h2><p>相比RBAC0，多了什么：角色的访问控制，添加了职责分离关系。</p>
<p>职责分离包括：</p>
<ul>
<li>静态职责分离（SSD）</li>
<li>SSD主要用在<strong>用户</strong>和<strong>角色</strong>之间（授权阶段），主要约束有：</li>
<li>互斥角色：同一个用户不能授予互斥关系的角色，如：不能同时授予（会计和出纳）或（警察与盗贼）的角色；</li>
<li>基数约束：一个用户拥有的角色是有限的，一个角色拥有的许可也是有限的；</li>
<li>先决条件约束：用户想要得到高级权限，必须先拥有低级权限；</li>
<li>动态职责分离（DSD）</li>
<li>DSD用于 <strong>会话</strong>和<strong>角色</strong>之间的约束，动态决定怎么计划角色，如：一个用户拥有5个角色，只激活2个；</li>
</ul>
<p><img src="/images/20200927/2.png" alt=""></p>
<h2 id="RBAC3"><a href="#RBAC3" class="headerlink" title="RBAC3"></a>RBAC3</h2><p>1 + 2 = 3</p>
<p><img src="/images/20200927/3.png" alt=""></p>
<h1 id="vs-ACL"><a href="#vs-ACL" class="headerlink" title="vs ACL"></a>vs ACL</h1><p>ACL，访问控制列表，核心在于：用户直接和权限挂钩。</p>
<p>于是乎，相较于RBAC，ACL在授权时复杂度较高，如果加入用户组，也会导致系统不好理解，在判断用户是否拥有某个权限时较为困难。</p>
<h1 id="一个较为完善的基于RBAC的ERD图"><a href="#一个较为完善的基于RBAC的ERD图" class="headerlink" title="一个较为完善的基于RBAC的ERD图"></a>一个较为完善的基于RBAC的ERD图</h1><p><img src="/images/20200927/4.png" alt=""></p>
<ul>
<li>以上所有的表，都可以加上created_date, updated_date 等较为common的列；</li>
<li>当然，除了以上的这些数据库表，还可以设计“操作日志表”，用于存储（操作人、操作时间、操作内容）；</li>
</ul>
]]></content>
      <categories>
        <category>用户授权</category>
      </categories>
      <tags>
        <tag>用户授权</tag>
      </tags>
  </entry>
  <entry>
    <title>JMH--细粒度方法的压力测试神器</title>
    <url>/JMH--%E7%BB%86%E7%B2%92%E5%BA%A6%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%A5%9E%E5%99%A8/</url>
    <content><![CDATA[<h1 id="什么是基准测试？"><a href="#什么是基准测试？" class="headerlink" title="什么是基准测试？"></a>什么是基准测试？</h1><p>基准测试（benchmark）：性能测试的一种。</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>通过设计合理的测试方法，选用合适的测试工具和被测系统，实现对某个特定目标场景的某项性能指标进行定量的和可对比的测试。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>可重复性</strong>：可进行重复性的测试，这样做有利于比较每次的测试结果，得到性能结果的长期变化趋势，为系统调优和上线前的容量规划做参考。<blockquote>
<p>PS: 这种特质是为了满足基准测试的日常轮询需要。</p>
</blockquote>
</li>
<li><strong>可观测性</strong>：通过全方位的监控（包括测试开始到结束，执行机、服务器、数据库），及时了解和分析测试过程发生了什么。</li>
<li><strong>可展示性</strong>：相关人员可以直观明了的了解测试结果（web界面、仪表盘、折线图树状图等形式）。</li>
<li><strong>真实性</strong>：测试的结果反映了客户体验到的真实的情况（真实准确的业务场景+与生产一致的配置+合理正确的测试方法）。</li>
<li><strong>可执行性</strong>：相关人员可以快速地进行测试验证修改调优（可定位可分析）。</li>
</ul>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>基准测试一定要在可控条件下进行。就是不要嘴上说着需求只是一天几次CRUD，上线才说要搞个淘宝亿万级并发。</p>
<p>才能得到相对准确的结果，为容量规划、缺陷定位、系统调优提供参考和依据。</p>
<h1 id="JMH简介"><a href="#JMH简介" class="headerlink" title="JMH简介"></a>JMH简介</h1><p>JMH is a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks written in Java and other languages targetting the JVM</p>
<blockquote>
<p>由简介可知，JMH不止能对Java语言做基准测试，还能对运行在JVM上的其他语言做基准测试。而且可以分析到纳秒级别。</p>
</blockquote>
<h1 id="Maven库"><a href="#Maven库" class="headerlink" title="Maven库"></a>Maven库</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.25.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.25.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="推荐用法"><a href="#推荐用法" class="headerlink" title="推荐用法"></a>推荐用法</h1><p>官方推荐创建一个独立的Maven工程来运行JMH基准测试</p>
<h2 id="一、用mvn命令创建工程"><a href="#一、用mvn命令创建工程" class="headerlink" title="一、用mvn命令创建工程"></a>一、用mvn命令创建工程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate </span><br><span class="line">-DinteractiveMode=false </span><br><span class="line">-DarchetypeGroupId=org.openjdk.jmh </span><br><span class="line">-DarchetypeArtifactId=jmh-java-benchmark-archetype </span><br><span class="line">-DgroupId=com.afei.jmh </span><br><span class="line">-DartifactId=jmh-test-demo </span><br><span class="line">-Dversion=1.0.0-SNAPSHOT</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate</span><br></pre></td></tr></table></figure>
<p>然后一步步往下走，创建项目。</p>
<p>注意使用generate的maven项目，update一下依赖和编译jdk的版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jmh.version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">jmh.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javac.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">javac.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uberjar.name</span>&gt;</span>benchmarks<span class="tag">&lt;/<span class="name">uberjar.name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、IDEA打开项目，写一个你想测的代码"><a href="#二、IDEA打开项目，写一个你想测的代码" class="headerlink" title="二、IDEA打开项目，写一个你想测的代码"></a>二、IDEA打开项目，写一个你想测的代码</h2><p>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">5</span>, time = <span class="number">1</span>, timeUnit = TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>, time = <span class="number">1</span>, timeUnit = TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cardCount = <span class="number">54</span>;</span><br><span class="line">        List&lt;Integer&gt; cardList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cardCount; i++)&#123;</span><br><span class="line">            cardList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌算法</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cardCount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rand = random.nextInt(cardCount);</span><br><span class="line">            Collections.swap(cardList, i, rand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cardList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">5</span>, time = <span class="number">1</span>, timeUnit = TimeUnit.SECONDS)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>, time = <span class="number">1</span>, timeUnit = TimeUnit.SECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benchmark02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;Demo&gt; demoList;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        demoList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i ++) &#123;</span><br><span class="line">            demoList.add(<span class="keyword">new</span> Demo(i, <span class="string">"test"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line">    <span class="meta">@OutputTimeUnit</span>(TimeUnit.SECONDS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashMapWithoutSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (Demo demo : demoList) &#123;</span><br><span class="line">            map.put(demo.id, demo.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line">    <span class="meta">@OutputTimeUnit</span>(TimeUnit.MICROSECONDS)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap((<span class="keyword">int</span>)(demoList.size() / <span class="number">0.75f</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Demo demo : demoList) &#123;</span><br><span class="line">            map.put(demo.id, demo.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行压测方式一：直接写一个main方法"><a href="#运行压测方式一：直接写一个main方法" class="headerlink" title="运行压测方式一：直接写一个main方法"></a>运行压测方式一：直接写一个main方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">    Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">            .include(Benchmark02.class.getSimpleName())</span><br><span class="line">            .include(MyBenchmark.class.getSimpleName())</span><br><span class="line">            .forks(<span class="number">1</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行压测方式二：打包并运行jar包"><a href="#运行压测方式二：打包并运行jar包" class="headerlink" title="运行压测方式二：打包并运行jar包"></a>运行压测方式二：打包并运行jar包</h2><h3 id="1-用mvn打包项目"><a href="#1-用mvn打包项目" class="headerlink" title="1. 用mvn打包项目"></a>1. 用mvn打包项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>会看到<code>/target/benchmarks.jar</code>文件，具体打包得到的jar包文件名，是在<code>pom.xml</code>文件中配置的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>benchmarks.jar<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-执行jar"><a href="#2-执行jar" class="headerlink" title="2. 执行jar"></a>2. 执行jar</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar target/benchmarks.jar</span><br></pre></td></tr></table></figure>

<h1 id="运行结果分析"><a href="#运行结果分析" class="headerlink" title="运行结果分析"></a>运行结果分析</h1><p>得到输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># VM invoker: C:\Program Files\Java\jre1.8.0_181\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 1 s each</span><br><span class="line"># Measurement: 5 iterations, 1 s each</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Average time, time/op</span><br><span class="line"># Benchmark: com.afei.jmh.MyBenchmark.testMethod</span><br><span class="line"></span><br><span class="line"># Run progress: 0.00% complete, ETA 00:00:10</span><br><span class="line"># Fork: 1 of 1</span><br><span class="line"># Warmup Iteration   1: 913.311 ns/op</span><br><span class="line"># Warmup Iteration   2: 829.894 ns/op</span><br><span class="line"># Warmup Iteration   3: 856.890 ns/op</span><br><span class="line"># Warmup Iteration   4: 851.876 ns/op</span><br><span class="line"># Warmup Iteration   5: 849.720 ns/op</span><br><span class="line">Iteration   1: 863.683 ns/op</span><br><span class="line">Iteration   2: 852.417 ns/op</span><br><span class="line">Iteration   3: 856.067 ns/op</span><br><span class="line">Iteration   4: 869.006 ns/op</span><br><span class="line">Iteration   5: 878.699 ns/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result: 863.974 ±(99.9%) 40.309 ns/op [Average]</span><br><span class="line">  Statistics: (min, avg, max) = (852.417, 863.974, 878.699), stdev = 10.468</span><br><span class="line">  Confidence interval (99.9%): [823.665, 904.283]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:00:12</span><br><span class="line"></span><br><span class="line">Benchmark                       Mode  Samples    Score  Score error  Units</span><br><span class="line">c.a.j.MyBenchmark.testMethod    avgt        5  863.974       40.309  ns/op</span><br></pre></td></tr></table></figure>

<h2 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="@Benchmarks"></a>@Benchmarks</h2><p><code>@Benchmark</code>标签是用来标记测试方法的，只有被这个注解标记的话，该方法才会参与基准测试，但是有一个基本的原则就是被<code>@Benchmark</code>标记的方法必须是<strong>public</strong>的。</p>
<h2 id="Warmup"><a href="#Warmup" class="headerlink" title="@Warmup"></a>@Warmup</h2><p>参数解释：</p>
<ul>
<li>iterations：预热的次数。</li>
<li>time：每次预热的时间。</li>
<li>timeUnit：时间单位，默认是s。</li>
<li>batchSize：批处理大小，每次操作调用几次方法。（后面用到）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>
<p>表示预热5秒（迭代5次，每次1秒）。<br>对应输出日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Warmup Iteration   1: 913.311 ns/op</span><br><span class="line"># Warmup Iteration   2: 829.894 ns/op</span><br><span class="line"># Warmup Iteration   3: 856.890 ns/op</span><br><span class="line"># Warmup Iteration   4: 851.876 ns/op</span><br><span class="line"># Warmup Iteration   5: 849.720 ns/op</span><br></pre></td></tr></table></figure>
<blockquote>
<p>预热？为什么要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>
</blockquote>
<h2 id="Measurement"><a href="#Measurement" class="headerlink" title="@Measurement"></a>@Measurement</h2><p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span><br></pre></td></tr></table></figure>
<p>表示循环运行5次，总计5秒时间。</p>
<h2 id="Fork"><a href="#Fork" class="headerlink" title="@Fork"></a>@Fork</h2><p>这个注解表示fork多少个线程运行基准测试：</p>
<ul>
<li><code>@Fork(1)</code>：那么就是一个线程，这时候就是同步模式。</li>
</ul>
<h2 id="BenchmarkMode-amp-amp-OutputTimeUnit"><a href="#BenchmarkMode-amp-amp-OutputTimeUnit" class="headerlink" title="@BenchmarkMode &amp;&amp; @OutputTimeUnit"></a>@BenchmarkMode &amp;&amp; @OutputTimeUnit</h2><p>基准测试模式申明为：</p>
<ul>
<li><code>@BenchmarkMode(Mode.AverageTime)</code><ul>
<li><code>Mode</code>有以下几个options：<ul>
<li><code>Mode.Throughput</code>：每毫秒的吞吐量（即每毫秒多少次操作）</li>
<li><code>Mode.AverageTime</code>：平均耗时</li>
<li><code>Mode.SampleTime</code>：抽样检测</li>
<li><code>Mode.SingleShotTime</code>：检测一次调用</li>
<li><code>Mode.All</code>：运行所有的检测模式</li>
</ul>
</li>
</ul>
</li>
<li><code>@OutputTimeUnit(TimeUnit.NANOSECONDS)</code>（可选基准测试模式通过枚举Mode得到）</li>
</ul>
<p>可以这样同时多个维度对目标方法进行测量：<code>@BenchmarkMode({Mode.Throughput, Mode.AverageTime, Mode.SampleTime, Mode.SingleShotTime})</code></p>
<p>笔者的示例是AverageTime，即表示每次操作需要的平均时间，而OutputTimeUnit申明为纳秒，所以基准测试单位是ns/op，即每次操作的纳秒单位平均时间。基准测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 863.974 ±(99.9%) 40.309 ns/op [Average]</span><br><span class="line">  Statistics: (min, avg, max) = (852.417, 863.974, 878.699), stdev = 10.468</span><br><span class="line">  Confidence interval (99.9%): [823.665, 904.283]</span><br></pre></td></tr></table></figure>
<p>最后一段结果如下，重点关注<strong>Mean</strong>和<strong>Units</strong>两个字段，组合起来就是 <strong>863.974ns/op</strong>，即每次操作耗时863.974纳秒：</p>
<p>对于 <strong>Mean error</strong>：表示误差，或者波动。</p>
<h2 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h2><p>在很多时候我们需要维护一些状态内容，比如在多线程的时候我们会维护一个共享的状态，这个状态值可能会在每隔线程中都一样，也有可能是每个线程都有自己的状态，JMH为我们提供了状态的支持。该注解只能用来标注在类上，因为类作为一个属性的载体。 @State的状态值主要有以下几种：</p>
<ul>
<li><code>Scope.Benchmark</code> 该状态的意思是会在所有的Benchmark的工作线程中共享变量内容。</li>
<li><code>Scope.Group</code> 同一个Group的线程可以享有同样的变量</li>
<li><code>Scope.Thread</code> 每隔线程都享有一份变量的副本，线程之间对于变量的修改不会相互影响。<br>下面看两个常见的@State的写法：</li>
</ul>
<p>1.直接在内部类中使用@State作为“PropertyHolder”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMHSample_03_States</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BenchmarkState</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">double</span> x = Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@State</span>(Scope.Thread)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">double</span> x = Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureUnshared</span><span class="params">(ThreadState state)</span> </span>&#123;</span><br><span class="line">        state.x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureShared</span><span class="params">(BenchmarkState state)</span> </span>&#123;</span><br><span class="line">        state.x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JMHSample_03_States.class.getSimpleName())</span><br><span class="line">                .threads(<span class="number">4</span>)</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在Main类中直接使用@State作为注解，是Main类直接成为“PropertyHolder”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMHSample_04_DefaultState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.PI;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JMHSample_04_DefaultState.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们试想以下@State的含义，它主要是方便框架来控制变量的过程逻辑，通过@State标示的类都被用作属性的容器，然后框架可以通过自己的控制来配置不同级别的隔离情况。被@Benchmark标注的方法可以有参数，但是参数必须是被@State注解的，就是为了要控制参数的隔离。<br>但是有些情况下我们需要对参数进行一些初始化或者释放的操作，就像Spring提供的一些init和destory方法一样，JHM也提供有这样的钩子：</p>
<ul>
<li><code>@Setup</code> 必须标示在@State注解的类内部，表示初始化操作</li>
<li><code>@TearDown</code> 必须表示在@State注解的类内部，表示销毁操作</li>
</ul>
<p>初始化和销毁的动作都只会执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMHSample_05_StateFixtures</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = Math.PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TearDown</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; Math.PI : <span class="string">"Nothing changed?"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JMHSample_05_StateFixtures.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .jvmArgs(<span class="string">"-ea"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们可以执行初始化和销毁的动作，但是总是感觉还缺点啥？对，就是初始化的粒度。因为基准测试往往会执行多次，那么能不能保证每次执行方法的时候都初始化一次变量呢？ @Setup和@TearDown提供了以下三种纬度的控制：</p>
<ul>
<li><code>Level.Trial</code> 只会在个基础测试的前后执行。包括Warmup和Measurement阶段，一共只会执行一次。</li>
<li><code>Level.Iteration</code> 每次执行记住测试方法的时候都会执行，如果Warmup和Measurement都配置了2次执行的话，那么@Setup和@TearDown配置的方法的执行次数就4次。</li>
<li><code>Level.Invocation</code> 每个方法执行的前后执行（一般不推荐这么用）</li>
</ul>
<h2 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h2><p>在很多情况下，我们需要测试不同的参数的不同结果，但是测试的了逻辑又都是一样的，因此如果我们编写镀铬benchmark的话会造成逻辑的冗余，幸好JMH提供了<code>@Param</code>参数来帮助我们处理这个事情，被<code>@Param</code>注解标示的参数组会一次被benchmark消费到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Param</span>(&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;)</span><br><span class="line">    <span class="keyword">int</span> testNum;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(testNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(ParamTest.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Threads"><a href="#Threads" class="headerlink" title="@Threads"></a>@Threads</h2><p>测试线程的数量，可以配置在方法或者类上，代表执行测试的线程数量。</p>
<blockquote>
<p>通常看到这里我们会比较迷惑Iteration和Invocation区别，我们在配置Warmup的时候默认的时间是的1s，即1s的执行作为一个Iteration，假设每次方法的执行是100ms的话，那么1个Iteration就代表10个Invocation。</p>
</blockquote>
<h1 id="JMH进阶"><a href="#JMH进阶" class="headerlink" title="JMH进阶"></a>JMH进阶</h1><h2 id="不要编写无用代码"><a href="#不要编写无用代码" class="headerlink" title="不要编写无用代码"></a>不要编写无用代码</h2><p>因为现代的编译器非常聪明，如果我们在代码使用了没有用处的变量的话，就容易被编译器优化掉，这就会导致实际的测量结果可能不准确，因为我们要在测量的方法中避免使用void方法，然后记得在测量的结束位置返回结果。这么做的目的很明确，就是为了与编译器斗智斗勇，让编译器不要改变这段代码执行的初衷。</p>
<h2 id="Blackhole介绍"><a href="#Blackhole介绍" class="headerlink" title="Blackhole介绍"></a>Blackhole介绍</h2><p>Blackhole会消费传进来的值，不提供任何信息来确定这些值是否在之后被实际使用。<br>Blackhole处理的事情主要有以下几种：</p>
<ul>
<li>死代码消除：入参应该在每次都被用到，因此编译器就不会把这些参数优化为常量或者在计算的过程中对他们进行其他优化。</li>
<li>处理内存壁：我们需要尽可能减少写的量，因为它会干扰缓存，污染写缓冲区等。<br>这很可能导致过早地撞到内存壁</li>
</ul>
<p>我们在上面说到需要消除无用代码，那么其中一种方式就是通过Blackhole，我们可以用Blackhole来消费这些返回的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1:返回测试结果，防止编译器优化</span></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">measureRight_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.log(x1) + Math.log(x2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.通过Blackhole消费中间结果，防止编译器优化</span></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureRight_2</span><span class="params">(Blackhole bh)</span> </span>&#123;</span><br><span class="line">    bh.consume(Math.log(x1));</span><br><span class="line">    bh.consume(Math.log(x2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环处理"><a href="#循环处理" class="headerlink" title="循环处理"></a>循环处理</h2><p>我们虽然可以在Benchmark中定义循环逻辑，但是这么做其实是不合适的，因为编译器可能会将我们的循环进行展开或者做一些其他方面的循环优化，所以JHM建议我们不要在Beanchmark中使用循环，如果我们需要处理循环逻辑了，可以结合@BenchmarkMode(Mode.SingleShotTime)和@Measurement(batchSize = N)来达到同样的效果.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMHSample_26_BatchSize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个iteration中做5000次Invocation</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@Warmup</span>(iterations = <span class="number">5</span>, batchSize = <span class="number">5000</span>)</span><br><span class="line">    <span class="meta">@Measurement</span>(iterations = <span class="number">5</span>, batchSize = <span class="number">5000</span>)</span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(Mode.SingleShotTime)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">measureRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list.add(list.size() / <span class="number">2</span>, <span class="string">"something"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setup</span>(Level.Iteration)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JMHSample_26_BatchSize.class.getSimpleName())</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h2><p>方法内联：如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身。比如说下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add2(x1, x2) + add2(x3, x4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 + x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一段时间后JVM会把add2方法去掉，并把你的代码翻译成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1 + x2 + x3 + x4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JMH提供了CompilerControl注解来控制方法内联，但是实际上我感觉比较有用的就是两个了：</p>
<ul>
<li>CompilerControl.Mode.DONT_INLINE：强制限制不能使用内联</li>
<li>CompilerControl.Mode.INLINE：强制使用内联</li>
</ul>
<p>看一下官方提供的例子把：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMHSample_16_CompilerControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_blank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CompilerControl</span>(CompilerControl.Mode.DONT_INLINE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_dontInline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CompilerControl</span>(CompilerControl.Mode.INLINE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_inline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dontinline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        target_dontInline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        target_inline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(JMHSample_16_CompilerControl.class.getSimpleName())</span><br><span class="line">                .warmupIterations(<span class="number">0</span>)</span><br><span class="line">                .measurementIterations(<span class="number">3</span>)</span><br><span class="line">                .forks(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">======================================执行结果==============================</span><br><span class="line">Benchmark                                Mode  Cnt  Score   Error  Units</span><br><span class="line">JMHSample_16_CompilerControl.baseline    avgt    <span class="number">3</span>  <span class="number">0.896</span> ± <span class="number">3.426</span>  ns/op</span><br><span class="line">JMHSample_16_CompilerControl.dontinline  avgt    <span class="number">3</span>  <span class="number">0.344</span> ± <span class="number">0.126</span>  ns/op</span><br><span class="line">JMHSample_16_CompilerControl.inline      avgt    <span class="number">3</span>  <span class="number">0.391</span> ± <span class="number">2.622</span>  ns/op</span><br><span class="line">======================================执行结果==============================</span><br></pre></td></tr></table></figure>

<h1 id="JMH和jMeter的不同"><a href="#JMH和jMeter的不同" class="headerlink" title="JMH和jMeter的不同"></a>JMH和jMeter的不同</h1><p>JMH和jMeter的使用场景还是有很大的不同的，jMeter更多的是对rest api进行压测，而JMH关注的粒度更细，它更多的是发现某块性能槽点代码，然后对优化方案进行基准测试对比。比如json序列化方案对比，bean copy方案对比，文中提高的洗牌算法对比等。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://www.jianshu.com/p/0da2988b9846" target="_blank" rel="noopener">https://www.jianshu.com/p/0da2988b9846</a></li>
<li><a href="https://www.jianshu.com/p/23abfe3251ca" target="_blank" rel="noopener">https://www.jianshu.com/p/23abfe3251ca</a></li>
<li><a href="https://juejin.im/post/5c471d3ff265da61427433b3" target="_blank" rel="noopener">https://juejin.im/post/5c471d3ff265da61427433b3</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 通过类名找到类的踩坑之路</title>
    <url>/Spring%20Boot%20%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E6%89%BE%E5%88%B0%E7%B1%BB%E7%9A%84%E8%B8%A9%E5%9D%91%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>通过全类名找类，估计大家都尝试过，但，通过 simple类名去找类，估计少用，这不，有个业务场景，尝试通过这个方式去解决，并进而踩坑的过程分享。</p>
</blockquote>
<a id="more"></a>

<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>我通过MQ 传给你一个message，message上面有一堆的header，每个header都是一个json，我还传了一个headerType 列表，用于告诉 consumer，每个header到底是什么类型的，String？Integer？CustomObj？ 换言之，就是多了一份类型描述文档：</p>
<p>Message Header:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"breadcrumbId"</span>: <span class="string">"ID-76265358ec77-1594171418720-0-187147"</span>,</span><br><span class="line">    <span class="attr">"CamelJmsDeliveryMode"</span>: <span class="string">"2"</span>,</span><br><span class="line">    <span class="attr">"CARRIED_DATA_LIST"</span>: <span class="string">"&#123;\"EVENT_ACTION\":\"java.lang.String\",\"EVENT_NUMBER_RELATIONSHIP\":\"com.example.entity.NumberRelationship\",\"EVENT_DATE_TIME\":\"java.time.LocalDateTime\"&#125;"</span>,</span><br><span class="line">    <span class="attr">"EVENT_ACTION"</span>: <span class="string">"NEW"</span>,</span><br><span class="line">    <span class="attr">"EVENT_DATE_TIME"</span>: <span class="string">"\"2020-07-24T10:37:27\""</span>,</span><br><span class="line">    <span class="attr">"EVENT_NUMBER_RELATIONSHIP"</span>: <span class="string">"&#123;\"orderNumber\":\"Order001\",\"traceNumber\":\"TraceId01\",\"customerId\":\"user001\"&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好，那consumer方要拿到这份json，然后，为了方便做一些处理，consumer方会尝试根据 这份message header里头的  <code>CARRIED_DATA_LIST</code> 这份类型清单，然后，根据这个类型去做一个 JSON to Java Object 的映射，然后方便我们以Java Object 的方式去进行后续的logic处理。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>于是，我们有了一个<code>OwnClassUtil.java</code>，在类加载过程中就扫描并加载好所有里里外外的类名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnClassUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; ownClassList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ownClassList = getAllClassName();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">findDeclaredClassName</span><span class="params">(String className)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class clazz = findClassByCompleteName(className);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] splits = className.split(<span class="string">"\\."</span>);</span><br><span class="line">        String simpleClassName = splits[splits.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> findClassBySimpleClassName(simpleClassName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">findClassByCompleteName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">findClassBySimpleClassName</span><span class="params">(String simpleClassName)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"String"</span>.equals(simpleClassName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.class;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ownClassList.contains(simpleClassName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(simpleClassName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String className : ownClassList) &#123;</span><br><span class="line">            String[] strings = className.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="keyword">if</span> (strings.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (strings[strings.length - <span class="number">1</span>].equals(simpleClassName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"can not find class "</span> + simpleClassName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getAllClassName</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.addAll(getClassName(<span class="string">"com.example.myapp"</span>));</span><br><span class="line">        names.addAll(getClassName(<span class="string">"com.example.common"</span>));</span><br><span class="line">        <span class="keyword">return</span> names;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassName</span><span class="params">(String packageName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClassName(packageName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassName</span><span class="params">(String packageName, <span class="keyword">boolean</span> childPackage)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        List&lt;String&gt; fileNames = <span class="keyword">null</span>;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        String packagePath = packageName.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; resources = loader.getResources(packagePath);</span><br><span class="line">        URL url = loader.getResource(packagePath);</span><br><span class="line">        <span class="keyword">while</span> (resources.hasMoreElements()) &#123;</span><br><span class="line">            url = resources.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (!url.toString().contains(<span class="string">"test-classes"</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String type = url.getProtocol();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"file"</span>.equals(type)) &#123;</span><br><span class="line">                fileNames = getClassNameByFile(url.getPath(), <span class="keyword">null</span>, childPackage);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"jar"</span>.equals(type)) &#123;</span><br><span class="line">                fileNames = getClassNameByJar(url.getPath(), childPackage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileNames = getClassNameByJars(((URLClassLoader) loader).getURLs(), packagePath, childPackage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassNameByFile</span><span class="params">(String filePath, List&lt;String&gt; className, <span class="keyword">boolean</span> childPackage)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; myClassName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        File[] childFiles = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File childFile : childFiles) &#123;</span><br><span class="line">            <span class="keyword">if</span> (childFile.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childPackage) &#123;</span><br><span class="line">                    myClassName.addAll(getClassNameByFile(childFile.getPath(), myClassName, childPackage));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String childFilePath = childFile.getPath();</span><br><span class="line">                <span class="keyword">if</span> (childFilePath.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                    childFilePath = childFilePath.substring(childFilePath.indexOf(<span class="string">"classes"</span>) + <span class="number">8</span>,</span><br><span class="line">                            childFilePath.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">                    childFilePath = childFilePath.replace(<span class="string">"\\"</span>, <span class="string">"."</span>);</span><br><span class="line">                    childFilePath = childFilePath.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">                    myClassName.add(childFilePath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> myClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassNameByJar</span><span class="params">(String jarPath, <span class="keyword">boolean</span> childPackage)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; myClassName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String[] jarInfo = jarPath.split(<span class="string">"!"</span>);</span><br><span class="line">        String jarFilePath = jarInfo[<span class="number">0</span>].substring(jarInfo[<span class="number">0</span>].indexOf(<span class="string">"/"</span>));</span><br><span class="line">        String packagePath = jarInfo[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JarFile jarFile = <span class="keyword">new</span> JarFile(jarFilePath);</span><br><span class="line">            Enumeration&lt;JarEntry&gt; entrys = jarFile.entries();</span><br><span class="line">            <span class="keyword">while</span> (entrys.hasMoreElements()) &#123;</span><br><span class="line">                JarEntry jarEntry = entrys.nextElement();</span><br><span class="line">                String entryName = jarEntry.getName();</span><br><span class="line">                <span class="keyword">if</span> (entryName.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childPackage) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (entryName.startsWith(packagePath)) &#123;</span><br><span class="line">                            entryName = entryName.replace(<span class="string">"/"</span>, <span class="string">"."</span>).substring(<span class="number">0</span>, entryName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">                            myClassName.add(entryName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> index = entryName.lastIndexOf(<span class="string">"/"</span>);</span><br><span class="line">                        String myPackagePath;</span><br><span class="line">                        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">                            myPackagePath = entryName.substring(<span class="number">0</span>, index);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            myPackagePath = entryName;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (myPackagePath.equals(packagePath)) &#123;</span><br><span class="line">                            entryName = entryName.replace(<span class="string">"/"</span>, <span class="string">"."</span>).substring(<span class="number">0</span>, entryName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">                            myClassName.add(entryName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassNameByJars</span><span class="params">(URL[] urls, String packagePath, <span class="keyword">boolean</span> childPackage)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; myClassName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; urls.length; i++) &#123;</span><br><span class="line">                URL url = urls[i];</span><br><span class="line">                String urlPath = url.getPath();</span><br><span class="line">                <span class="keyword">if</span> (urlPath.endsWith(<span class="string">"classes/"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String jarPath = urlPath + <span class="string">"!/"</span> + packagePath;</span><br><span class="line">                myClassName.addAll(getClassNameByJar(jarPath, childPackage));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myClassName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，就能够实现 当传入的 类型清单 里告诉我，这个 <code>EVENT_NUMBER_RELATIONSHIP</code> header 实际是 一个 <code>com.example.entity.NumberRelationship</code> 类型时，我能够match上我这边app的同名类，如 <code>com.backend.po.NumberRelationship</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String type = typeListMap.get(<span class="string">"EVENT_NUMBER_RELATIONSHIP"</span>); <span class="comment">// com.example.entity.NumberRelationship</span></span><br><span class="line">String stringValue = headerMap.get(<span class="string">"EVENT_NUMBER_RELATIONSHIP"</span>); <span class="comment">// "&#123;\"orderNumber\":\"Order001\",\"traceNumber\":\"TraceId01\",\"customerId\":\"user001\"&#125;"</span></span><br><span class="line">Class&lt;?&gt; clazz = OwnClassUtil.findDeclaredClassName(type);</span><br><span class="line">JsonUtils.jsonToObject(jsonValue, clazz); <span class="comment">//  com.backend.po.NumberRelationship 实例对象</span></span><br></pre></td></tr></table></figure>
<p>其中，JsonUtils是用的 alibaba FastJson：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">jsonToObject</span><span class="params">(String json, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(json)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONObject.parseObject(json, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSONObject.parseObject(<span class="string">"\""</span> + json + <span class="string">"\""</span>, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="抽common-lib-之后"><a href="#抽common-lib-之后" class="headerlink" title="抽common lib 之后"></a>抽common lib 之后</h1><p>好，当业务logic多了之后，我们将一些common的 po类放入 common lib，供其他 app 引用。</p>
<p>然后，我们准备在本地 run 或者 debug 一个 引用了 common lib 的 app，我们称其为”<strong>my-app</strong>“，<br><img src="/images/20200805/1.png" alt=""></p>
<p>此时 <code>OwnClassUtil.java</code> 发挥正常，其中的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader loader = Thread.currentThread().getContextClassLoader(); </span><br><span class="line">String packagePath = packageName.replace(<span class="string">"."</span>, <span class="string">"/"</span>); </span><br><span class="line">Enumeration&lt;URL&gt; resources = loader.getResources(packagePath); </span><br><span class="line">URL url = loader.getResource(packagePath);</span><br><span class="line"><span class="comment">//........</span></span><br></pre></td></tr></table></figure>
<p>ContextClassLoader 能够正常 加载到 本app package 和 common-lib package 两边的 class：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.myapp.entity.Student</span><br><span class="line">com.example.myapp.entity.Teacher</span><br><span class="line">com.example.myapp.entity.Address</span><br><span class="line">com.example.common.lib.po.NumberRelationship</span><br><span class="line">com.example.common.lib.po.Customer</span><br><span class="line">com.example.common.lib.po.Order</span><br></pre></td></tr></table></figure>

<p>所有的  “JSON to Java Object” 的logic 都完好运行。</p>
<h1 id="打jar包之后"><a href="#打jar包之后" class="headerlink" title="打jar包之后"></a>打jar包之后</h1><p>好，现在要将这个 <strong>my-app</strong> <code>mvn clean package</code> 一下了，因为它用的插件是：<code>spring-boot-maven-plugin</code>，所以打出来的包 就是 可以直接 通过 <code>java -jar</code> 命令启动的。</p>
<p>但是，我们发现，通过 <code>java -jar my-app.jar</code> 运行起来后，虽然spring boot 项目能正常运行，但是却发现， 我们的 <code>OwnClassUtil</code> 类并没有扫描到 common-lib 中的 类，换句话说，此时，线程上下文类加载器 ContextClassLoader 只扫描到了 当前项目的包<code>com.example.myapp</code>下的类，其他第三方库中的类并没有被扫描到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.myapp.entity.Student</span><br><span class="line">com.example.myapp.entity.Teacher</span><br><span class="line">com.example.myapp.entity.Address</span><br></pre></td></tr></table></figure>

<h1 id="扫描不到类的解决方案"><a href="#扫描不到类的解决方案" class="headerlink" title="扫描不到类的解决方案"></a>扫描不到类的解决方案</h1><h2 id="方案一：ExtClassLoader帮忙扫多一个自定义目录"><a href="#方案一：ExtClassLoader帮忙扫多一个自定义目录" class="headerlink" title="方案一：ExtClassLoader帮忙扫多一个自定义目录"></a>方案一：ExtClassLoader帮忙扫多一个自定义目录</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们知道，在整个JVM类加载过程中，遵循双亲委派机制的、我们最熟悉的三个ClassLoader：</p>
<ul>
<li>BootstrapClassLoader：【我爷爷】<ul>
<li>JVM级别的，由C++撰写，jvm中某c++写的dll类</li>
<li>负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等</li>
</ul>
</li>
<li>ExtClassLoader：【我爸】<ul>
<li>Java类</li>
<li>继承自URLClassLoader超类</li>
<li>负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar和class</li>
<li>由 <code>sun.misc.Launcher</code> 初始化</li>
</ul>
</li>
<li>AppClassLoader：【我】<ul>
<li>Java类</li>
<li>继承自URLClassLoader超类</li>
<li>负责加载当前java应用的classpath中的所有类。</li>
<li>由 <code>sun.misc.Launcher</code> 初始化</li>
</ul>
</li>
<li>自定义 ClassLoader：【我同辈】<ul>
<li>Java类</li>
<li>继承自URLClassLoader超类</li>
</ul>
</li>
</ul>
<p>其中，</p>
<ul>
<li>AppClassLoader 对应加载  <code>--classpath</code>，可以这样扩展：<blockquote>
<p>JDK 9 弃用 -classpath  改用 –class-path</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -cp <span class="string">"./:./lib/a.jar:./lib/b.jar"</span> -jar  my-app.jar</span><br><span class="line"></span><br><span class="line">// 当 lib目录下jar过多，一般使用 shell帮忙</span><br><span class="line">CLASS_PATH=./</span><br><span class="line"><span class="keyword">for</span> jar <span class="keyword">in</span> ./lib/*.jar; <span class="keyword">do</span></span><br><span class="line">   CLASS_PATH=<span class="variable">$CLASS_PATH</span>:<span class="variable">$jar</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">java -cp <span class="variable">$CLASS_PATH</span> -jar my-app.jar</span><br></pre></td></tr></table></figure></li>
<li>ExtClassLoader 对应加载 <code>java.ext.dirs</code>，可以这样动态让ExtClassLoader多加载一个目录<code>./mylib</code>：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// Linux</span><br><span class="line">java -Djava.ext.dirs=<span class="variable">$JAVA_HOME</span>/jre/lib/ext:/usr/java/packages/lib/ext:./mylib -jar  my-app.jar</span><br><span class="line"></span><br><span class="line">// Windows (分号 和 冒号的区别)</span><br><span class="line">java -Djava.ext.dirs=<span class="variable">$JAVA_HOME</span>/jre/lib/ext;/usr/java/packages/lib/ext;./mylib -jar  my-app.jar</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>所以，我们 可以利用这一点，让ExtClassLoader 帮 <code>OwnClassUtil</code> 一把，帮忙加载一些我们想扫描的jar包。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>首先，优化一下我们的<code>OwnClassUtil</code> 中的<code>getClassName</code> 方法，让ExtClassLoader 进来帮帮忙：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getClassName</span><span class="params">(String packageName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = getClassName(Thread.currentThread().getContextClassLoader(), packageName, <span class="keyword">true</span>); <span class="comment">// 上下文ClassLoader先尝试扫描</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(names)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader extClassLoader = OwnClassUtil.class.getClassLoader().getParent().getParent(); <span class="comment">// ExtClassLoader 再帮忙扫描</span></span><br><span class="line">            names = getClassName(extClassLoader, packageName, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后，<code>mvn clean package</code>打包</li>
<li>将打包好的<code>my-app.jar</code> 解压：<code>unzip my-app.jar</code></li>
<li>得到三个目录：<code>BOOT-INF</code>，<code>META-INF</code> 以及 <code>org</code></li>
<li>然后，在启动jar包时，执行这样一句命令：<code>java -jar -Djava.ext.dirs=$JAVA_HOME/jre/lib/ext;/usr/java/packages/lib/ext;./mylib -jar  my-app.jar</code></li>
</ol>
<p>这样一来，最终回归到 Dockerfile，是长这样的：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./target/my-app.jar ./app/app.jar</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> ./app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> unzip app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"-Djava.ext.dirs=<span class="variable">$JAVA_HOME</span>/jre/lib/ext:/usr/java/packages/lib/ext:./BOOT-INF/lib"</span>,  <span class="string">"-jar"</span>, <span class="string">"app.jar"</span>]</span></span><br></pre></td></tr></table></figure>
<p>当然，如果你想要删除某些没必要再被ExtClassLoader扫描的jar，那可以删除它，如：我要删除除了<code>common-lib-1.0.0.jar</code>以外的所有jar包，可以这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./target/my-app.jar ./app/app.jar</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> ./app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> unzip app.jar</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> ./BOOT-INF/lib</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ls | grep -v ^common-lib | xargs rm -rf</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> ./../../</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"java"</span>, <span class="string">"-Djava.ext.dirs=<span class="variable">$JAVA_HOME</span>/jre/lib/ext:/usr/java/packages/lib/ext:./BOOT-INF/lib"</span>,  <span class="string">"-jar"</span>, <span class="string">"app.jar"</span>]</span></span><br></pre></td></tr></table></figure>


<h2 id="方案二：解压后直接run-JarLauncher"><a href="#方案二：解压后直接run-JarLauncher" class="headerlink" title="方案二：解压后直接run JarLauncher"></a>方案二：解压后直接run JarLauncher</h2><p>我们换个思路：其实spring有自己的专属启动方式，那我们就了解一下，它打包出来的jar包 <code>my-app.jar</code> 到底内部有什么蹊跷：<br><img src="/images/20200805/2.png" alt=""></p>
<p>是的，spring 有自己的一套启动和类加载套路，它很通过 <code>org.springframework.boot.loader</code> 包下的 Launcher 和 ClassLoader 相关类，去很好地解决了依赖库依赖问题以及类查找问题。<br><img src="/images/20200805/3.png" alt=""></p>
<p>而它的 <code>JarLauncher.java</code> 内部代码片段如下：<br><img src="/images/20200805/4.png" alt=""><br><img src="/images/20200805/5.png" alt=""><br>背后是让自定义类加载器<code>LuanchedURLClassLoader</code> 去做类加载的。</p>
<p>可以看到，它是指定扫描 <code>BOOT-INF/lib</code> 里头的依赖库，所以，我们索性是可以将这个jar包解压，然后直接 用 java 指令 直接跑 <code>JarLauncher</code>， 从而启动 <code>my-app</code> 的入口<code>Application.java</code>，进而启动整个spring项目。</p>
<p>首先解压你gen好的Spring Boot项目可执行jar包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip your-app.jar</span><br></pre></td></tr></table></figure>
<p>然后，能直接看到当前目录多了三个目录，分别是：</p>
<ul>
<li>BOOT-INF</li>
<li>META-INF</li>
<li>org</li>
</ul>
<p>接着，直接运行 <code>JarLauncher</code> 即可启动项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>

<p>最终，dockerfile这么写：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-alpineCOPY ./target/BCCD_EXCEPTION_HANDLER.jar ./app/app.jarWORKDIR ./appRUN unzip app.jarEXPOSE <span class="number">8080</span>CMD [<span class="string">"java"</span>, <span class="string">"org.springframework.boot.loader.JarLauncher"</span>]</span><br></pre></td></tr></table></figure>


<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>看看 <code>OwnClassUtil</code> 在扫描类和包的时候，使用的类加载器 以及 扫描得到所有类名：</p>
<p>其中，运行jar包 和 直接IDE运行，得到的 类加载器是：<br><img src="/images/20200805/6.png" alt=""><br>都是 <code>TomcatEmbeddedWebappClassLoader</code> 其parent 是 <code>LaunchedURLClassLoader</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TomcatEmbeddedWebappClassLoader</span><br><span class="line">  context: ROOT</span><br><span class="line">  delegate: true</span><br><span class="line">----------&gt; Parent Classloader:</span><br><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader@ad9418</span><br></pre></td></tr></table></figure>

<p>但是，在jar包情况下，得到的classList如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[BOOT-INF.classes.com.example.myapp.entity.Teacher, .......]</span><br></pre></td></tr></table></figure>

<p>而直接IDE运行，得到的classList如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[com.example.myapp.entity.Teacher, ......., com.example.common.po.Customer, ........]</span><br></pre></td></tr></table></figure>
<p>可以看出，在jar包情况下运行，由于jar包环境没有了目录相关的概念，spring 的<code>LaunchedURLClassLoader</code> 并没有能力很好地走正常 扫描resource 类和jar包资源的logic，拿到的都是 <code>BOOT-INF.classes</code> 中的东西，并不能摸到 <code>BOOT-INF.lib</code> 中的jar包资源；而在IDE运行或解压运行的情况下，<code>JarLauncher</code> 则能够很好地扫描目录结构，因为文件结构是现成可见的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>通过利用ClassLoader的装载特性，可以帮助扫描装载你想要的jar；</li>
<li>spring-maven 插件打的jar包在 通过 <code>java -jar</code> 运行时，在类的可见性方面会有所限制，虽然背后的类加载器都是自定义Spring自家的<code>LaunchedURLClassLoader</code>，但由于jar包的目录概念弱化，正常的 <code>getResource</code> 仅能触及 <code>BOOT-INF/classes</code>即当前project本身的code；</li>
<li>通过解压 jar包，并运行 JarLauncher 类，能够打破类可见性方面的限制，文件系统再现，导致目录概念重回正轨，使得第三方类库中的类能够被当前类加载器通过<code>getResource</code> 扫描到；</li>
<li>Spring 可执行jar包的启动是通过JarLauncher配合自定义URLClassLoader  <code>LaunchedURLClassLoader</code> 进行类加载和初始化的。一般情况下，如果我们不去定制 contextClassLoader，那么所有的线程将会默认使用 AppClassLoader，所有的类都将会是共享的， 但是在Spring 项目中，是用的自定义类加载器，所以线程上下文类加载器并非默认的AppClassLoader。</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>String有最大长度吗？</title>
    <url>/String%E6%9C%89%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>这个问题，平时没想过，谁没事干往一个String头上放几个G的data嘛，但是一旦遇到，就问你怎么解决~！</p>
</blockquote>
<a id="more"></a>

<h1 id="Java-String有最大长度吗？"><a href="#Java-String有最大长度吗？" class="headerlink" title="Java String有最大长度吗？"></a>Java String有最大长度吗？</h1><h2 id="String内部结构分析"><a href="#String内部结构分析" class="headerlink" title="String内部结构分析"></a>String内部结构分析</h2><p><img src="/images/20200301/1.png" alt=""></p>
<p>看看接口<code>CharSequence</code>:</p>
<p><img src="/images/20200301/2.png" alt=""></p>
<p>打开<code>java.lang.String</code>源码，可以发现：</p>
<ol>
<li>有哪些字段： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 存储字符的容器</span><br><span class="line">private final char value[];</span><br><span class="line"></span><br><span class="line">// 缓存字符串的hashCode</span><br><span class="line">private int hash; // Default to 0</span><br><span class="line"></span><br><span class="line">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span><br><span class="line">private static final long serialVersionUID = -6849794470754667710L;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Class String is special cased within the Serialization Stream Protocol.</span><br><span class="line"> *</span><br><span class="line"> * A String instance is written into an ObjectOutputStream according to</span><br><span class="line"> * &lt;a href=&quot;&#123;@docRoot&#125;/../platform/serialization/spec/output.html&quot;&gt;</span><br><span class="line"> * Object Serialization Specification, Section 6.2, &quot;Stream Elements&quot;&lt;/a&gt;</span><br><span class="line"> */</span><br><span class="line">private static final ObjectStreamField[] serialPersistentFields =</span><br><span class="line">    new ObjectStreamField[0];</span><br></pre></td></tr></table></figure></li>
<li>哪些相关构造器： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将传入的字符数组，从 value[offset]到 value[offset+count] 这一段复制出来构造一个新的字符数组</span><br><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">    if (offset &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt;= 0) &#123;</span><br><span class="line">        if (count &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        if (offset &lt;= value.length) &#123;</span><br><span class="line">            this.value = &quot;&quot;.value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">    if (offset &gt; value.length - count) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从一个Unicode码数组上面copy一部分创建一个新的字符数组</span><br><span class="line"> * @since  1.5</span><br><span class="line"> */</span><br><span class="line">public String(int[] codePoints, int offset, int count) &#123;</span><br><span class="line">    if (offset &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt;= 0) &#123;</span><br><span class="line">        if (count &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        if (offset &lt;= codePoints.length) &#123;</span><br><span class="line">            this.value = &quot;&quot;.value;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">    if (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int end = offset + count;</span><br><span class="line"></span><br><span class="line">    // Pass 1: Compute precise size of char[]</span><br><span class="line">    int n = count;</span><br><span class="line">    for (int i = offset; i &lt; end; i++) &#123;</span><br><span class="line">        int c = codePoints[i];</span><br><span class="line">        if (Character.isBmpCodePoint(c))</span><br><span class="line">            continue;</span><br><span class="line">        else if (Character.isValidCodePoint(c))</span><br><span class="line">            n++;</span><br><span class="line">        else throw new IllegalArgumentException(Integer.toString(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Pass 2: Allocate and fill in char[]</span><br><span class="line">    final char[] v = new char[n];</span><br><span class="line"></span><br><span class="line">    for (int i = offset, j = 0; i &lt; end; i++, j++) &#123;</span><br><span class="line">        int c = codePoints[i];</span><br><span class="line">        if (Character.isBmpCodePoint(c))</span><br><span class="line">            v[j] = (char)c;</span><br><span class="line">        else</span><br><span class="line">            Character.toSurrogates(c, v, j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>String.copyValueOf()方法： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String copyValueOf(char data[], int offset, int count) &#123;</span><br><span class="line">    return new String(data, offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>从以上源码种种迹象</p>
<ul>
<li><code>length()</code>返回的是int类型；</li>
<li>构造器传入的<code>count</code>也是int类型；</li>
</ul>
<p>，都可以断定，String的长度不会超过<code>int</code>的最大值，换言之，<code>char value[]</code> 中最多可以保存<code>Integer.MAX_VALUE</code>个，即2147483647字符。</p>
<p>但事情是不是这样的呢？</p>
<p>我们需要分编译期和运行期来看：</p>
<h2 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h2><p>编译期，也就是从源码角度表面上看，我取一个<code>Integer.MAX_VALUE</code>长度的字符串，理论上没问题，因为我没有突破你 int 的最大长度。</p>
<p>但是，实验证明，<code>String s = &quot;&quot;;</code>中，最多可以有65534个字符。如果超过这个个数。就会在编译期报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 共65534个a，正常编译</span><br><span class="line">    String s = &quot;a...a&quot;;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line"></span><br><span class="line">    // 共65535个a，编译报错：错误: 常量字符串过长</span><br><span class="line">    String s1 = &quot;a...a&quot;;</span><br><span class="line">    System.out.println(s1.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>明明说好的长度限制是2147483647，为什么65535个字符就无法编译了呢？</strong></p>
<p>当我们使用字符串字面量直接定义String的时候，是会把字符串在常量池中存储一份的。那么上面提到的65534其实是常量池的限制。<br>常量池中的每一种数据项也有自己的类型。Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示。<br>CONSTANTUtf8info是一个CONSTANTUtf8类型的常量池数据项，它存储的是一个常量字符串。常量池中的所有字面量几乎都是通过CONSTANTUtf8info描述的。CONSTANTUtf8_info的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 length;</span><br><span class="line">    u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于本文的重点并不是CONSTANTUtf8info的介绍，这里就不详细展开了，我们只需要我们使用<strong>字面量</strong>定义的字符串在class文件中，是使用CONSTANTUtf8info存储的，而CONSTANTUtf8info中有u2 length;表明了该类型存储数据的长度。<br>u2是无符号的16位整数，因此理论上允许的的最大长度是2^16=65536。而 java class 文件是使用一种变体UTF-8格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。<br>关于这一点，在the class file format spec中也有明确说明：</p>
<blockquote>
<p>The length of field and method names, field and method descriptors, and other constant string values is limited to 65535 characters by the 16-bit unsigned length item of the CONSTANTUtf8info structure (§4.4.7). Note that the limit is on the number of bytes in the encoding and not on the number of encoded characters. UTF-8 encodes some characters using two or three bytes. Thus, strings incorporating multibyte characters are further constrained.</p>
</blockquote>
<p>也就是说，在Java中，所有需要保存在常量池中的数据，长度最大不能超过65535，这当然也包括字符串的定义咯。</p>
<h2 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h2><p>上面提到的这种String长度的限制是编译期的限制，也就是使用String s= “”;这种字面值方式定义的时候才会有的限制。<br>那么。String在运行期有没有限制呢，答案是有的，就是我们前文提到的那个Integer.MAX_VALUE ，这个值约等于4G，在运行期，如果String的长度超过这个范围，就可能会抛出异常。(在jdk 1.9之前）<br>int 是一个 32 位变量类型，取正数部分来算的话，他们最长可以有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2^31-1 =2147483647 个 16-bit Unicodecharacter</span><br><span class="line"></span><br><span class="line">2147483647 * 16 = 34359738352 位</span><br><span class="line">34359738352 / 8 = 4294967294 (Byte)</span><br><span class="line">4294967294 / 1024 = 4194303.998046875 (KB)</span><br><span class="line">4194303.998046875 / 1024 = 4095.9999980926513671875 (MB)</span><br><span class="line">4095.9999980926513671875 / 1024 = 3.99999999813735485076904296875 (GB)</span><br></pre></td></tr></table></figure>
<p>有近 4G 的容量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当我们在写代码时使用字面量形式去定义String对象，那么，对象最大长度是：65534（因为它需要被编译进常量池的StringTable当中，JVM编译时对在StringTable中生成的String对象会以CONSTANT_Utf8类型表示，而这个类型有个长度属性是无符号16位整数，而由于一些字符已经占用一些，所以最终剩下：65534个字节）；</li>
<li>当我们在运行时接受或动态构造一个String对象，那么，对象最大长度可达：Integer.MAX_VALUE个,即2147483647字符。</li>
</ul>
<h1 id="重温Java基本类型"><a href="#重温Java基本类型" class="headerlink" title="重温Java基本类型"></a>重温Java基本类型</h1><table>
<thead>
<tr>
<th>基本类型–numeric</th>
<th>占用字节数/byte</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td><code>[-128, 127]</code></td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td><code>[-32768,32767]</code> 或 <code>$[-2^{15}, 2^{15}-1]$</code></td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td><code>[0x80000000, 0x7fffffff]</code> 或 <code>$[-2^{31}, 2^{31}-1]$</code></td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td><code>[0x8000000000000000L, 0x7fffffffffffffffL]</code> 或 <code>$[-2^{63}, 2^{63}-1]$</code></td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td><code>[&#39;\u0000&#39;, &#39;\uFFFF&#39;]</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>基本类型–floating-point</th>
<th>占用字节数/byte</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4</td>
<td><code>[0x0.000002P-126f, 0x1.fffffeP+127f]</code> 或 <code>[1.4e-45f, 3.4028235e+38f]</code></td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td><code>[0x0.0000000000001P-1022, 0x1.fffffffffffffP+1023]</code> 或 <code>[4.9e-324,1.7976931348623157e+308]</code></td>
</tr>
</tbody></table>
<blockquote>
<p>注意，以上的所有基本类型，都有其对应的封装类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Number子类：</span><br><span class="line">    Integer</span><br><span class="line">    Short</span><br><span class="line">    Integer</span><br><span class="line">    Long</span><br><span class="line">    Float</span><br><span class="line">    Double</span><br><span class="line"></span><br><span class="line">Character</span><br></pre></td></tr></table></figure>
<p>发现，除了<code>Character</code>，其他都是继承<code>Number</code>。</p>
</blockquote>
<h1 id="扩展：Java数组也有最大长度吗？"><a href="#扩展：Java数组也有最大长度吗？" class="headerlink" title="扩展：Java数组也有最大长度吗？"></a>扩展：Java数组也有最大长度吗？</h1><p>看了String的源码也知道，其内部是一个<code>char[]</code>类型的字符数组，我们调用String的length()函数时，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s = &quot;hhh&quot;;</span><br><span class="line">s.length();</span><br></pre></td></tr></table></figure>
<p>发现实际其内部是调用了<code>char[].length</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">    .......</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        return value.length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而我们又知道字符串在编译期和运行期的不同，那么，可以得知，对于Java数组：</p>
<ol>
<li>一是规范隐含的限制。Java数组的length必须是非负的int，所以它的理论最大值就是java.lang.Integer.MAX_VALUE = 2^31-1 = 2147483647。</li>
<li>二是具体的实现带来的限制。这会使得实际的JVM不一定能支持上面说的理论上的最大length。<br>例如说如果有JVM使用uint32_t来记录对象大小的话，那可以允许的最大的数组长度（按元素的个数计算）就会是：<br>(uint32_t的最大值 - 数组对象的对象头大小) / 数组元素大小<br>于是对于元素类型不同的数组，实际能创建的数组的最大length也会不同。<br>JVM实现里可以有许多类似的例子会影响实际能创建的数组大小。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章带Go小白入门</title>
    <url>/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6Go%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>听说Go语言很火，什么大方向都能扯到他，什么区块链、大数据、大型高性能Web应用等，特地整理一波Go相关背景与基础知识，分享给大家。</p>
</blockquote>
<a id="more"></a>

<h1 id="Go简介"><a href="#Go简介" class="headerlink" title="Go简介"></a>Go简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>维基百科：Go，又称为Golang（Go Language）。Google开发的一种静态强类型、编译型、并发型、具有垃圾回收功能的类C编程语言。</li>
</ul>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul>
<li>诞生时间：2007年末。</li>
<li>开发者：Robert Griesemer, Rob Pike, Ken Thompson 设计Go并主持开发，后来加入了Ian Lance Taylor, Russ Cox等。(Pike听完C++0x的演讲，回到办公室，开始编译C++，编译过程中，Pike转身和Robert讨论语言问题，拉上Ken爷爷一起合计，群嘲C++的一些沙雕设计后，没等编译完成，三人一拍即合，搞了Go语言出来。GO语言之父Pike提到：GO语言是以C为原型，以C++为目标而设计的，希望C++程序员能以GO作为替代品。因为他觉得C++忒复杂了，要解救程序员于水火。)</li>
<li>开源时间：2009-19</li>
<li>刚开始的Go：在Linux及Mac OS X平台上进行了实现，后来追加了Windows系统下的实现。</li>
<li>Go 1.0 稳定版发布时间：2012</li>
</ul>
<h3 id="Go核心团队"><a href="#Go核心团队" class="headerlink" title="Go核心团队"></a>Go核心团队</h3><p>各个大牛：<br><img src="/images/20200225/go_da_niu.png" alt=""></p>
<p>核心设计师Pike和Ken都是出身自贝尔实验室，Ken之于Pike，亦师亦友，共同发明了UTF-8，还基情四射地结对编程过，感情好的穿一条裤子。</p>
<p>Pike是Unix先驱，贝尔实验室最早跟Ken、Dennis一起开发Unix的猛人，Plan9 OS的灵魂人物。大胡子Ken爷爷则是Unix之父，和Dennis一起发明了C语言，殿堂骨灰级程序员，早已是名满天下。</p>
<p>技术实力毋容置疑，不过这哥俩都是玩Kernel的，经历相同，理念相近，分歧会比较少，他们也都坦承C用得最多最熟，所以注定了GO的类C特性，不过这会不会导致GO设计上的思维火花不足，对OOP以及现代编程思想的支持不足，亦未可知。</p>
<h2 id="Go-的哲学"><a href="#Go-的哲学" class="headerlink" title="Go 的哲学"></a>Go 的哲学</h2><ul>
<li><strong>少即是多</strong>：Less Is More，大道至简；</li>
<li><strong>世界是并行的</strong>：世间万物是并行发生的；</li>
<li><strong>世界是物质组成的</strong>：微观世界由小的粒子组合成大的粒子；宏观世界由小的物体组合成大的物体；<ul>
<li>继承只能描述现实世界的一小部分，使用继承是不全面的；</li>
<li>Go的设计选择的是组合，这个和现实世界比较吻合的设计，表现力更强；</li>
</ul>
</li>
<li><strong>世界是标准化的</strong>：硬件是标准化的，软件也应如此，Go的接口是DUCK模型，接口是非侵入式的；</li>
<li><strong>正交性</strong>：Go的多个特性都是正交性的，正交性是保持事物稳定和简单的最好设计；</li>
<li><strong>二八定律</strong>：80%代码只使用20%特性，增加语言特性，并不能提升效率，反而会增加复杂性，提高犯错率，加重程序员心智负担；</li>
<li><strong>统一格式化</strong>：给你（我认为）最好的，而不是给你选择。就像iPhone一样，用户太笨了，他们根本不知道自己需要什么，就让帮主替你安排好一切吧。当然，因为规则不是大家定的，而已某一个人定的，那就难免有些主观，规则好坏，见仁见智。</li>
</ul>
<h2 id="特点与特性"><a href="#特点与特性" class="headerlink" title="特点与特性"></a>特点与特性</h2><ul>
<li>Go是基于Inferno操作系统所开发的；</li>
<li>Go每半年发布一个二级版本（即从a.x升级到a.y）；</li>
<li>原生并发，以东尼·霍尔的通信顺序进程（CSP）为基础的goroutine，适合现代多核机器；</li>
<li>语法简单清晰；</li>
<li>强编码规则；</li>
<li>开源；</li>
<li>高效的垃圾回收机制；</li>
<li>强大的标准库，对网络编程等的良好支持；</li>
<li>内存管理、数组安全、编译迅速；</li>
<li>语法接近C语言，但其内部运行机制又偏向Java；</li>
<li>CGO提供了GO调用C机制，扩展了GO的能力边界；</li>
<li>内嵌关联数组；</li>
<li>非侵入式的接口设计；</li>
</ul>
<h2 id="Go-vs-C-C"><a href="#Go-vs-C-C" class="headerlink" title="Go vs C/C++"></a>Go vs C/C++</h2><p><img src="/images/20200225/go_1.png" alt=""></p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>虽然Go号称兼备C++的运行效率和PHP的开发效率，但从benchmarks数据上看，Go的运行效率还不能真的干趴老大哥Java。<br><img src="/images/20200225/go_2.png" alt=""></p>
<p>当然，Go再加以优化，性能应会更强。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote>
<p>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</p>
</blockquote>
<ul>
<li>高性能分布式系统领域</li>
<li>游戏服务端</li>
</ul>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><p>IDE：JetBrains GoLand 2019.2.3</p>
<h2 id="Windows步骤"><a href="#Windows步骤" class="headerlink" title="Windows步骤"></a>Windows步骤</h2><ol>
<li>去<a href="https://golang.org" target="_blank" rel="noopener">官网</a>下载exe，双击安装（默认安装目录：<code>C:\Go</code>）</li>
<li>添加<code>c:\Go\bin</code>到环境变量Path 【其实这一步exe已经帮你做了】</li>
<li>输入命令进入验证 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Linux步骤-MacOS参考他们俩就好了"><a href="#Linux步骤-MacOS参考他们俩就好了" class="headerlink" title="Linux步骤 (MacOS参考他们俩就好了)"></a>Linux步骤 (MacOS参考他们俩就好了)</h2><ol>
<li>下载tar.gz包</li>
<li>解压（前提：保证你有root权限）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 解压到安装目录：/usr/local/go</span><br><span class="line">tar -C /usr/local go1.12.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li>设置环境变量 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOROOT = /usr/local/go</span><br><span class="line">export PATH = $PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>对所有用户有效：<code>/etc/profile</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure></li>
<li>对当前用户生效：<code>$HOME/.profile</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="Go特色"><a href="#Go特色" class="headerlink" title="Go特色"></a>Go特色</h1><h2 id="工作区目录结构"><a href="#工作区目录结构" class="headerlink" title="工作区目录结构"></a>工作区目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src // 引用的外部库</span><br><span class="line">pkg // 编译时，生成的对象文件</span><br><span class="line">bin // 编译后的程序</span><br></pre></td></tr></table></figure>

<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><ul>
<li>定义：Go的主要功能之一，简单易用的并行设计。</li>
<li>作用：让程序以异步的方式运行，类似JS的<code>async await</code>，为了解决一个函数导致主线程中断的问题。</li>
<li>原理：Goroutine 是类似线程的概念（并不是线程，类似于协程，一种轻量级线程）。线程属于系统层面，通常来说创建和销毁一个线程需要消耗较多资源且不易管理。又称为“并发”，一个Go程序可以运行超过数万个Goroutine，并且性能都是原生级别的，随时能够关闭。一个核心里可以有多个Goroutine，可通过<code>GOMAXPROCS</code>参数限制其占用系统线程的数目。</li>
<li>例子：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 透過 `go`，我們可以把這個函式同步執行，</span><br><span class="line">    // 如此一來這個函式就不會阻塞主程式的執行。</span><br><span class="line">    go loop()</span><br><span class="line">	// 執行另一個迴圈。</span><br><span class="line">	loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><ul>
<li>当前有两个Go编译器分支，分别为官方编译器gc和gccgo。官方编译器在初期使用C写成，后用Go重写。Gccgo是一个使用标准GCC作为后端的Go编译器。</li>
<li>官方编译器支持跨平台编译（但不支持CGO），允许将源码编译为可在目标系统、架构上执行的二进制文件。</li>
</ul>
<h1 id="环境相关：GOROOT-和-GOPATH"><a href="#环境相关：GOROOT-和-GOPATH" class="headerlink" title="环境相关：GOROOT 和 GOPATH"></a>环境相关：GOROOT 和 GOPATH</h1><ul>
<li><code>GOROOT</code>:  安装 go 的路径</li>
<li><code>GOPATH</code>:  是我们定义的自己的工作空间</li>
</ul>
<h3 id="手动配置GOROOT"><a href="#手动配置GOROOT" class="headerlink" title="手动配置GOROOT"></a>手动配置GOROOT</h3><p>如果是默认一路next，是会自动配置好<code>GOROOT</code>系统环境变量的。</p>
<ol>
<li>首先，在环境变量中添加<code>GOROOT</code>，值为 go 安装目录；</li>
<li>然后在环境变量 <code>PATH</code> 中添加 go 安装目录下的 <code>bin</code> 文件夹。</li>
</ol>
<h3 id="手动添加GOPATH"><a href="#手动添加GOPATH" class="headerlink" title="手动添加GOPATH"></a>手动添加GOPATH</h3><p>接着添加一个环境变量 <code>GOPATH</code>，值为你自己希望的工作目录：</p>
<p>配置完毕后，记得重启cmd工具，然后输入<code>go env</code>即可看到配置内容。</p>
<p><img src="https://s2.ax1x.com/2019/11/17/Mr1LDA.png" alt="Mr1LDA.png"></p>
<h1 id="如何运行-go文件"><a href="#如何运行-go文件" class="headerlink" title="如何运行.go文件"></a>如何运行.go文件</h1><p>Idea在create一个<code>new simple Application</code>时，会自动生成一个<code>main()</code>，然后，即可被Go编译器识别并运行。</p>
<p>给你一个hello world代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;Hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行方式一：</p>
<ol>
<li>run，直接运行 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go run helloWorld.go</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>运行方式二：</p>
<ol>
<li>build一下，得到二进制文件(<code>.exe</code>) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go build helloWorld.go</span><br></pre></td></tr></table></figure></li>
<li>然后，执行二进制文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helloWorld</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Go中的函数定义"><a href="#Go中的函数定义" class="headerlink" title="Go中的函数定义"></a>Go中的函数定义</h1><p>看到<code>fmt.Println(&quot;Hello world&quot;)</code>，我们会在想：为什么Go会用首字母大写去定义一个函数名？</p>
<p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</p>
<h1 id="Go-关键字一览"><a href="#Go-关键字一览" class="headerlink" title="Go 关键字一览"></a>Go 关键字一览</h1><p>25个关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break	default	func	interface	select</span><br><span class="line">case	defer	go	map	struct</span><br><span class="line">chan	else	goto	package	switch</span><br><span class="line">const	fallthrough	if	range	type</span><br><span class="line">continue	for	import	return	var</span><br></pre></td></tr></table></figure>
<p>36 个预定义标识符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">append	bool	byte	cap  	close	complex 	complex64	complex128	uint16</span><br><span class="line">copy	false	float32	float64	    imag	int	 int8	int16	uint32</span><br><span class="line">int32	int64	iota	len	make	new	nil	panic	uint64</span><br><span class="line">print	println	real	recover  	string	true	uint	uint8	uintptr</span><br></pre></td></tr></table></figure>


<h1 id="Go-数据类型-注意点"><a href="#Go-数据类型-注意点" class="headerlink" title="Go 数据类型 注意点"></a>Go 数据类型 注意点</h1><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</p>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uint8</td>
<td>无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td>int8</td>
<td>有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td>int16</td>
<td>有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td>int64</td>
<td>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>float32</td>
<td>IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td>float64</td>
<td>IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td>complex64</td>
<td>32 位实数和虚数</td>
</tr>
<tr>
<td>complex128</td>
<td>64 位实数和虚数</td>
</tr>
</tbody></table>
<h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>类似 uint8</td>
</tr>
<tr>
<td>rune</td>
<td>类似 int32</td>
</tr>
<tr>
<td>uint</td>
<td>32 或 64 位</td>
</tr>
<tr>
<td>int</td>
<td>与 uint 一样大小</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</p>
<h3 id="派生类型"><a href="#派生类型" class="headerlink" title="派生类型"></a>派生类型</h3><p>包括：</p>
<ul>
<li>(a) 指针类型（Pointer）</li>
<li>(b) 数组类型</li>
<li>(c) 结构化类型(struct)</li>
<li>(d) Channel 类型</li>
<li>(e) 函数类型</li>
<li>(f) 切片类型</li>
<li>(g) 接口类型（interface）</li>
<li>(h) Map 类型</li>
</ul>
<h1 id="Go-语言变量"><a href="#Go-语言变量" class="headerlink" title="Go 语言变量"></a>Go 语言变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>声明格式： <code>var identifier type</code></p>
<p>可以一次声明多个变量：<code>var identifier1,identifier2 type</code></p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var a string = &quot;xxxx&quot;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    var b,c int = 1,2</span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一种：指定变量类型，如果没有初始化，则变量默认为零值。"><a href="#第一种：指定变量类型，如果没有初始化，则变量默认为零值。" class="headerlink" title="第一种：指定变量类型，如果没有初始化，则变量默认为零值。"></a>第一种：指定变量类型，如果没有初始化，则变量默认为零值。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v_name v_type  // 声明，此时 v_name 为零值</span><br><span class="line">v_name = value     // 赋值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>零值：变量没有做初始化时系统默认设置的值。</p>
</blockquote>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明一个变量并初始化</span><br><span class="line">var a1 = &quot;Jay&quot;</span><br><span class="line">fmt.Println(a1) // Jay</span><br><span class="line"></span><br><span class="line">// 没有初始化就为零值</span><br><span class="line">var b1 int</span><br><span class="line">fmt.Println(b1) // 0</span><br><span class="line"></span><br><span class="line">// bool 零值为 false</span><br><span class="line">var c1 bool</span><br><span class="line">fmt.Println(c1) // false</span><br></pre></td></tr></table></figure>

<p><strong>零值分类</strong>：</p>
<ul>
<li>数值类型（包括complex64/128）为 0</li>
<li>布尔类型为 false</li>
<li>字符串为 “”（空字符串）</li>
<li>以下几种类型为 nil：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a *int</span><br><span class="line">var a []int</span><br><span class="line">var a map[string] int</span><br><span class="line">var a chan int</span><br><span class="line">var a func(string) int</span><br><span class="line">var a error // error 是接口</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i int     // 0</span><br><span class="line">    var f float64 // 0</span><br><span class="line">    var b bool    // false</span><br><span class="line">    var s string  // &quot;&quot;</span><br><span class="line">    fmt.Printf(&quot;%v %v %v %q\n&quot;, i, f, b, s) // 0 0 false &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种：根据值自动判定对象类型"><a href="#第二种：根据值自动判定对象类型" class="headerlink" title="第二种：根据值自动判定对象类型"></a>第二种：根据值自动判定对象类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isValid = true</span><br><span class="line">fmt.Println(isValid) // true</span><br></pre></td></tr></table></figure>

<h3 id="第三种："><a href="#第三种：" class="headerlink" title="第三种：:="></a>第三种：<code>:=</code></h3><p><code>isValid := true</code> 相当于 <code>var isValid bool = true</code>。 所以，一定要是新声明变量，才能用这个<code>:=</code></p>
<h3 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h3><h4 id="1-值类型"><a href="#1-值类型" class="headerlink" title="1. 值类型"></a>1. 值类型</h4><p>所有像 <code>int</code>、<code>float</code>、<code>bool</code> 和 <strong><code>string</code></strong> 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：<br><img src="https://s2.ax1x.com/2019/11/17/MrUsOO.png" alt="MrUsOO.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i = 7</span><br><span class="line">var j = i // 实际上是在内存中将 i 的值进行了拷贝</span><br><span class="line">fmt.Println(&amp;i, &amp;j) // 0xc0000580d8 0xc0000580e0</span><br><span class="line">// 发现两个变量指向的内存地址的位置不同</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/11/17/MrURkd.png" alt="MrURkd.png"></p>
<h4 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2. 引用类型"></a>2. 引用类型</h4><p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。<br><img src="https://s2.ax1x.com/2019/11/17/MralAH.png" alt="MralAH.png"><br>这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p>
<p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p>
<p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</p>
<p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p>
<h1 id="Go-常量"><a href="#Go-常量" class="headerlink" title="Go 常量"></a>Go 常量</h1><h3 id="一般玩法：const"><a href="#一般玩法：const" class="headerlink" title="一般玩法：const"></a>一般玩法：const</h3><p>常量定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const identifier [type] = value</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const LENGTH int = 10</span><br><span class="line">const WIDTH int = 5</span><br><span class="line">var area int</span><br><span class="line">const a, b, c = 1, false, &quot;str&quot; //多重赋值</span><br><span class="line"></span><br><span class="line">area = LENGTH * WIDTH</span><br><span class="line">fmt.Printf(&quot;面积为 : %d&quot;, area) // 面积为：50</span><br><span class="line">println()</span><br><span class="line">println(a, b, c) // 1 false str</span><br></pre></td></tr></table></figure>
<p>常量可以用<code>len()</code>, <code>cap()</code>, <code>unsafe.Sizeof()</code> 函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line">.........</span><br><span class="line">const (</span><br><span class="line">	a_1         = &quot;abc&quot;</span><br><span class="line">	a_len       = len(a_1)</span><br><span class="line">	a_type_size = unsafe.Sizeof(a_1)</span><br><span class="line">)</span><br><span class="line">println(a_1, a_len, a_type_size) // abc 3 16</span><br></pre></td></tr></table></figure>

<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota，特殊常量，可以认为是一个<strong>可以被编译器修改的常量</strong>。</p>
<p>iota 在 <code>const</code> 关键字出现时将被重置为 <code>0</code> (const 内部的第一行之前)，<code>const</code> 中每新增一行常量声明将使 iota 计数一次 (<u>iota 可理解为 const 语句块中的行索引</u>)。</p>
<p>iota 可以被用作枚举值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota // 0</span><br><span class="line">    b = iota // 1</span><br><span class="line">    c = iota // 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">    a = iota  // 0</span><br><span class="line">    b         // 1</span><br><span class="line">    c         // 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>iota用法例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const (</span><br><span class="line">	a = iota   //0</span><br><span class="line">	b          //1</span><br><span class="line">	c          //2</span><br><span class="line">	d = &quot;ha&quot;   //独立值，iota += 1</span><br><span class="line">	e          //&quot;ha&quot;   iota += 1</span><br><span class="line">	f = 100    //iota +=1</span><br><span class="line">	g          //100  iota +=1</span><br><span class="line">	h = iota   //7,恢复计数</span><br><span class="line">	i          //8</span><br><span class="line">)</span><br><span class="line">fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">// 0 1 2 ha ha 100 100 7 8</span><br></pre></td></tr></table></figure>
<p>有趣例子二–左移：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">const (</span><br><span class="line">    i=1&lt;&lt;iota // 1&lt;&lt;0 = 1</span><br><span class="line">    j=3&lt;&lt;iota // 3&lt;&lt;1 = 6</span><br><span class="line">    k         // 3&lt;&lt;2 = 12</span><br><span class="line">    l         // 3&lt;&lt;3 = 24</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;i=&quot;,i) // 1</span><br><span class="line">    fmt.Println(&quot;j=&quot;,j) // 6</span><br><span class="line">    fmt.Println(&quot;k=&quot;,k) // 12</span><br><span class="line">    fmt.Println(&quot;l=&quot;,l) // 24</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td><code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>&amp;^</code></td>
</tr>
<tr>
<td>4</td>
<td><code>+</code>, <code>-</code>, `</td>
</tr>
<tr>
<td>3</td>
<td><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
</tr>
<tr>
<td>2</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>1</td>
<td>`</td>
</tr>
</tbody></table>
<p>特别说明一下：</p>
<ul>
<li><code>&amp;</code>：返回变量存储地址（<code>&amp;a;</code> 将给出变量的实际地址）</li>
<li><code>*</code>：指针变量。（<code>*a;</code> 是一个指针变量）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x uint8 = 3</span><br><span class="line">var y uint8 = 2</span><br><span class="line">fmt.Println(x &gt;&gt; y)// 0</span><br><span class="line">xStr := &amp;x</span><br><span class="line">fmt.Println(xStr)  // 0xc00000a0b0</span><br><span class="line">fmt.Println(*xStr) // 3</span><br></pre></td></tr></table></figure>

<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h2><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var x interface&#123;&#125;</span><br><span class="line">     </span><br><span class="line">   switch i := x.(type) &#123;</span><br><span class="line">      case nil:   </span><br><span class="line">         fmt.Printf(&quot; x 的类型 :%T&quot;,i)                </span><br><span class="line">      case int:   </span><br><span class="line">         fmt.Printf(&quot;x 是 int 型&quot;)                       </span><br><span class="line">      case float64:</span><br><span class="line">         fmt.Printf(&quot;x 是 float64 型&quot;)           </span><br><span class="line">      case func(int) float64:</span><br><span class="line">         fmt.Printf(&quot;x 是 func(int) 型&quot;)                      </span><br><span class="line">      case bool, string:</span><br><span class="line">         fmt.Printf(&quot;x 是 bool 或 string 型&quot; )       </span><br><span class="line">      default:</span><br><span class="line">         fmt.Printf(&quot;未知型&quot;)     </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x 的类型 :&lt;nil&gt;</span><br></pre></td></tr></table></figure>
<h2 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h2><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	// 条件语句</span><br><span class="line">	a := 2</span><br><span class="line">	switch &#123;</span><br><span class="line">	case a == 1:</span><br><span class="line">		fmt.Println(&quot;1、case 条件语句为 false&quot;)</span><br><span class="line">		fallthrough</span><br><span class="line">	case a == 2:</span><br><span class="line">		fmt.Println(&quot;2、case 条件语句为 true&quot;)</span><br><span class="line">		fallthrough</span><br><span class="line">	case a == 3:</span><br><span class="line">		fmt.Println(&quot;3、case 条件语句为 false&quot;)</span><br><span class="line">		fallthrough</span><br><span class="line">	case a == 4:</span><br><span class="line">		fmt.Println(&quot;4、case 条件语句为 true&quot;)</span><br><span class="line">	case a == 5:</span><br><span class="line">		fmt.Println(&quot;5、case 条件语句为 false&quot;)</span><br><span class="line">		fallthrough</span><br><span class="line">	default:</span><br><span class="line">		fmt.Println(&quot;6、默认 case&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、case 条件语句为 true</span><br><span class="line">3、case 条件语句为 false</span><br><span class="line">4、case 条件语句为 true</span><br></pre></td></tr></table></figure>

<h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>例子：在变量 a 等于 15 的时候跳过本次循环并回到循环的开始语句 LOOP 处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var a int = 10</span><br><span class="line">LOOP:</span><br><span class="line">	for a &lt; 20 &#123;</span><br><span class="line">		if a == 15 &#123;</span><br><span class="line">			a += 1</span><br><span class="line">			goto LOOP</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(a)</span><br><span class="line">		a++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td></tr></table></figure>

<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var x uint8 = 3</span><br><span class="line">	var y uint8 = 2</span><br><span class="line">	fmt.Println(x &gt;&gt; y)// 0</span><br><span class="line">	// 获取x 的指针</span><br><span class="line">	xStr := &amp;x</span><br><span class="line">	fmt.Println(xStr)  // 打印指针的值（也就是x值的内存地址）： 0xc00000a0b0</span><br><span class="line">	fmt.Println(*xStr) // 3</span><br><span class="line"></span><br><span class="line">	var a int = 20</span><br><span class="line">	var ip *int</span><br><span class="line">	ip = &amp;a</span><br><span class="line">	println(&quot;a 值&quot;, a) // 20</span><br><span class="line">	println(&quot;a 变量地址&quot;, &amp;a) // a 变量地址 0xc000081f40</span><br><span class="line">	println(&quot;ip 变量的值&quot;, ip)// ip 变量的值 0xc000081f40</span><br><span class="line">	println(&quot;通过 （指针）*ip 返回值&quot;, *ip) // 通过 （指针）*ip 返回值 20</span><br><span class="line"></span><br><span class="line">	println(&quot;空指针&quot;)</span><br><span class="line">	var nilIp *int</span><br><span class="line">	println(&quot;默认指针为空，值为&quot;, nilIp) // 默认指针为空，值为 0x0</span><br><span class="line">	println(&quot;到底是不是空指针的判断：&quot;, &quot;if(nilIp == nil)&quot;, &quot;结果是&quot;, nilIp == nil) // true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	println(&quot;printInt:&quot;, printInt())</span><br><span class="line">	println(&quot;add(1,2):&quot;, add(1, 2))</span><br><span class="line">	s := &quot;hello world&quot;</span><br><span class="line">	println(&quot;s的长度:&quot;, len(s))</span><br><span class="line"></span><br><span class="line">	baseSalary := 8000.0</span><br><span class="line">	var rate float32 = 1.2</span><br><span class="line">	var res float64 = calculateFinalSalary(baseSalary, rate)</span><br><span class="line">	fmt.Printf(&quot;原来工资为%f,晋升后的工资为：%f\n&quot;, baseSalary, res)</span><br><span class="line"></span><br><span class="line">	x1 := &quot;Mike&quot;</span><br><span class="line">	x2 := &quot;David&quot;</span><br><span class="line">	res1, res2 := swap(x1, x2)</span><br><span class="line">	fmt.Printf(&quot;返回多个值的函数：原来是%s,%s, 交换位置后得到%s, %s\n&quot;, x1, x2, res1, res2)</span><br><span class="line"></span><br><span class="line">	println()</span><br><span class="line">	println()</span><br><span class="line"></span><br><span class="line">	println(&quot;看看Go语言 string是否是值传递的：&quot;)</span><br><span class="line">	mike :=&quot;Mike&quot;</span><br><span class="line">	playSwitch(mike)</span><br><span class="line">	changePlayer(mike, &quot;Louis&quot;)</span><br><span class="line">	playSwitch(mike)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func changePlayer(name string, newName string) &#123;</span><br><span class="line">	println(name, &quot;已经换人了，现在是&quot;, newName)</span><br><span class="line">	name = newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func playSwitch(player string) &#123;</span><br><span class="line">	println(player, &quot;playing the Switch ~&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func swap(x1 string, x2 string) (string, string) &#123;</span><br><span class="line">	return x2, x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calculateFinalSalary(base float64, promoteRate float32) float64 &#123;</span><br><span class="line">	return base * float64(promoteRate)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func add(a int, b int) int &#123;</span><br><span class="line">	return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printInt() int &#123;</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>Go中的String的确是值传递的；</li>
<li>Go的函数可以返回多个参数；</li>
<li>进行运算时，类型不一致需要显式进行类型转换；</li>
</ul>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>Go也有全局变量和局部变量的概念：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 全局变量</span><br><span class="line">var g string = &quot;ABC&quot;</span><br><span class="line">var x string = &quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 局部变量</span><br><span class="line">	var x string = &quot;sss&quot;</span><br><span class="line"></span><br><span class="line">	println(g, x) // ABC sss</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Go语言中的数组有一些特点：</p>
<ul>
<li>数组一旦初始化，那就是固定大小（和Java的 int[] 等一个道理）；</li>
<li>只有相同长度和类型的数组之间，才能直接进行赋值，否则，需要遍历元素来赋值；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">	//	声明数组</span><br><span class="line">	var balance [10] float32</span><br><span class="line">	balance[0] = 12</span><br><span class="line">	println(&quot;balance数组长度&quot;, len(balance)) // 10</span><br><span class="line">	println(&quot;balance数组cap&quot;, cap(balance))  // 10</span><br><span class="line">	println(&quot;balance数组指针&quot;, &amp;balance)     // 0xc00006beb0</span><br><span class="line"></span><br><span class="line">	var actors [10] string</span><br><span class="line">	actors[0] = &quot;XiaoMing&quot;</span><br><span class="line">	println(&quot;actors数组长度&quot;, len(actors))   // 10</span><br><span class="line">	println(&quot;actors数组cap&quot;, cap(actors))    // 10</span><br><span class="line">	println(&quot;actors数组指针&quot;, &amp;actors)       // 0xc00006bee8</span><br><span class="line"></span><br><span class="line">	// 初始化数组(括号里的参数个数不得大于 给定的数组长度)</span><br><span class="line">	// 报错：因为前面已经声明 balance 为长度是 10 的float32 数组了</span><br><span class="line">	// balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</span><br><span class="line">	var arr1 = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</span><br><span class="line">	println(len(arr1))                       // 5</span><br><span class="line">	// 赋值的数组形状一样，所以不会报错</span><br><span class="line">	// 这里可以不指定数组长度，默认按照括号中的元素个数来设置数组大小</span><br><span class="line">	arr1 = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</span><br><span class="line">	println(len(arr1))                       // 5</span><br><span class="line"></span><br><span class="line">	println(&quot;遍历数组（保留2位小数）：&quot;)</span><br><span class="line">	for i := 0; i &lt; len(arr1); i++ &#123;</span><br><span class="line">		fmt.Printf(&quot;%.2f,&quot;, arr1[i])         // 1000.00,2.00,3.40,7.00,50.00,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 结构体</span><br><span class="line">// Go 当中，数组可以存储同一类型的数据，但是，如果是结构体，我们可以给不同项存储不同数据类型</span><br><span class="line">// 相当于 Java 的类，一个类有一到多个属性，每个属性之间可以有不同的数据类型</span><br><span class="line">type Books struct &#123;</span><br><span class="line">	title   string</span><br><span class="line">	author  string</span><br><span class="line">	subject string</span><br><span class="line">	book_id int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//println(&quot;创建一个结构体Books：&quot;, Books&#123;&quot;Go 语言&quot;, &quot;www.xxx.com&quot;, &quot;Go 教程&quot;, 1232&#125;)</span><br><span class="line">	bookA := Books&#123;&quot;Go 语言&quot;, &quot;www.xxx.com&quot;, &quot;Go 教程&quot;, 1232&#125;</span><br><span class="line">	bookB := Books&#123;title: &quot;Python 语言&quot;, book_id: 4444&#125;</span><br><span class="line">	fmt.Printf(&quot;bookA %v\n&quot;, bookA) // bookA &#123;Go 语言 www.xxx.com Go 教程 1232&#125;</span><br><span class="line">	fmt.Printf(&quot;bookB %v\n&quot;, bookB) // bookB &#123;Python 语言   4444&#125;</span><br><span class="line"></span><br><span class="line">	println(&quot;结构体指针&quot;, &amp;bookA)   // 0xc00006bf18</span><br><span class="line">	println(&quot;结构体也能作为形参&quot;)</span><br><span class="line">	printBook(bookA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printBook(book Books) &#123;</span><br><span class="line">	//println(&quot;printBook&quot;, book.title, book.author)</span><br><span class="line">	fmt.Printf(&quot;%v\n&quot;, book)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="slice-实现Go动态数组"><a href="#slice-实现Go动态数组" class="headerlink" title="slice 实现Go动态数组"></a>slice 实现Go动态数组</h1><p>Go 语言切片是 对 数组 的抽象</p>
<p>因为：Go 数组 长度不可改变，在特定场景中，这样的不可变集合不适用。</p>
<p>于是：Go提供了 一种灵活、功能强悍的内置类型切片（“动态数组”）</p>
<p>声明格式： var id []type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	//var badArr1 [3]int = [3]int&#123;1, 2, 3&#125;</span><br><span class="line">	badArr := [...]int&#123;1, 2, 3&#125;</span><br><span class="line">	//  动态数组初始化方式一</span><br><span class="line">	//var goodArr1 []int  = make([]int, 3)</span><br><span class="line">	//  动态数组初始化方式二</span><br><span class="line">	//goodArr2 := make([]int, 3)</span><br><span class="line">	//  动态数组初始化方式三</span><br><span class="line">	goodArr := [] int&#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">	println(&quot;普通数组&quot;)</span><br><span class="line">	for i := 0; i &lt; len(badArr); i++ &#123;</span><br><span class="line">		print(badArr[i], &quot;,&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	println()</span><br><span class="line">	println(&quot;可变数组&quot;)</span><br><span class="line">	for i := 0; i &lt; len(goodArr); i++ &#123;</span><br><span class="line">		print(goodArr[i], &quot;,&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	println()</span><br><span class="line">	goodArr = append(goodArr, 4, 5, 6)</span><br><span class="line">	println(&quot;可变数组加了几个元素后&quot;)</span><br><span class="line">	printSlice(goodArr)</span><br><span class="line"></span><br><span class="line">	println()</span><br><span class="line">	println()</span><br><span class="line">	println(&quot;开始切片&quot;)</span><br><span class="line">	s := [] int&#123;1, 2, 3&#125;</span><br><span class="line">	println(&quot;这里有个切片s(len = cap = 3)：&quot;)</span><br><span class="line">	printSlice(s)</span><br><span class="line">	println(&quot;获取切片s后面两个元素：&quot;)</span><br><span class="line">	printSlice(s[1:])</span><br><span class="line">	println()</span><br><span class="line">	println(&quot;获取切片s后面两个元素初始化为另一个切片s1：&quot;)</span><br><span class="line">	s1 := s[1:]</span><br><span class="line">	printSlice(s1)</span><br><span class="line"></span><br><span class="line">	println()</span><br><span class="line">	println(&quot;-------------------------------------------------&quot;)</span><br><span class="line">	println(&quot;len() 和 cap()&quot;)</span><br><span class="line"></span><br><span class="line">	var nums = make([]int, 3,5)</span><br><span class="line">	printSlice(nums)</span><br><span class="line"></span><br><span class="line">	println()</span><br><span class="line">	println(&quot;-------------------------------------------------&quot;)</span><br><span class="line">	println(&quot;空切片（nil）&quot;)</span><br><span class="line"></span><br><span class="line">	var numbers []int</span><br><span class="line">	printSlice(numbers)</span><br><span class="line">	if numbers == nil &#123;</span><br><span class="line">		fmt.Printf(&quot;切片是空的&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	println()</span><br><span class="line">	println(&quot;-------------------------------------------------&quot;)</span><br><span class="line">	println(&quot;append() 和 copy() 函数&quot;)</span><br><span class="line">	append_and_copy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func append_and_copy() &#123;</span><br><span class="line">	var numbers []int</span><br><span class="line">	printSlice(numbers)</span><br><span class="line"></span><br><span class="line">	/* 允许追加空切片 */</span><br><span class="line">	numbers = append(numbers, 0)</span><br><span class="line">	printSlice(numbers)</span><br><span class="line"></span><br><span class="line">	/* 向切片添加一个元素 */</span><br><span class="line">	numbers = append(numbers, 1)</span><br><span class="line">	printSlice(numbers)</span><br><span class="line"></span><br><span class="line">	/* 同时添加多个元素 */</span><br><span class="line">	numbers = append(numbers, 2,3,4)</span><br><span class="line">	printSlice(numbers)</span><br><span class="line"></span><br><span class="line">	/* 创建切片 numbers1 是之前切片的两倍容量*/</span><br><span class="line">	numbers1 := make([]int, len(numbers), (cap(numbers))*2)</span><br><span class="line"></span><br><span class="line">	/* 拷贝 numbers 的内容到 numbers1 */</span><br><span class="line">	copy(numbers1,numbers)</span><br><span class="line">	printSlice(numbers1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSlice(x []int) &#123;</span><br><span class="line">	//for i := 0; i &lt; len(goodArr); i++ &#123;</span><br><span class="line">	//	print(goodArr[i], &quot;,&quot;)</span><br><span class="line">	//&#125;</span><br><span class="line">	fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;,len(x),cap(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通数组</span><br><span class="line">1,2,3,</span><br><span class="line">可变数组</span><br><span class="line">1,2,3,</span><br><span class="line">可变数组加了几个元素后</span><br><span class="line">len=6 cap=6 slice=[1 2 3 4 5 6]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开始切片</span><br><span class="line">这里有个切片s(len = cap = 3)：</span><br><span class="line">len=3 cap=3 slice=[1 2 3]</span><br><span class="line">获取切片s后面两个元素：</span><br><span class="line">len=2 cap=2 slice=[2 3]</span><br><span class="line"></span><br><span class="line">获取切片s后面两个元素初始化为另一个切片s1：</span><br><span class="line">len=2 cap=2 slice=[2 3]</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">len() 和 cap()</span><br><span class="line">len=3 cap=5 slice=[0 0 0]</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">空切片（nil）</span><br><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">切片是空的</span><br><span class="line">-------------------------------------------------</span><br><span class="line">append() 和 copy() 函数</span><br><span class="line">len=0 cap=0 slice=[]</span><br><span class="line">len=1 cap=1 slice=[0]</span><br><span class="line">len=2 cap=2 slice=[0 1]</span><br><span class="line">len=5 cap=6 slice=[0 1 2 3 4]</span><br><span class="line">len=5 cap=12 slice=[0 1 2 3 4]</span><br></pre></td></tr></table></figure>
<h1 id="range"><a href="#range" class="headerlink" title="range"></a>range</h1><p>range 关键字：用于for 循环中 迭代数组array、切片slice、通道channel、集合map 的元素</p>
<ul>
<li>数组和切片中，返回元素的索引和索引对应的值</li>
<li>集合中，返回key-value对<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	nums := []int&#123;2, 3, 4&#125;</span><br><span class="line">	sum := 0</span><br><span class="line">	// 当我们不想要这个index时，可以用&quot;_&quot;代替</span><br><span class="line">	for _, num := range nums &#123;</span><br><span class="line">		sum += num</span><br><span class="line">	&#125;</span><br><span class="line">	println(&quot;sum&quot;, sum) // 9</span><br><span class="line">	for i, num := range nums &#123;</span><br><span class="line">		println(&quot;遍历过程中：索引&quot;, i, &quot;值&quot;, num)</span><br><span class="line">	&#125;</span><br><span class="line">	// 遍历过程中：索引 0 值 2</span><br><span class="line">    // 遍历过程中：索引 1 值 3</span><br><span class="line">    // 遍历过程中：索引 2 值 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// for map</span><br><span class="line">	kvs := map[string]int&#123;&quot;A&quot;: 18, &quot;B&quot;: 25&#125;</span><br><span class="line">	for k, v := range kvs &#123;</span><br><span class="line">		fmt.Printf(&quot;%s -&gt; %d\n&quot;, k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	// A -&gt; 18</span><br><span class="line">    // B -&gt; 25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// for 枚举 Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span><br><span class="line">	for i, c := range &quot;go&quot; &#123;</span><br><span class="line">		println(i, c)</span><br><span class="line">	&#125;</span><br><span class="line">	// 0 103</span><br><span class="line">    // 1 111</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1>集合</li>
<li>特点： 无序，默认为nil，内部使用hash表实现</li>
</ul>
<p>初始化格式：</p>
<ul>
<li>声明变量，默认 map 是 nil<blockquote>
<p><code>var map_variable map[key_data_type]value_data_type</code></p>
</blockquote>
</li>
<li>使用 make 函数<blockquote>
<p><code>map_variable := make(map[key_data_type]value_data_type)</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var countryCapitalMap map[string]string /*创建集合 */</span><br><span class="line">	countryCapitalMap = make(map[string]string)</span><br><span class="line"></span><br><span class="line">	/* map插入key - value对,各个国家对应的首都 */</span><br><span class="line">	countryCapitalMap [ &quot;France&quot; ] = &quot;巴黎&quot;</span><br><span class="line">	countryCapitalMap [ &quot;Italy&quot; ] = &quot;罗马&quot;</span><br><span class="line">	countryCapitalMap [ &quot;Japan&quot; ] = &quot;东京&quot;</span><br><span class="line">	countryCapitalMap [ &quot;India &quot; ] = &quot;新德里&quot;</span><br><span class="line"></span><br><span class="line">	/*使用键输出地图值 */</span><br><span class="line">	for country := range countryCapitalMap &#123;</span><br><span class="line">		fmt.Println(country, &quot;首都是&quot;, countryCapitalMap [country])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*查看元素在集合中是否存在 */</span><br><span class="line">	capital, ok := countryCapitalMap [ &quot;American&quot; ] /*如果确定是真实的,则存在,否则不存在 */</span><br><span class="line">	/*fmt.Println(capital) */</span><br><span class="line">	/*fmt.Println(ok) */</span><br><span class="line">	if (ok) &#123;</span><br><span class="line">		fmt.Println(&quot;American 的首都是&quot;, capital)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		fmt.Println(&quot;American 的首都不存在&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	println(&quot;-----------------------------------------&quot;)</span><br><span class="line">	println(&quot;delete() 函数&quot;)</span><br><span class="line">	println(&quot;-----------------------------------------&quot;)</span><br><span class="line"></span><br><span class="line">	/* 创建map */</span><br><span class="line">	countryCapitalMap2 := map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;原始地图&quot;)</span><br><span class="line"></span><br><span class="line">	/* 打印地图 */</span><br><span class="line">	for country := range countryCapitalMap2 &#123;</span><br><span class="line">		fmt.Println(country, &quot;首都是&quot;, countryCapitalMap2 [ country ])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*删除元素*/ delete(countryCapitalMap2, &quot;France&quot;)</span><br><span class="line">	fmt.Println(&quot;法国条目被删除&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;删除元素后地图&quot;)</span><br><span class="line"></span><br><span class="line">	/*打印地图*/</span><br><span class="line">	for country := range countryCapitalMap2 &#123;</span><br><span class="line">		fmt.Println(country, &quot;首都是&quot;, countryCapitalMap2 [ country ])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">type Phone interface &#123;</span><br><span class="line">	call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type NokiaPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 实现call() 方法</span><br><span class="line">func (nokiaPhone NokiaPhone) call() &#123;</span><br><span class="line">	println(&quot;I am Nokia&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现call() 方法</span><br><span class="line">func (iPhone IPhone) call() &#123;</span><br><span class="line">	println(&quot;I am iPhone&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var phone Phone</span><br><span class="line"></span><br><span class="line">	phone = new(NokiaPhone)</span><br><span class="line">	phone.call()</span><br><span class="line"></span><br><span class="line">	phone = new(IPhone)</span><br><span class="line">	phone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常处理（基础）"><a href="#异常处理（基础）" class="headerlink" title="异常处理（基础）"></a>异常处理（基础）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">Go 内置的 error类型 是一个接口类型，其定义如下：</span><br><span class="line">type error interface &#123;</span><br><span class="line">  Error() string</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 这是一个 利用了 error 接口的 方法</span><br><span class="line">func mySqrt(f float64) (float64, error) &#123;</span><br><span class="line">	if f &lt; 0 &#123;</span><br><span class="line">		return 0, errors.New(&quot;math: square root of negative number&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return math.Sqrt(f), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	println(&quot;基础用法&quot;)</span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	result, err := mySqrt(-1)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		fmt.Printf(&quot;报错了：%v\n&quot;, err)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		println(&quot;结果是：&quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------</span><br><span class="line">基础用法</span><br><span class="line">--------------------------</span><br><span class="line">报错了：math: square root of negative number</span><br></pre></td></tr></table></figure>

<h1 id="异常处理（自定义-error-接口）"><a href="#异常处理（自定义-error-接口）" class="headerlink" title="异常处理（自定义 error 接口）"></a>异常处理（自定义 error 接口）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 自定义一个DivideError 结构 （除法运算错误）</span><br><span class="line">type DivideError struct &#123;</span><br><span class="line">	dividee int</span><br><span class="line">	divider int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现 `error` 接口</span><br><span class="line">func (de *DivideError) Error() string &#123;</span><br><span class="line">	strFormat := `</span><br><span class="line">    Cannot proceed, the divider is zero.</span><br><span class="line">    dividee: %d</span><br><span class="line">    divider: 0</span><br><span class="line">`</span><br><span class="line">	return fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义 `int` 类型除法运算的函数</span><br><span class="line">func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;</span><br><span class="line">	if varDivider == 0 &#123;</span><br><span class="line">		dData := DivideError&#123;</span><br><span class="line">			dividee: varDividee,</span><br><span class="line">			divider: varDivider,</span><br><span class="line">		&#125;</span><br><span class="line">		errorMsg = dData.Error()</span><br><span class="line">		return</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return varDividee / varDivider, &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	// 正常情况</span><br><span class="line">	if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;</span><br><span class="line">		fmt.Println(&quot;100/10 = &quot;, result)</span><br><span class="line">	&#125;</span><br><span class="line">	// 当除数为零的时候会返回错误信息</span><br><span class="line">	if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;</span><br><span class="line">		fmt.Println(&quot;errorMsg is: &quot;, errorMsg)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100/10 =  10</span><br><span class="line">errorMsg is:</span><br><span class="line">    Cannot proceed, the divider is zero.</span><br><span class="line">    dividee: 100</span><br><span class="line">    divider: 0</span><br></pre></td></tr></table></figure>

<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>
<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>goroutine 语法格式： go 函数名( 参数列表 )</p>
<p>Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine，以一个不同的、新创建的 goroutine 来执行一个函数。<br>同一个程序中的所有 goroutine 共享同一个地址空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">func say(s string) &#123;</span><br><span class="line">	for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">		time.Sleep(100 * time.Millisecond)</span><br><span class="line">		println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	go say(&quot;world&quot;)</span><br><span class="line">	say(&quot;hello&quot;)</span><br><span class="line">	println(&quot;输出的 hello 和 world 是没有固定先后顺序。因为它们是两个 goroutine 在执行&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel 通道"></a>channel 通道</h1><p>通道（channel）</p>
<ul>
<li>作用：用于传递数据。可用于 两个goroutine 之间通过传递一个指定类型的值来同步运行和通信。</li>
<li>操作符：<code>&lt;-</code> 用于指定通道的方向、发送或接收。</li>
</ul>
<p>如果未指定方向，则是 双向通道</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">		   // 并把值赋给 v</span><br></pre></td></tr></table></figure>
<p>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ch := make(chan int)</span><br></pre></td></tr></table></figure>
<p>注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func sum(s []int, c chan int) &#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	for _, v := range s &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- sum // 把 sum 发送到通道 c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	println(&quot;例子：分段求和，最终相加&quot;)</span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	s := []int&#123;7, 2, 8, -9, 4, 0&#125;</span><br><span class="line"></span><br><span class="line">	c := make(chan int)</span><br><span class="line">	go sum(s[:len(s)/2], c)</span><br><span class="line">	go sum(s[len(s)/2:], c)</span><br><span class="line">	x, y := &lt;-c, &lt;-c // 从通道 c 中接收</span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y, x+y)</span><br><span class="line"></span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	println(&quot;通道缓冲区（通过 make 的第二个参数指定缓冲区大小）&quot;)</span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	/**</span><br><span class="line">	带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</span><br><span class="line"></span><br><span class="line">	不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</span><br><span class="line"></span><br><span class="line">	注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</span><br><span class="line">	*/</span><br><span class="line">	// 这里我们定义了一个可以存储整数类型的带缓冲通道</span><br><span class="line">	// 缓冲区大小为2</span><br><span class="line">	ch := make(chan int, 2)</span><br><span class="line"></span><br><span class="line">	// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span><br><span class="line">	// 而不用立刻需要去同步读取数据</span><br><span class="line">	ch &lt;- 1</span><br><span class="line">	ch &lt;- 2</span><br><span class="line"></span><br><span class="line">	// 获取这两个数据</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line"></span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	println(&quot;Go 遍历通道与关闭通道&quot;)</span><br><span class="line">	println(&quot;--------------------------&quot;)</span><br><span class="line">	/**</span><br><span class="line">	Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</span><br><span class="line">	  v, ok := &lt;-ch</span><br><span class="line">	如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</span><br><span class="line">	*/</span><br><span class="line">	channelA := make(chan int, 10)</span><br><span class="line">	go fibonacci(cap(channelA), channelA)</span><br><span class="line">	// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span><br><span class="line">	// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span><br><span class="line">	// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span><br><span class="line">	// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span><br><span class="line">	for i := range channelA &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func fibonacci(n int, c chan int) &#123;</span><br><span class="line">	x, y := 0, 1</span><br><span class="line">	// 一边计算，一边扔到 通道的缓冲区中</span><br><span class="line">	for i := 0; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x+y</span><br><span class="line">	&#125;</span><br><span class="line">	// 完了，通道没有生产者了，此时，就可以close通道了，close之后，通道不会再进数据，但是还是能够读取数据</span><br><span class="line">	close(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Go语言常用命令"><a href="#Go语言常用命令" class="headerlink" title="Go语言常用命令"></a>Go语言常用命令</h1><h2 id="go-get：一键获取代码、编译并安装"><a href="#go-get：一键获取代码、编译并安装" class="headerlink" title="go get：一键获取代码、编译并安装"></a>go get：一键获取代码、编译并安装</h2><p>go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。</p>
<p>这个命令可以动态获取远程代码包，目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。在使用 go get 命令前，需要安装与远程包匹配的代码管理工具，如 Git、SVN、HG 等，参数中需要提供一个包名。</p>
<p>这个命令在内部实际上分成了两步操作：</p>
<ol>
<li>第一步是下载源码包；</li>
<li>第二步是执行 <code>go install</code>。</li>
</ol>
<p>下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BitBucket (Mercurial Git)</span><br><span class="line">GitHub (Git)</span><br><span class="line">Google Code Project Hosting (Git, Mercurial, Subversion)</span><br><span class="line">Launchpad (Bazaar)</span><br></pre></td></tr></table></figure>
<p>所以为了 go get 命令能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的 PATH 中。其实 go get 支持自定义域名的功能。</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d 只下载不安装</span><br><span class="line">-f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用</span><br><span class="line">-fix 在获取源码之后先运行fix，然后再去做其他的事情</span><br><span class="line">-t 同时也下载需要为运行测试所需要的包</span><br><span class="line">-u 强制使用网络去更新包和它的依赖包</span><br><span class="line">-v 显示执行的命令</span><br><span class="line">-insecure 允许使用不安全的 HTTP 方式进行下载操作</span><br></pre></td></tr></table></figure>

<p>一般用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -v -u &lt;远程包：网站域名&gt;/&lt;作者&gt;/&lt;项目名&gt;</span><br></pre></td></tr></table></figure>

<h1 id="项目github"><a href="#项目github" class="headerlink" title="项目github"></a>项目github</h1><p><a href="https://github.com/androidjp/training-Go" target="_blank" rel="noopener">https://github.com/androidjp/training-Go</a></p>
<h1 id="相关学习链接"><a href="#相关学习链接" class="headerlink" title="相关学习链接"></a>相关学习链接</h1><ul>
<li><a href="https://studygolang.com/" target="_blank" rel="noopener">https://studygolang.com/</a></li>
<li><a href="http://c.biancheng.net/view/123.html" target="_blank" rel="noopener">http://c.biancheng.net/view/123.html</a></li>
<li><a href="http://c.biancheng.net/golang/syntax/" target="_blank" rel="noopener">http://c.biancheng.net/golang/syntax/</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的boolean占多少字节</title>
    <url>/Java%E4%B8%AD%E7%9A%84boolean%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82/</url>
    <content><![CDATA[<blockquote>
<p>引言：网上众说纷纭：1个字节；1位；4 byte……. 到底信哪个？ 这篇文章快速为你解答。</p>
</blockquote>
<a id="more"></a>

<h1 id="先回答你"><a href="#先回答你" class="headerlink" title="先回答你"></a>先回答你</h1><p>boolean 占 <strong>4 byte</strong>，相当于 int 的空间占用；</p>
<p>boolean[] 内每个元素 占 <strong>1 byte</strong>，相当于 byte 的空间占用；</p>
<p>Boolean 属于对象类型，其内部唯一的成员变量就是一个boolean值（其余都是静态变量），理论上类实例空间占用也是 <strong>4 byte</strong></p>
<h1 id="看看官方怎么说"><a href="#看看官方怎么说" class="headerlink" title="看看官方怎么说"></a>看看官方怎么说</h1><p>官方文档：</p>
<blockquote>
<p>boolean: The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its “size” isn’t something that’s precisely defined.</p>
</blockquote>
<p>上面的说的很清楚，boolean 值只有 true 和 false 两种，这个数据类型只代表 1 bit 的信息，但是它的“大小”没有严格的定义。也就是说，不管它占多大的空间，只有一个bit的信息是有意义的。</p>
<p>JVM规范上：</p>
<blockquote>
<p>Although the Java Virtual Machine defines a boolean type, it only provides very limited support for it. There are no Java Virtual Machine instructions solely dedicated to operations on boolean values. Instead, expressions in the Java programming language that operate on boolean values are compiled to use values of the Java Virtual Machine int data type.</p>
</blockquote>
<p>Java 虚拟机虽然定义了 boolean 类型，但是支持是有限的，没有专门的虚拟机指令。在 Java 语言中，对 boolean 值的操作被替换成 int 数据类型。</p>
<blockquote>
<p>The Java Virtual Machine does directly support boolean arrays. Its newarray instruction (§newarray) enables creation of boolean arrays. Arrays of type boolean are accessed and modified using the byte array instructions baload and bastore (§baload, §bastore).</p>
</blockquote>
<p>Java 虚拟机没有直接支持 boolean 数组。boolean 类型数组和 byte 数组公用指令。</p>
<blockquote>
<p>In Oracle’s Java Virtual Machine implementation, boolean arrays in the Java programming language are encoded as Java Virtual Machine byte arrays, using 8 bits per boolean element.</p>
</blockquote>
<p>在 Oracle 的 Java 虚拟机实现中，Java 语言中的 boolean 数组被编码成 Java 虚拟机的 byte 数组，每个元素占 8 比特。</p>
<blockquote>
<p>The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false . Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int , the compilers must use the same encoding.</p>
</blockquote>
<p>Java 虚拟机使用 1 表示 true，0 表示 false 来编码 boolean 数组。Java 语言的 boolean 值被编译器映射成 Java 虚拟机的 int 类型的时候，也是采用一样的编码。</p>
<p><strong>简单来说</strong>：</p>
<p>说占一个字节的人是这样认为的：计算机处理数据的最小单位是字节，一个字节等于8位，存储true和false的实际存储空间是：用1一个字节的最低位存储，其他位用0填补。虽然编译后的Boolean类型是0和1，但是依旧需要8位来进行存储，true的存储为：00000001；false的存储为：00000000。</p>
<p>认为占4个字节的理由是：在Java虚拟机中没有任何字节码指令供boolean值专用，Java中的boolean值，在编译后都使用Java虚拟机中的int类型来代替，而boolean数组会被编码成Java虚拟机中的byte数组，数组中的每个元素占8位（1字节），由此，可以得出boolean类型在单独使用时占4个字节，作为boolean数组存在的时候是一个字节。</p>
<p>之所以在虚拟机中将boolean类型使用int类型来代替的原因是CPU硬件来说的，转换成int对于32位的CPU来说，具有更高的存取效果。</p>
<h1 id="从源码角度分析"><a href="#从源码角度分析" class="headerlink" title="从源码角度分析"></a>从源码角度分析</h1><p>我们跑一下下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BoolAndBoolArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        boolean x = true;</span><br><span class="line">        boolean y;</span><br><span class="line">        boolean[] z = new boolean[4];</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            System.out.print(z[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译然后反编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac BoolAndBoolArray.java</span><br><span class="line">javap -v BoolAndBoolArray.class</span><br></pre></td></tr></table></figure>

<p>看到指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=5, args_size=1</span><br><span class="line">         0: iconst_1                         // 加载常量池中int值 1 --- 表示 true</span><br><span class="line">         1: istore_1                         // 将常量池中int值 1 存入 slot[1] 中 （这里的slot 指的是 存储本地变量的数组）</span><br><span class="line">         2: iconst_4                         // 加载常量池中int值 4</span><br><span class="line">         3: newarray       boolean           // 创建boolean[4]数组</span><br><span class="line">         5: astore_3                         // 将boolean[4]数组放入 slot[3]中</span><br><span class="line">         6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         9: iload_1                           // 打印 x 值，也就是 slot[1]的值</span><br><span class="line">        10: invokevirtual #3                  // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">        13: iconst_0                          // 加载常量池中的int值 0</span><br><span class="line">        14: istore        4                   // 将其放入 slot[4]</span><br><span class="line">        16: iload         4                   // 将 slot[4] 的值 又加载到 操作数栈</span><br><span class="line">        18: iconst_3                          // 加载常量池中int值 3 到 操作数栈</span><br><span class="line">        19: if_icmpge     38                  // 结束循环的标记：i值&gt;=3</span><br><span class="line">        22: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        25: aload_3                           // 将 boolean[4]数组 加载进操作数栈</span><br><span class="line">        26: iload         4                   // 将 i 载入操作数栈</span><br><span class="line">        28: baload                            // load出byte元素</span><br><span class="line">        29: invokevirtual #4                  // Method java/io/PrintStream.print:(Z)V</span><br><span class="line">        32: iinc          4, 1                // i++</span><br><span class="line">        35: goto          16</span><br><span class="line">        38: return</span><br></pre></td></tr></table></figure>

<p>由字节码指令就可以证明以上所述：</p>
<ol>
<li>JVM指令中没有一条说是 ‘加载boolean值’ 的指令，只有 <code>iload</code> 和 <code>baload</code> 分别表示 加载 int类型  以及 byte类型 的值；</li>
<li>JVM用 int 的 1 表示 true，0 表示 false；</li>
<li>JVM让 boolean型的变量操作，和 int型共用 一套指令集，在JVM眼里，boolean型也就是int型；</li>
<li>JVM让 boolean数组 中的元素操作 使用 byte相关指令，说明boolean数组中元素大小等同于 byte大小 — 1 byte；</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?subscene=23&__biz=Mzg2OTA4Mjg5NQ==&mid=2247483669&idx=1&sn=9555df728fc4ec6a7160a64469fe7466&chksm=cea33375f9d4ba632a08f57fc221af9a69f6112c9bf22db954acd443ec541c834453c196e8cc&scene=7&key=69038692c09c4f48bc5af16571e5da8d0c49523b88c24758ea6772e21dec12693fb8c2ab383ff369284827d4cc1b32ffd2241ad1d77837b11eaaf1d477636694c8dec517b1d0dd147a1cb84a47ec2a30&ascene=0&uin=MjU1MDY2OTI0Mw%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=A1DZSaSJy5alXMjHOOx%2B33o%3D&pass_ticket=H3eYA3Bz9co9X41uSLGzoACLUbwKFfkfHF3b0zU8m%2FxJ6K0hIwZN5UYqKKUYfymj" target="_blank" rel="noopener">Java中的boolean占多少个字节？</a></li>
<li><a href="https://mp.weixin.qq.com/s?subscene=23&__biz=MzIzMzgxOTQ5NA==&mid=2247490231&idx=2&sn=67fcbdd631d98cf5982a2d57ce2c2afd&chksm=e8fe86bedf890fa85144c478a35bbd302587ab13d843c29d953c170742973931e104241e23c2&scene=7&key=aa7656a594d1173368ca896d7826918aeddd65bd1fe537143622380fb6c6af942a50f2c28cf7254e8f6bb270adac956445bce36fda162d7fe00c6ae470bc73f1d5c0a499e817f1148da12ba07bbcdf87&ascene=0&uin=MjU1MDY2OTI0Mw%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=A4wSZoM4XsyS8RgPH%2BkTnyE%3D&pass_ticket=H3eYA3Bz9co9X41uSLGzoACLUbwKFfkfHF3b0zU8m%2FxJ6K0hIwZN5UYqKKUYfymj" target="_blank" rel="noopener">在Java中boolean类型占多少字节？大多数人都回答错了…</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>用Gradle从零搭建 Spring Cloud Greenwich.SR4  微服务项目（二）-- 配置中心</title>
    <url>/%E7%94%A8Gradle%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%20Spring%20Cloud%20Greenwich.SR4%20%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p>这篇，重点关注我们的配置中心，在各种场景下该如何运用，才会最妙！</p>
<a id="more"></a>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>怎么验证是否能够读取到git上面的配置呢？</p>
<blockquote>
<p>答：直接启动配置中心，然后，访问对应你想要访问的git上面的目录或文件，如：</p>
<ul>
<li><code>http://localhost:9010/micro-financial/manager</code></li>
<li><code>http://localhost:9010/micro-financial-manager/dev</code></li>
<li><code>http://localhost:9010/micro-financial-manager.yml</code></li>
</ul>
</blockquote>
<p>修改了git上面的配置，配置中心是如何收到更新通知的？</p>
<blockquote>
<p>答：同样，通过访问上述的几个API，此时，配置中心就会自动读取最新提交内容：</p>
<ul>
<li><code>http://localhost:9010/micro-financial/manager</code></li>
<li><code>http://localhost:9010/micro-financial-manager/dev</code></li>
<li><code>http://localhost:9010/micro-financial-manager.yml</code></li>
</ul>
</blockquote>
<p>仓库中的配置文件会被转换为web接口，访问参照以下规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>

<h2 id="相关配置参数"><a href="#相关配置参数" class="headerlink" title="相关配置参数"></a>相关配置参数</h2><table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spring.cloud.config.allow-override</td>
<td>true</td>
<td>外部源配置是否可被覆盖</td>
</tr>
<tr>
<td>spring.cloud.config.override-none</td>
<td>false</td>
<td>外部源配置是否不覆盖任何源</td>
</tr>
<tr>
<td>spring.cloud.config.override-system-properties</td>
<td>true</td>
<td>外部源配置是否可覆盖本地属性</td>
</tr>
</tbody></table>
<p>针对相应的属性的值对应的外部源在Environment对象中的读取优先级，罗列如下</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>读取优先级</th>
</tr>
</thead>
<tbody><tr>
<td>spring.cloud.config.allow-override=false</td>
<td>最高</td>
</tr>
<tr>
<td>spring.cloud.config.override-none=false&amp;&amp;spring.cloud.config.override-system-properties=true</td>
<td>最高(默认)</td>
</tr>
<tr>
<td>spring.cloud.config.override-none=true</td>
<td>最低</td>
</tr>
<tr>
<td>spring上下文无systemEnvironment属性</td>
<td>最低</td>
</tr>
<tr>
<td>spring上下文有systemEnvironment属性 &amp;&amp; spring.cloud.config.override-system-properties=false</td>
<td>在systemEnvironment之后</td>
</tr>
<tr>
<td>spring上下文有systemEnvironment属性 &amp;&amp; spring.cloud.config.override-system-properties=false</td>
<td>在systemEnvironment之前</td>
</tr>
</tbody></table>
<ul>
<li>即默认情况下，外部源的配置属性的读取优先级是最高的。</li>
<li>且除了<code>spring.cloud.config.override-none=true</code>的情况下，其他情况下外部源的读取优先级均比本地配置文件高。</li>
</ul>
<blockquote>
<p>Note:值得注意的是，如果用户想复写上述的属性，则放在<code>bootstrap.yml</code>|<code>application.yml</code>配置文件中是无效的，根据源码分析只能是自定义一个<code>PropertySourceLocator</code>接口实现类并放置在相应的<code>spring.factories</code>文件中方可生效。</p>
</blockquote>
<h2 id="自定义PropertySourceLocator接口"><a href="#自定义PropertySourceLocator接口" class="headerlink" title="自定义PropertySourceLocator接口"></a>自定义PropertySourceLocator接口</h2><p>目的：想要将部分的参数优先读本地配置</p>
<p>假设有这么一个场景，远程仓库的配置都是公有的，我们也不能修改它，我们只在项目中去复写相应的配置以达到兼容的目的。那么用户就需要自定义去编写接口了。</p>
<ol>
<li>编写PropertySourceLocator接口实现类 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description 自定义的PropertySourceLocator的顺序应该要比远程仓库读取方式要优先</span><br><span class="line"> * @see org.springframework.cloud.config.client.ConfigServicePropertySourceLocator</span><br><span class="line"> */</span><br><span class="line">@Order(value = Ordered.HIGHEST_PRECEDENCE + 1)</span><br><span class="line">public class CustomPropertySourceLocator implements PropertySourceLocator &#123;</span><br><span class="line"></span><br><span class="line">    private static final String OVERRIDE_ADD_MAPPING = &quot;spring.resources.add-mappings&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public PropertySource&lt;?&gt; locate(Environment environment) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; customMap = new HashMap&lt;&gt;(2);</span><br><span class="line">        // 远程仓库此配置为false，本地进行复写</span><br><span class="line">        customMap.put(OVERRIDE_ADD_MAPPING, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        return new MapPropertySource(&quot;custom&quot;, customMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写BootstrapConfiguration <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CustomBootstrapConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;customPropertySourceLocator&quot;)</span><br><span class="line">    public CustomPropertySourceLocator propertySourceLocator() &#123;</span><br><span class="line">        return new CustomPropertySourceLocator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在src\main\resources目录下创建META-INF\spring.factories文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Bootstrap components</span><br><span class="line">org.springframework.cloud.bootstrap.BootstrapConfiguration=\</span><br><span class="line">com.example.configdemo.propertysource.CustomBootstrapConfiguration</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="直接读取本地配置"><a href="#直接读取本地配置" class="headerlink" title="直接读取本地配置"></a>直接读取本地配置</h2><p>好，对于本地环境，或者默认环境，直接读取本地配置文件会是一个OK的选择：</p>
<p><code>basic-config</code>的<code>application-dev.yml</code>这么配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        native:</span><br><span class="line">          search-locations: classpath:/config</span><br></pre></td></tr></table></figure>
<p>然后，在<code>resources/config/application-dev.yml</code>作为给到别的微服务的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test: Mike</span><br></pre></td></tr></table></figure>
<p>最后，<code>micro-financial-manager</code>的<code>bootstrap.yml</code>这么配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: micro-financial-manager</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: basic-config</span><br><span class="line">      profile: $&#123;JP_CLOUD_CONFIG_PROFILE:dev&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置放在git仓库"><a href="#配置放在git仓库" class="headerlink" title="配置放在git仓库"></a>配置放在git仓库</h2><p>首先，新建github仓库，把你的配置扔上去：</p>
<p>github上面配置文件的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|_ qa</span><br><span class="line">  |_ micro-financial-manager.yml</span><br><span class="line">|_ prod</span><br></pre></td></tr></table></figure>
<p>其中，文件<code>micro-financial-manager.yml</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jpcloud:</span><br><span class="line">  test: Jay</span><br></pre></td></tr></table></figure>

<p>然后，<code>basic-config</code>的<code>application-qa-git.yml</code>这么配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: git@github.com:jpuneng/jp-cloud-gradle-config-repo.git</span><br><span class="line">          search-paths: qa</span><br><span class="line">      label: master</span><br></pre></td></tr></table></figure>
<p>这里的<code>uri</code>也可以使用HTTPs方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/jpuneng/jp-cloud-gradle-config-repo.git</span><br></pre></td></tr></table></figure>

<p>最后，<code>miro-financial-manager</code>的<code>boostrap.yml</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: micro-financial-manager  # 对应&#123;application&#125;部分</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      discovery:                   # 通过eureka发现配置中心</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: basic-config   # 指定配置中心的service-id，便于扩展为高可用配置集群。</span><br><span class="line">      label: master                # 对应git的分支。如果配置中心使用的是本地存储，则该参数无用</span><br><span class="line">      profile: dev                 # 对应&#123;profile&#125;部分</span><br><span class="line">      fail-fast: true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别注意：上面这些与spring-cloud相关的属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.properties。</p>
</blockquote>
<p>在微服务启动时，读取配置中心相关配置的过程涉及到三个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConfigServicePropertySourceLocator ---- 调用 locate() 方法，真的去请求获取远程配置</span><br><span class="line">ConfigClientHealthProperties ---------- 相关配置（如：时间间隔）</span><br><span class="line">PropertySourceBootstrapConfiguration -- 真的将远程配置更新到微服务自己的各个属性</span><br></pre></td></tr></table></figure>

<p>只要有注入<code>spring-cloud-starter-config</code>并且有配置这个<code>spring.cloud.config.discovery.enabled=true</code>，那么，就会默认每5分钟去config service上面读取配置。注意：是去配置中心上面拿配置，此时，配置中心回去看看git上面的配置的version对不对，有没有被修改过，并最终将version信息返回给到微服务。定时读取配置的相关类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConfigServerHealthIndicator ---------- Scheduler调用的方法入口</span><br><span class="line">ConfigClientHealthProperties --------- 相关配置（如：时间间隔）</span><br><span class="line">ConfigServicePropertySourceLocator --- 调用 locate() 方法，真的去请求获取远程配置</span><br></pre></td></tr></table></figure>
<p>如果要自定义定时获取配置的时间间隔，比如：我要10s获取一次配置，则在微服务的<code>bootstrap.yml</code>里头加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">health:</span><br><span class="line">  config:</span><br><span class="line">    time-to-live: 10000</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>但注意，虽然微服务已经读到了更新后的version，发现了配置已经是被更新了的，但是，此时并不会触发<code>PropertySourceBootstrapConfiguration.initialize()</code>方法，那么，就不会真正地去使用这个已更新的配置。</p>
<h2 id="其他服务想要的配置，都只能从我这里拿"><a href="#其他服务想要的配置，都只能从我这里拿" class="headerlink" title="其他服务想要的配置，都只能从我这里拿"></a>其他服务想要的配置，都只能从我这里拿</h2><p>我的其他微服务，例如：路由网关服务<code>basic-gateway</code>的一些routing配置，我是不是也可以配在我自己的git仓库当中呢？</p>
<p>其实可以！</p>
<ol>
<li>首选我们将原本在<code>basic-gateway/bootstrap.yml</code>中的配置，放到github 上面的<code>basic-gateway.yml</code>文件上： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: micro-financial-manager-route</span><br><span class="line">          uri: http://localhost:9200/</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/financial/**</span><br></pre></td></tr></table></figure></li>
<li>然后，将原来code里头的config删除；</li>
<li>接着，我们引入config相关依赖库； <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-config&apos;</span><br></pre></td></tr></table></figure></li>
<li>以及相关配置<code>bootstrap.yml</code>： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: basic-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: basic-config</span><br><span class="line">      label: master</span><br><span class="line">      fail-fast: true</span><br></pre></td></tr></table></figure></li>
<li>这样一来，就能读取到git上的routing配置了。</li>
</ol>
<h2 id="主动推送更新配置给到配置使用方"><a href="#主动推送更新配置给到配置使用方" class="headerlink" title="主动推送更新配置给到配置使用方"></a>主动推送更新配置给到配置使用方</h2><p>我的git中配置更新了，我又不想通过重启微服务的方式去拿这个更新后的值，怎么样才能动态、主动地将更新后的配置告诉给各大微服务爸爸呢？</p>
<h3 id="方式一：actuator-refresh刷新微服务配置"><a href="#方式一：actuator-refresh刷新微服务配置" class="headerlink" title="方式一：actuator/refresh刷新微服务配置"></a>方式一：actuator/refresh刷新微服务配置</h3><ul>
<li>原理：通过调用<code>/actuator/refresh</code>POST请求，让微服务主动去找配置中心刷新最新的配置；</li>
<li>缺点：配置更新了，但也无法主动通知到微服务，需要微服务自己handle；</li>
<li>优点：不需要重启微服务和配置中心；</li>
</ul>
<p>步骤：</p>
<ol>
<li>首先，如果没有配<code>actuator</code>相关依赖，需要配上，当然，eureka-client库,config库,甚至admin-client库里头本身依赖着<code>actuator</code>相关库，所以只要你有依赖这几个库的其中一个，都不需要单独引入<code>org.springframework.boot:spring-boot-starter-actuator</code>： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-config&apos;</span><br><span class="line">compile group: &apos;de.codecentric&apos;, name: &apos;spring-boot-admin-starter-client&apos;, version: &apos;2.1.6&apos;</span><br></pre></td></tr></table></figure></li>
<li>然后，<code>micro-financial-manager</code>的<code>application.yml</code>配置暴露refresh相关接口： <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">'*'</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">ALWAYS</span></span><br></pre></td></tr></table></figure></li>
<li>然后，我们给需要上去配置中心读取的配置，所在的类，头上，加上一个注解：<code>@RefreshScope</code>；</li>
<li>最后，我们主动帮<code>micro-financial-manager</code>调用<code>/actuactor/refresh</code>POST方法，即可刷新配置（因为这个方法会trigger <code>PropertySourceBootstrapConfiguration.initialize</code>方法）；</li>
<li>当然，我们也可以通过github 的 webhook，来监听每次git配置的push请求，然后自动请求我们这个<code>/actuator/refresh</code>方法。</li>
</ol>
<h3 id="方式二：集成event-bus，并调用actuator-bus-refresh刷新微服务配置"><a href="#方式二：集成event-bus，并调用actuator-bus-refresh刷新微服务配置" class="headerlink" title="方式二：集成event-bus，并调用actuator/bus-refresh刷新微服务配置"></a>方式二：集成event-bus，并调用actuator/bus-refresh刷新微服务配置</h3><p>这里应该需要配合 事件总线 来实现。</p>
<p>流程：<img src="https://i.loli.net/2019/12/10/nFxj32iRBtYgKpX.png" alt="UTOOLS1575938691182.png"></p>
<ul>
<li>缺点：比起方式一，更加繁琐，需要依赖<code>event-bus</code>和MQ服务的配合；</li>
<li>优点：能够通过通配符一键trigger所有的微服务更新配置，比起一个个调用，好一点；</li>
</ul>
<p>步骤：</p>
<ol>
<li>首先，保证你的MQ服务已经启动，例如这里我们选用rabbitMQ（<code>spring-cloud</code>默认支持RabbitMQ和Kafka两种event-bus集成方式）【详细搭建步骤可看另一篇文章】</li>
<li>然后，给你的微服务引入依赖： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-bus-amqp&apos;</span><br></pre></td></tr></table></figure>
 spring-cloud-starter-bus-amqp 内部依赖：spring-cloud-starter-stream-rabbit 和 spring-cloud-bus</li>
<li>配置<code>application.yml</code>： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.204.132</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br><span class="line">  cloud:</span><br><span class="line">    bus:</span><br><span class="line">      enabled: true</span><br><span class="line">      trace:</span><br><span class="line">        enabled: true</span><br></pre></td></tr></table></figure></li>
<li>最后，调用 POST <code>/actuator/bus-refresh?destination=customers:**</code>即刷新服务名为customers的所有服务。<blockquote>
<p>注意： 这个接口也可能是： <code>/bus/refresh</code></p>
</blockquote>
</li>
</ol>
<p>打开rabbitmq管理界面，看到它自己建了相关的queue，就是为了发一个更新的数据给到各个微服务：<br><img src="https://i.loli.net/2019/12/09/sfH6k1hyIiqv482.png" alt="UTOOLS1575899420222.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>具体看这篇文章：<a href="https://vitzhou.top/2018-02-spring-cloud-refresh-context/" target="_blank" rel="noopener">https://vitzhou.top/2018-02-spring-cloud-refresh-context/</a></p>
]]></content>
      <categories>
        <category>spring cloud</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>用Gradle从零搭建 Spring Cloud Greenwich.SR4  微服务项目（一）-- 基础入门</title>
    <url>/%E7%94%A8Gradle%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%20Spring%20Cloud%20Greenwich.SR4%20%20%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89--%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>引言：</p>
<ul>
<li><a href="https://spring.io/blog/2019/09/12/spring-cloud-greenwich-sr3-released" target="_blank" rel="noopener">Greenwich.SR3 Release Blog</a></li>
<li><a href="https://spring.io/blog/2019/11/19/spring-cloud-greenwich-sr4-released" target="_blank" rel="noopener">Greenwich.SR4 Release Blog</a></li>
</ul>
</blockquote><h1 id="总体框架"><a href="#总体框架" class="headerlink" title="总体框架"></a>总体框架</h1><ul>
<li>gradle版本：6.0.1</li>
<li>Spring Boot版本：2.1.10.RELEASE</li>
<li>Spring Cloud版本：Greenwich.SR4</li>
<li>服务注册与发现：Eureka</li>
<li>配置中心：Spring Cloud Config</li>
</ul><a id="more"></a>

<h1 id="相关规范"><a href="#相关规范" class="headerlink" title="相关规范"></a>相关规范</h1><p>端口：</p>
<ul>
<li>基础服务（<code>basic-xxx</code>）：90xx ~ 91xx<ul>
<li>注册服务器（<code>basic-registry</code>）：900x</li>
<li>配置服务器（<code>basic-config</code>）：901x</li>
<li>路由服务器（<code>basic-gateway</code>）：902x</li>
<li>其他基础服务器</li>
</ul>
</li>
<li>业务相关微服务: 92xx ~</li>
</ul>
<h1 id="一、搭建一个父Gradle目录-root-project"><a href="#一、搭建一个父Gradle目录-root-project" class="headerlink" title="一、搭建一个父Gradle目录(root project)"></a>一、搭建一个父Gradle目录(root project)</h1><h2 id="纯命令create"><a href="#纯命令create" class="headerlink" title="纯命令create"></a>纯命令create</h2><ol>
<li>新创建项目纯gradle项目 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir jp-cloud-gradle</span><br><span class="line">cd jp-cloud-gradle</span><br><span class="line">gradle init --type=basic</span><br></pre></td></tr></table></figure></li>
<li>假设你现在的系统全局Gradle版本是5.4.1，那么，如果要变成Gradle 6.0.1，两个选择：<ol>
<li>将当前系统Gradle换成6.0.1，然后执行运行<code>gradle wrapper</code>，即可将当前项目换成当前系统默认Gradle版本。然后执行<code>gradlew</code>即可用到当前6.0.1版本去进行项目构建；</li>
<li>直接用当前生成的5.4.1版本的Gradle命令，来切换版本至6.0.1：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gradlew wrapper --gradle-version=6.0.1</span><br><span class="line">gradlew</span><br><span class="line">// or gradlew tasks</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>更新root project的<code>build.gradle</code>，将Spring Cloud 和 Spring Boot相关基础依赖集成进来： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &apos;java&apos;</span><br><span class="line">group &apos;com.jpcloud&apos;</span><br><span class="line">version &apos;1.0.0&apos;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = 1.8</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        //定义一个变量，统一规定springboot的版本</span><br><span class="line">        // 注意：Spring Boot版本一定要匹配上 Spring Cloud 版本</span><br><span class="line">        // There should be a mismatch version between spring boot and spring cloud.</span><br><span class="line">        // If you use spring boot version 2.2.0.RELEASE you have to use spring cloud version Hoxton.RC1.</span><br><span class="line">        // If you use spring boot version 2.1.9.RELEASE, you have to use spring cloud version Greenwich.SR3.</span><br><span class="line">        // If you use spring boot version 2.1.10.RELEASE, you have to use spring cloud version Greenwich.SR4.</span><br><span class="line">        // 否则，会报错：No qualifying bean of type &apos;javax.servlet.Filter&apos; available</span><br><span class="line">        springBootVersion = &apos;2.1.10.RELEASE&apos;</span><br><span class="line">        springCloudVersion = &apos;Greenwich.SR4&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;//用来打包</span><br><span class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)</span><br><span class="line">        // 作用：设置依赖管理插件版本</span><br><span class="line">        classpath &quot;io.spring.gradle:dependency-management-plugin:1.0.2.RELEASE&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; &#125;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    // 指定编码格式</span><br><span class="line">    tasks.withType(JavaCompile) &#123;</span><br><span class="line">        options.encoding = &quot;UTF-8&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 作用：配置这个项目的子项目。这个方法对这个项目的每个子项目执行给定的闭包。目标项目作为闭包的委托传递给闭包</span><br><span class="line">subprojects &#123;</span><br><span class="line">    apply plugin: &apos;java&apos;</span><br><span class="line">    apply plugin: &apos;idea&apos;</span><br><span class="line">    // spring boot 插件</span><br><span class="line">    apply plugin: &apos;org.springframework.boot&apos;</span><br><span class="line">    // A Gradle plugin that provides Maven-like dependency management functionality</span><br><span class="line">    apply plugin: &apos;io.spring.dependency-management&apos;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        testCompile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-test&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencyManagement &#123;</span><br><span class="line">        imports &#123;</span><br><span class="line">            //spring bom helps us to declare dependencies without specifying version numbers.</span><br><span class="line">            mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jar &#123;</span><br><span class="line">        manifest.attributes provider: &apos;gradle&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>最终，使用的相关版本是：</p>
<ul>
<li>Spring Cloud: GreenWich SR4 (基于Spring Boot 2.1.10)</li>
<li>Spring Boot: 2.1.10</li>
</ul>
<h1 id="二、服务注册与发现"><a href="#二、服务注册与发现" class="headerlink" title="二、服务注册与发现"></a>二、服务注册与发现</h1><h2 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.cloud:spring-cloud-starter-netflix-eureka-server</span><br></pre></td></tr></table></figure>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>创建一个module <code>basic-registry</code>，纯命令操作如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir basic-registry</span><br><span class="line">cd basic-registry</span><br><span class="line">gradlew init</span><br></pre></td></tr></table></figure></li>
<li>配置<code>build.gradle</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-server&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置<code>application.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: basic-registry</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false # eureka服务是否向自己注册,默认true.这里我们不想自己注册</span><br><span class="line">    service-url:          # eureka的注册地址</span><br><span class="line">      defaultZone: http://$&#123;eureka.host:localhost&#125;:$&#123;eureka.port:9000&#125;/eureka/</span><br></pre></td></tr></table></figure></li>
<li>创建App入口 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class RegistryApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RegistryApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="三、配置中心"><a href="#三、配置中心" class="headerlink" title="三、配置中心"></a>三、配置中心</h1><h2 id="相关依赖-1"><a href="#相关依赖-1" class="headerlink" title="相关依赖"></a>相关依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-config-server&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>首先，创建module <code>basic-config</code></li>
<li>配置 <code>build.gradle</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-config-server&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置 <code>application.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9010</span><br></pre></td></tr></table></figure></li>
<li>配置 <code>bootstrap.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: basic-config</span><br><span class="line">  profiles:</span><br><span class="line">    active: native # 表示是用本地配置文件中读取配置</span><br><span class="line">  cloud:           # 配置是从哪里读取配置文件</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        native:</span><br><span class="line">          search-locations: classpath:/config</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    non-secure-port: $&#123;server.port&#125;</span><br><span class="line">    metadata-map:</span><br><span class="line">      instanceId: $&#123;server.port&#125;</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://$&#123;eureka.host:localhost&#125;:$&#123;eureka.port:9000&#125;/eureka/</span><br></pre></td></tr></table></figure></li>
<li>好，新建<code>recources/config/application-dev.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jpcloud:</span><br><span class="line">  mongodb:</span><br><span class="line">    uri: mongodb://localhost:27017/jpcloud</span><br><span class="line">  test: jjjjjp</span><br></pre></td></tr></table></figure></li>
<li>最后，创建入口 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当然这里，用 @EnableEurekaClient 也是OK的</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableConfigServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConfigApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="四、愉快地写业务代码"><a href="#四、愉快地写业务代码" class="headerlink" title="四、愉快地写业务代码"></a>四、愉快地写业务代码</h1><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><p>我们很愉快，想要新建一个专门计算每日花费的微服务，并尝试让其注册到我们的注册中心当中，且能够获取配置中心的配置。</p>
<ol>
<li>创建module <code>micro-financial-manager</code></li>
<li>配置<code>build.gradle</code>，让其能够往注册中心注册，并且可以读取配置 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">    compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-web&apos;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-config&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置<code>application.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9200</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &apos;*&apos;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure></li>
<li>配置<code>bootstrap.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: micro-financial-manager</span><br><span class="line">  cloud:      # 配置能够扫描配置服务并获取相关配置</span><br><span class="line">    config:</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: basic-config</span><br><span class="line">      profile: $&#123;JP_CLOUD_CONFIG_PROFILE:dev&#125;</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://$&#123;eureka.host:localhost&#125;:$&#123;eureka.port:9000&#125;/eureka/</span><br></pre></td></tr></table></figure></li>
<li>好，写入口 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class FinancialManagerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(FinancialManagerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后，写一个计算花费的API，并尝试去拿到配置中心里头的配置： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;financial/cost&quot;)</span><br><span class="line">public class CostController &#123;</span><br><span class="line">    @Value(&quot;$&#123;jpcloud.test&#125;&quot;)</span><br><span class="line">    private String testName;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public BigDecimal get() &#123;</span><br><span class="line">        System.out.println(testName);</span><br><span class="line">        return BigDecimal.valueOf(3000 * Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>OK，此时，依次启动：</p>
<ol>
<li>basic-registry</li>
<li>basic-config</li>
<li>micro-financial-manager</li>
</ol>
<p><img src="../images/spring_cloud/1.png" alt></p>
<p>然后，就能够在eureka中心<code>http://localhost:9000</code>中看到几个服务已经注册了：<br><img src="../images/spring_cloud/2.png" alt></p>
<p>并且，调用<code>http://localhost:9200/finanical/cost</code>，可以正常请求API：<br><img src="../images/spring_cloud/3.png" alt></p>
<h1 id="五、网关与负载均衡"><a href="#五、网关与负载均衡" class="headerlink" title="五、网关与负载均衡"></a>五、网关与负载均衡</h1><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>新建module <code>basic-gateway</code></li>
<li>配置<code>build.gradle</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-gateway&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置<code>application.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9020</span><br><span class="line"></span><br><span class="line"># actuator 服务状态检测相关API，全开放</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br></pre></td></tr></table></figure></li>
<li>配置 <code>bootstrap.yml</code>，这边可以配置yml方式的routing策略 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: basic-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: micro-financial-manager-route</span><br><span class="line">          uri: http://192.168.0.102:9200/</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/financial/**</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">    non-secure-port: $&#123;server.port&#125;</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://$&#123;eureka.host:localhost&#125;:$&#123;eureka.port:9000&#125;/eureka/</span><br></pre></td></tr></table></figure></li>
<li>最后，创建入口 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">//    以下是Java方式的Routing配置</span><br><span class="line">//    @Bean</span><br><span class="line">//    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) &#123;</span><br><span class="line">//        return builder.routes()</span><br><span class="line">//                .route(r -&gt; r.path(&quot;/financial&quot;).uri(&quot;https://localhost:9200&quot;))</span><br><span class="line">//                .build();</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后，我们启动gateway，端口为9020</li>
<li>就可以通过call <code>http://localhost:9020/financial/cost</code> API 路由到 我们的微服务上了<br><img src="../images/spring_cloud/4.png" alt></li>
</ol>
<h1 id="六、集成Admin"><a href="#六、集成Admin" class="headerlink" title="六、集成Admin"></a>六、集成Admin</h1><p>好，这时，已经有了4个服务在运行了：<br><img src="../images/spring_cloud/5.png" alt><br>然后，我们想给他一个更加好看的monitoring页面，怎么办呢？ </p>
<p>答案：再加多一个基础微服务<code>basic-admin</code>，来实时监控大家的运行状况吧。</p>
<h2 id="相关依赖-2"><a href="#相关依赖-2" class="headerlink" title="相关依赖"></a>相关依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">de.codecentric:spring-boot-admin-starter-server:2.1.6</span><br><span class="line">de.codecentric:spring-boot-admin-starter-client:2.1.6</span><br></pre></td></tr></table></figure>
<h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>创建gradle module，名为<code>basic-admin</code></li>
<li>给上配置<code>build.gradle</code>: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // enable admin服务端</span><br><span class="line">    compile group: &apos;de.codecentric&apos;, name: &apos;spring-boot-admin-starter-server&apos;, version: &apos;2.1.6&apos;</span><br><span class="line">    // 作为 eureka客户端，用于注册自己，并且从eureka服务器上面实时读取大家的状态</span><br><span class="line">    compile group: &apos;org.springframework.cloud&apos;, name: &apos;spring-cloud-starter-netflix-eureka-client&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>配置<code>application.yml</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9030</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: basic-admin</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registry-fetch-interval-seconds: 5</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: $&#123;EUREKA_SERVICE_URL:http://localhost:9000&#125;/eureka/</span><br><span class="line">  instance:</span><br><span class="line">    leaseRenewalIntervalInSeconds: 10</span><br><span class="line">    health-check-url-path: /actuator/health</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br></pre></td></tr></table></figure></li>
<li>入口 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableAdminServer</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class AdminApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(AdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>此时，启动admin服务；</li>
<li>打开<code>http://localhost:9300</code>，可以看到<code>admin</code>服务 和 <code>config</code>服务都是UP的状态；</li>
<li>此时，如果发现<code>gateway</code>和<code>micro-financial-manager</code>服务是DOWN状态，那么，需要给他们俩加上这个库： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;de.codecentric&apos;, name: &apos;spring-boot-admin-starter-client&apos;, version: &apos;2.1.6&apos;</span><br></pre></td></tr></table></figure></li>
<li>并且，给他们俩打开acturator 健康检查相关接口： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br></pre></td></tr></table></figure></li>
<li>然后，重启gateway 和 micro-financial-manager服务，即可。</li>
</ol>
<p><img src="../images/spring_cloud/6.png" alt></p>
<h2 id="给admin监控台加上登录页"><a href="#给admin监控台加上登录页" class="headerlink" title="给admin监控台加上登录页"></a>给admin监控台加上登录页</h2><p>因为安全登录相关的功能与页面被集成到了<code>security</code>库里头，所以，我们需要在admin服务中，做一些enhancement了：</p>
<ol>
<li>为<code>basic-admin/build.gradle</code>添加依赖库： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-web&apos;</span><br><span class="line">compile group: &apos;org.springframework.boot&apos;, name: &apos;spring-boot-starter-security&apos;</span><br></pre></td></tr></table></figure></li>
<li>修改<code>basic-admin/.../application.yml</code>，添加登录用户相关配置： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  #    登录页相关：配置spring security的用户名和密码</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: &quot;admin&quot;</span><br><span class="line">      password: &quot;admin&quot;</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    #    登录页相关：这时需要在服务注册时带上metadata-map的信息</span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: $&#123;spring.security.user.name&#125;</span><br><span class="line">      user.password: $&#123;spring.security.user.password&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后，添加一个<code>WebSecurityConfigurerAdapter</code>实现类，作为<code>basic-admin</code>服务的一个Configuration： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecuritySecureConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    private final String adminContextPath;</span><br><span class="line"></span><br><span class="line">    public SecuritySecureConfig(AdminServerProperties adminServerProperties) &#123;</span><br><span class="line">        this.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        // @formatter:off</span><br><span class="line">        SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">        successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()</span><br><span class="line">                .antMatchers(adminContextPath + &quot;/login&quot;).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and()</span><br><span class="line">                .logout().logoutUrl(adminContextPath + &quot;/logout&quot;).and()</span><br><span class="line">                .httpBasic().and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">        // @formatter:on</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启<code>basic-admin</code>服务，会发现，再次访问<code>localhost:9030</code>时，就会重定向到登录界面，登录的用户名和密码为配置文件中配置的，分别为admin和admin。</li>
</ol>
<p><img src="../images/spring_cloud/7.png" alt><br>大功告成！！</p>
<h1 id="七、集成Lombok"><a href="#七、集成Lombok" class="headerlink" title="七、集成Lombok"></a>七、集成Lombok</h1><p>如果我们直接去mvnrepository.com, 直接拿gradle 的Lombok的依赖方式放到我们的项目中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subprojects &#123;</span><br><span class="line">    // ...................</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // .......................</span><br><span class="line">        providedCompile group: &apos;org.projectlombok&apos;, name: &apos;lombok&apos;, version: &apos;1.18.2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">A problem occurred evaluating root project &apos;jp-cloud-gradle&apos;.</span><br><span class="line">&gt; Could not find method providedCompile() for arguments [&#123;group=org.projectlombok, name=lombok, version=1.18.2&#125;] on object of type org.gradle.api.internal.artifacts.dsl.dependencies.DefaultDependencyHandler.</span><br></pre></td></tr></table></figure>
<p>然后，编译失败。</p>
<p>这应该是由于enable Lombok的写法，对于我们这个Gradle版本搭建的project 来说有误。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-官方推荐方式"><a href="#1-官方推荐方式" class="headerlink" title="1. 官方推荐方式"></a>1. 官方推荐方式</h3><p><a href="https://docs.gradle.org/4.7-rc-1/userguide/java_plugin.html#sec:java_compile_avoidance" target="_blank" rel="noopener">官方文档</a> | <a href="https://stackoverflow.com/questions/50519138/annotationprocessor-gradle-4-7-configuration-doesnt-run-lombok" target="_blank" rel="noopener">stackoverflow: correct way</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">annotationProcessor &apos;org.projectlombok:lombok:1.18.2&apos;</span><br><span class="line">compileOnly &apos;org.projectlombok:lombok:1.18.2&apos;</span><br><span class="line">testAnnotationProcessor &apos;org.projectlombok:lombok:1.18.2&apos;</span><br><span class="line">testCompileOnly &apos;org.projectlombok:lombok:1.18.2&apos;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用Gradle-Plugin的方式"><a href="#2-使用Gradle-Plugin的方式" class="headerlink" title="2. 使用Gradle Plugin的方式"></a>2. 使用Gradle Plugin的方式</h3><p><a href="https://projectlombok.org/setup/gradle" target="_blank" rel="noopener">Lombok官网推荐配法</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	compileOnly &apos;org.projectlombok:lombok:1.18.10&apos;</span><br><span class="line">	annotationProcessor &apos;org.projectlombok:lombok:1.18.10&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好，当你做完以上的这些步骤，基本的一个简单的Spring Cloud微服务项目的雏形就诞生了！</p>
<p>之后的文章，我们会在此项目基础上更进一步地专研各个服务的特性，并深入学习~</p>
]]></content>
      <categories>
        <category>spring cloud</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP原理与技术对比</title>
    <url>/Spring%20AOP%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h1><p>AOP（Aspect Orient Programming），我们一般称为面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表。</p><a id="more"></a>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>其实，<code>org.springframework.boot:spring-boot-starter</code> 内部就依赖了<code>org.springframework:spring-aop</code>，也就是说，基本上只要用到spring-boot-starter相关库，内部就会有spring-aop相关支持。</p>
<p>比如，我们去打印一个Application的启动情况，就会发现，它其实是用GCLib动态代理后的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DynamicProxyDemoApplication implements ApplicationRunner &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    DynamicProxyDemoApplication mainApp;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DynamicProxyDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(mainApp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.example.dynamic_proxy_demo.DynamicProxyDemoApplication$$EnhancerBySpringCGLIB$$c4f6520e@420bc288</span><br></pre></td></tr></table></figure>

<p>Spring AOP 其实提供了多种横切逻辑织入机制（Weaving），性能损耗上也是各有差别，从运行期间的动态代理和字节码增强 Weavng，到类加载期间的 Weaving，甚至高冷的 AspectJ 二次静态编译 Weaving。</p>
<h1 id="静态代理–AspectJ"><a href="#静态代理–AspectJ" class="headerlink" title="静态代理–AspectJ"></a>静态代理–AspectJ</h1><p><img src="../images/spring_aop/1.png" alt><br>AspectJ属于编译时增强实现AOP。</p>
<p>AspectJ是一个Java实现的面向切面的框架，它扩展了Java语言。AspectJ有自定义的语法，所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。</p>
<ul>
<li>所谓静态代理：AOP框架在编译阶段生成AOP代理类。</li>
<li>静态代理也被称为“编译时增强”。</li>
</ul>
<p>原理：AspectJ会在Java文件编译生成Class文件时，Aspect J编译器会将需要做的额外的代码逻辑的字节码一并补全到被代理类的逻辑字节码周围。之后，在运行期间，一旦命中被代理类相关的逻辑，就会进入这个增强后的AOP对象，并调用增强后的逻辑。</p>
<blockquote>
<p>注意：这里说的是 AspectJ编译器（acj编译器），也就说明了其是在编译期生成新的类。</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol>
<li>首先maven引入依赖： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.8.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.8.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>然后，在idea中将javac编译器变成acj编译器来支持AspectJ语法：<br> <img src="../images/spring_aop/2.png" alt></li>
<li>将明星的表演抽象成一个ShowService接口，包括了唱歌、跳舞的功能 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ShowService &#123;</span><br><span class="line">    // 歌唱表演</span><br><span class="line">    void sing(String songName);</span><br><span class="line">    // 舞蹈表演</span><br><span class="line">    void dance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 明星类实现了ShowService接口： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Star implements ShowService&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sing(String songName) &#123;</span><br><span class="line">        System.out.println(this.name + &quot; sing a song: &quot; + songName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void dance() &#123;</span><br><span class="line">        System.out.println(this.name + &quot;dance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Star(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Star() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Star star = new Star(&quot;Eminem&quot;);</span><br><span class="line">        star.sing(&quot;Mockingbird&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>【关键】用AspectJ 的语法，来写切面类 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public aspect AgentAspectJ &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义切点</span><br><span class="line">     */</span><br><span class="line">    pointcut sleepPointCut():call(* Star.sing(..));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义切点</span><br><span class="line">     */</span><br><span class="line">    pointcut eatPointCut():call(* Star.eat(..));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义前置通知</span><br><span class="line">     *</span><br><span class="line">     * before(参数):连接点函数&#123;</span><br><span class="line">     *     函数体</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line">    before():sleepPointCut()&#123;</span><br><span class="line">        getMoney();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定义后置通知</span><br><span class="line">     * after(参数):连接点函数&#123;</span><br><span class="line">     *     函数体</span><br><span class="line">     * &#125;</span><br><span class="line">     */</span><br><span class="line">    after():sleepPointCut()&#123;</span><br><span class="line">        writeReceipt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void getMoney() &#123;</span><br><span class="line">        System.out.println(&quot;get money&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void writeReceipt() &#123;</span><br><span class="line">        System.out.println(&quot;write receipt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="动态代理–Spring-AOP"><a href="#动态代理–Spring-AOP" class="headerlink" title="动态代理–Spring AOP"></a>动态代理–Spring AOP</h1><p><img src="../images/spring_aop/3.png" alt></p>
<p>所谓动态代理：AOP框架不会修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法（相当于动态创建目标对象的一个子类对象），并在特定的切点做了增强处理，并回调原对象的方法。</p>
<p>Spring AOP动态代理的两种方式：</p>
<h2 id="JDK动态代理（反射）"><a href="#JDK动态代理（反射）" class="headerlink" title="JDK动态代理（反射）"></a>JDK动态代理（反射）</h2><p>JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 提供了一系列的static方法，用来创建代理类或对象，这个类是所有动态代理类的父类</span><br><span class="line">java.lang.reflect.Proxy</span><br><span class="line"></span><br><span class="line">// 这是调用处理器接口，只有一个invoke方法，处理动态代理类对象方法的调用，每个动态代理类都会关联一个InvocationHandler</span><br><span class="line">// 可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起</span><br><span class="line">java.lang.reflect.InvocationHandler</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyDemo_1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;</span><br><span class="line">        //(1)通过实现 InvocationHandler 接口创建自己的调用处理器</span><br><span class="line">        InvocationHandler handler = new InvocationHandler() &#123;</span><br><span class="line">            //创建委托类对象实例</span><br><span class="line">            private RealSubject subject = new RealSubject();</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                //调用委托类的方法</span><br><span class="line">                return method.invoke(subject, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //(2)通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类</span><br><span class="line">        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(ProxyDemo_1.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Subject.class&#125;);</span><br><span class="line">        //(3)通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型</span><br><span class="line">        Constructor&lt;?&gt; proxyClassConstructor = proxyClass.getConstructor(new Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;);</span><br><span class="line">        //(4)通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入</span><br><span class="line">        Object o = proxyClassConstructor.newInstance(handler);</span><br><span class="line">        //(5)通过动态代理对象调用</span><br><span class="line">        Subject subject = (Subject) o;</span><br><span class="line">        //(6)输出委托类的结果</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static interface Subject &#123;</span><br><span class="line">        void doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class RealSubject implements Subject &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void doSomething() &#123;</span><br><span class="line">            System.out.println(&quot;Hello&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不足：动态代理只能支持接口的代理，这也是因为java的继承性本质所限制的，因为所有的动态代理类都继承了Proxy类，所以再也无法同时继承其他类</p>
<h2 id="CGLIB动态代理（继承）"><a href="#CGLIB动态代理（继承）" class="headerlink" title="CGLIB动态代理（继承）"></a>CGLIB动态代理（继承）</h2><p>如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类<strong>被标记为final</strong>，那么它是<strong>无法使用CGLIB做动态代理</strong>的。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 中介所B implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T extends 房东&gt; 房东 newProxyInstance(Class&lt;T&gt; targetClass) &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(targetClass);</span><br><span class="line">        enhancer.setCallback(new 中介所B());</span><br><span class="line">        return (房东) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        System.out.print(objects[0] + &quot;你好，其实我是中介B，让我帮你转接电话给业务本人吧：&quot;);</span><br><span class="line">        return methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="JDK和CGLib两种动态代理性能对比"><a href="#JDK和CGLib两种动态代理性能对比" class="headerlink" title="JDK和CGLib两种动态代理性能对比"></a>JDK和CGLib两种动态代理性能对比</h1><ul>
<li>无论如何，他们两者相对于直接<code>new</code>对象，还是慢一点；</li>
<li>JDK1.8之前，JDK动态代理方式会比CGLib方式慢一点点；</li>
<li>JDK1.8之后，JDK动态代理方法甚至比后者更快。</li>
</ul>
<h1 id="Spring-AOP-与-AspectJ-的关系"><a href="#Spring-AOP-与-AspectJ-的关系" class="headerlink" title="Spring AOP 与 AspectJ 的关系"></a>Spring AOP 与 AspectJ 的关系</h1><p>目前来看，Spring貌似和AspectJ没半毛钱关系，那为什么在许多应用了Spring AOP的项目中都出现了@AspectJ的注解呢？Spring是应用的动态代理，怎么会还和AspectJ有关系呢，原因是Spring AOP基于注解配置的情况下，需要依赖于AspectJ包的标准注解，但是不需要额外的编译以及AspectJ的织入器，而基于XML配置不需要，所以Spring AOP只是复用了AspectJ的注解，并没有其他依赖AspectJ的地方。</p>
<p>所以，虽然使用了Aspect的Annotation，但是并没有使用它的编译器和织入器。其实现原理是JDK动态代理或Cglib，在运行时生成代理类。</p>
<h1 id="Spring-AOP-方式配置"><a href="#Spring-AOP-方式配置" class="headerlink" title="Spring AOP 方式配置"></a>Spring AOP 方式配置</h1><p>当需要使用@Aspectj 注解支持时，需要在Spring配置中加入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>

<p>当需要强制使用CGLIB：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="基于xml"><a href="#基于xml" class="headerlink" title="基于xml"></a>基于xml</h2><p>切面类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.fufu.spring.aop;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class AgentAdvisorXML &#123;</span><br><span class="line"></span><br><span class="line">    public void getMoney() &#123;</span><br><span class="line">        System.out.println(&quot;get money&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void writeReceipt() &#123;</span><br><span class="line">        System.out.println(&quot;write receipt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">       http://www.springframework.org/schema/aop</span><br><span class="line">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;star&quot; class=&quot;com.fufu.proxy.Star&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Eminem&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;agentAdvisorXML&quot; class=&quot;com.fufu.spring.aop.AgentAdvisorXML&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">     &lt;!--Spring基于Xml的切面--&gt;</span><br><span class="line">     &lt;aop:config&gt;</span><br><span class="line">         &lt;!-- 定义切点函数 --&gt;</span><br><span class="line">         &lt;aop:pointcut id=&quot;singPointCut&quot; expression=&quot;execution(* com.fufu.proxy.Star.sing(..))&quot;/&gt;</span><br><span class="line">         &lt;!-- 定义切面 order 定义优先级,值越小优先级越大--&gt;</span><br><span class="line">         &lt;aop:aspect ref=&quot;agentAdvisorXML&quot; order=&quot;0&quot;&gt;</span><br><span class="line">             &lt;!--前置通知--&gt;</span><br><span class="line">             &lt;aop:before method=&quot;getMoney&quot; pointcut-ref=&quot;singPointCut&quot;/&gt;</span><br><span class="line">             &lt;!--后置通知--&gt;</span><br><span class="line">             &lt;aop:after method=&quot;writeReceipt&quot; pointcut-ref=&quot;singPointCut&quot;/&gt;</span><br><span class="line">         &lt;/aop:aspect&gt;</span><br><span class="line">     &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.fufu.spring.aop;</span><br><span class="line"></span><br><span class="line">import com.fufu.proxy.ShowService;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aop.xml&quot;);</span><br><span class="line"></span><br><span class="line">        Object star = applicationContext.getBean(&quot;star&quot;);</span><br><span class="line"></span><br><span class="line">        ShowService showService = (ShowService)star;</span><br><span class="line">        showService.sing(&quot;Mockingbird&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h2><p>切面类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class AgentAdvisor &#123;</span><br><span class="line"></span><br><span class="line">    @Before(value = &quot;execution(* com.fufu.proxy.ShowService.sing(..))&quot;)</span><br><span class="line">    public void getMoney() &#123;</span><br><span class="line">        System.out.println(&quot;get money&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(value = &quot;execution(* com.fufu.proxy.ShowService.sing(..))&quot;)</span><br><span class="line">    public void writeReceipt() &#123;</span><br><span class="line">        System.out.println(&quot;write receipt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">       http://www.springframework.org/schema/aop</span><br><span class="line">       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.fufu.proxy, com.fufu.spring.aop&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy  proxy-target-class=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.fufu.spring.aop;</span><br><span class="line"></span><br><span class="line">import com.fufu.proxy.ShowService;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-aop-annotation.xml&quot;);</span><br><span class="line"></span><br><span class="line">        Object star = applicationContext.getBean(&quot;star&quot;);</span><br><span class="line"></span><br><span class="line">        ShowService showService = (ShowService)star;</span><br><span class="line">        showService.sing(&quot;Mockingbird&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Spring-Boot-Starter-AOP-方式配置"><a href="#Spring-Boot-Starter-AOP-方式配置" class="headerlink" title="Spring Boot Starter AOP 方式配置"></a>Spring Boot Starter AOP 方式配置</h1><p>当需要使用@Aspectj 注解支持时，.properties中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认是true</span><br><span class="line">spring.aop.auto=true</span><br></pre></td></tr></table></figure>

<p>当需要强制使用CGLIB，.properties中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.aop.proxy-target-class=true</span><br></pre></td></tr></table></figure>


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>AspectJ在编译时就增强了目标对象，Spring AOP的动态代理则是在每次运行时动态的增强，生成AOP代理对象。</li>
<li>两者区别：生成AOP代理对象的时机不同。</li>
<li>AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</li>
</ul>
<h1 id="相关Demo"><a href="#相关Demo" class="headerlink" title="相关Demo"></a>相关Demo</h1><p><a href="https://github.com/androidjp/dynamic_proxy_demo.git" target="_blank" rel="noopener">https://github.com/androidjp/dynamic_proxy_demo.git</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://thinkdevos.net/2017/09/22/2017-09-22/#more" target="_blank" rel="noopener">http://thinkdevos.net/2017/09/22/2017-09-22/#more</a></li>
<li><a href="https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a" target="_blank" rel="noopener">https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a</a></li>
<li><a href="https://juejin.im/post/5a99048a6fb9a028d5668e62" target="_blank" rel="noopener">https://juejin.im/post/5a99048a6fb9a028d5668e62</a></li>
<li><a href="https://www.cnblogs.com/MOBIN/p/5597215.html" target="_blank" rel="noopener">https://www.cnblogs.com/MOBIN/p/5597215.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/NZP2_I918SplJy_zAuhing" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/NZP2_I918SplJy_zAuhing</a></li>
<li><a href="https://juejin.im/post/5b90e648f265da0aea695672" target="_blank" rel="noopener">https://juejin.im/post/5b90e648f265da0aea695672</a></li>
</ul>
]]></content>
      <categories>
        <category>spring</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList是怎么工作的</title>
    <url>/CopyOnWriteArrayList%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<blockquote>
<p>Java 并发包提供了很多线程安全的集合，有了他们的存在，使得我们在多线程开发下，大大简化了多线程开发的难度，但是如果不知道其中的原理，可能会引发意想不到的问题，所以知道其中的原理还是很有必要的。</p>
</blockquote>
<a id="more"></a>

<h1 id="背景思想"><a href="#背景思想" class="headerlink" title="背景思想"></a>背景思想</h1><p>Copy-On-Write 简称 COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容 Copy 出去形成一个新的内容然后再改，这是一种延时懒惰策略。</p>
<p>CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>CopyOnWrite相关两个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.CopyOnWriteArrayList</span><br><span class="line">java.util.concurrent.CopyOnWriteArraySet</span><br></pre></td></tr></table></figure>
<p>其中，<code>CopyOnWriteArraySet</code>的底层是<code>CopyOnWriteArrayList</code>。</p>
<p>本文主要通过源码入手，探讨<code>CopyOnWriteArrayList</code>的工作原理。</p>
<h1 id="看看源码"><a href="#看看源码" class="headerlink" title="看看源码"></a>看看源码</h1><h2 id="首先，看看它有什么field："><a href="#首先，看看它有什么field：" class="headerlink" title="首先，看看它有什么field："></a>首先，看看它有什么field：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可重入锁（不参与对象序列化过程）</span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 底层对象数组（不参与对象序列化过程，拥有线程可见性）</span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ol>
<li>底层数组使用volatile保证数据可见性和禁止指令重排序；</li>
<li><code>CopyOnWriteArraySet</code> 实现线程安全的原理是利用可重入锁。</li>
</ol>
<h2 id="数据修改方法–源码分析"><a href="#数据修改方法–源码分析" class="headerlink" title="数据修改方法–源码分析"></a>数据修改方法–源码分析</h2><p><code>add()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock(); //------------- 1. 写操作加锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        //---------------------- 2. 复制数组</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        //---------------------- 3. 将旧数组 指针指向 新数组</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //---------------------- 4. 解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock(); //------------- 1. 写操作加锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        //---------------------- 2. 如果新元素不等于旧元素，则copy一份副本，更新该位置的元素，最后替换原数组</span><br><span class="line">        if (oldValue != element) &#123;</span><br><span class="line">            int len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //------------------ 3. 即使新旧元素相同，但为了触发volatile特性，还是做一次赋值操作</span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //---------------------- 4. 解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock(); //------------- 1. 写操作加锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            //------------------ 2. 如果是删除数组最后一个元素，那么，直接复制一个长度减1的副本，然后更新原数组</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            //------------------ 3. 否则，分开两次进行复制，再更新原数组</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //---------------------- 4. 解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，</p>
<p>看到这里，可以得出一些结论：</p>
<ol>
<li>对于所有的写操作，在多线程对同一个<code>CopyOnWriteArrayList</code>对象做写入操作时，是线程安全的。因为用了 <code>ReentrantLock</code> 独占锁，保证同时只有一个线程对集合进行修改操作。</li>
<li>CopyOnWrite 原来就是指：写时复制。就是在写的时候，先 copy 一个，操作新的对象。然后在覆盖旧的对象，保证 volatile 语义。</li>
<li>占用内存，写时 copy 效率低。我们看这些每一个写操作，都是需要copy数据的。因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 300M，那么这个时候很有可能造成频繁的 Yong GC 和 Full GC。</li>
</ol>
<h2 id="再看看它的get方法："><a href="#再看看它的get方法：" class="headerlink" title="再看看它的get方法："></a>再看看它的get方法：</h2><p><code>get()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Object[] getArray() &#123;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 <code>get()</code>我们就能知道，“读写分离” 原来就是这么回事：因为的写操作不会直接立即修改原数组，那么，我在读的时候就可以肆无忌惮地并发读，因为我不需要担心数组在读取、遍历过程中会被别人修改。</p>
<p>get 方法很简单。但是会出现一个很致命的问题，那就是一致性问题。</p>
<p>当我们获得了 array 后，由于整个 get 方法没有独占锁，所以另外一个线程还可以继续执行修改的操作，比如执行了 remove 的操作，remove 和 add 一样，也会申请独占锁，并且复制出新的数组，删除元素后，替换掉旧的数组。而这一切 get 方法是不知道的，它不知道 array 数组已经发生了天翻地覆的变化。就像微信一样，虽然对方已经把你给删了，但是你不知道。这就是一个一致性问题。</p>
<p>CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器。</p>
<h2 id="它的迭代器：COWIterator"><a href="#它的迭代器：COWIterator" class="headerlink" title="它的迭代器：COWIterator"></a>它的迭代器：COWIterator</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    /** Snapshot of the array */</span><br><span class="line">    private final Object[] snapshot;</span><br><span class="line">    /** Index of element to be returned by subsequent call to next.  */</span><br><span class="line">    private int cursor;</span><br><span class="line"></span><br><span class="line">    private COWIterator(Object[] elements, int initialCursor) &#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return cursor &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        if (! hasNext())</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 iterator 方法获取迭代器，内部会调用 COWIterator 的构造方法，此构造方法有两个参数，第一个参数就是 array 数组，第二个参数是下标，就是 0。随后构造方法中会把 array 数组赋值给snapshot变量。snapshot 是“快照”的意思，如果 Java 基础尚可的话，应该知道数组是引用类型，传递的是指针，如果有其他地方修改了数组，这里应该马上就可以反应出来，那为什么又会是 snapshot这样的命名呢？没错，如果其他线程没有对 CopyOnWriteArrayList 进行增删改的操作，那么 snapshot 就是本身的 array，但是如果其他线程对 CopyOnWriteArrayList 进行了增删改的操作，旧的数组会被新的数组给替换掉，但是 snapshot 还是原来旧的数组的引用。也就是说 当我们使用迭代器便利 CopyOnWriteArrayList 的时候，不能保证拿到的数据是最新的，这也是一致性问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>CopyOnWriteArrayList是这样工作的</strong>：</p>
<ul>
<li><strong>写时复制</strong>：在执行<code>add</code>、<code>set</code>、<code>remove</code>等操作修改底层数组时，会先copy一份原数组的副本，然后操作这个副本，操作完毕后，会让原数组的指针指向更新后的副本。</li>
<li><strong>写时加锁，写完释放锁</strong>：在执行<code>add</code>、<code>set</code>、<code>remove</code>等操作的开头，就会上一个可重入锁，只有在操作完成后，才会释放锁。并且同一时刻，对于CopyOnWriteArrayList来说，只会执行一个写相关方法，换句话说：线程A 在<code>add</code>的时候，线程B 的<code>set</code>会等待。</li>
<li><strong>读取和遍历的数据，不一定就是最新的数据</strong>：看到其<code>get()</code>方法和<code>COWIterator</code>迭代器的原理，我们知道，<code>CopyOnWriteArrayList</code>只能保证数据的最终一致性，目的是为了牺牲即时一致性，来保证数据的可读。</li>
<li><strong>底层数据结构是volatile修饰的数组，所以支持volatile的所有特性</strong>：在之前的文章中笔者有分享volatile的原理，在<code>CopyOnWriteArrayList</code>中，volatile关键字的作用则是：保证数据的修改会让刷入主线程，并其他线程的缓存失效，从而达到“可见性”。不过由于“写时复制”特性，只有在最终的原数组指针重新指向新数组的时刻，这个“可见性”才会生效（不过也只有当下一次调用<code>get()</code>等读方法时，才会读取最新的数据）。所以，volatile并不能解决数据在多线程中的实时一致性问题，更不能实现原子性。</li>
</ul>
<p><strong>CopyOnWriteArrayList 的优点</strong></p>
<ul>
<li>线程安全</li>
<li>读写分离，支持并发读</li>
</ul>
<p><strong>CopyOnWriteArrayList 的缺点</strong></p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
<li>由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</li>
<li>内存占用问题：因为CopyOnWrite的写时拷贝机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意：在拷贝的时候只是拷贝容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，比如ConcurrentHashMap。<blockquote>
<p>尽量使用批量方法 <code>addAll()</code>，添加因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</p>
</blockquote>
</li>
</ul>
<p><strong>CopyOnWriteArrayList 的设计思想</strong></p>
<ul>
<li>读写分离，读和写分开（好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。）</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
<p><strong>CopyOnWriteArrayList 的使用场景</strong></p>
<ul>
<li><strong>读多写少</strong>的场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIyODE5NjUwNQ==&amp;mid=2653316286&amp;idx=1&amp;sn=faa5649aefb0958d7bab73b4d4d7c8a0&amp;chksm=f3876d48c4f0e45e20640c8212bcb3a3af35b17cdca774d1171d2a6ad8369ba7f761eabe29f7&amp;scene=7&amp;key=93bab146cfb76d6578a2d711fde6e911546b163716abc2b49706d4e6e754611ca6eb67be498b19fe4ec528918aa01caa6f4a6a116df0f5c004a5374325fb8a6485ec449668d8138f2d84da8de13cf3a1&amp;ascene=0&amp;uin=MjU1MDY2OTI0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=pdoJI3%2BSn6V4T3Hfaxyp%2FLAZx6FpYCaKbhu1NtjFtsrhyY9yGKrmq9h33iKr1bxQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIyODE5NjUwNQ==&amp;mid=2653316286&amp;idx=1&amp;sn=faa5649aefb0958d7bab73b4d4d7c8a0&amp;chksm=f3876d48c4f0e45e20640c8212bcb3a3af35b17cdca774d1171d2a6ad8369ba7f761eabe29f7&amp;scene=7&amp;key=93bab146cfb76d6578a2d711fde6e911546b163716abc2b49706d4e6e754611ca6eb67be498b19fe4ec528918aa01caa6f4a6a116df0f5c004a5374325fb8a6485ec449668d8138f2d84da8de13cf3a1&amp;ascene=0&amp;uin=MjU1MDY2OTI0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=pdoJI3%2BSn6V4T3Hfaxyp%2FLAZx6FpYCaKbhu1NtjFtsrhyY9yGKrmq9h33iKr1bxQ</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NjczNzUwOA==&amp;mid=2247483868&amp;idx=1&amp;sn=e33526b478b47e9aa3985c68f2ff5bc6&amp;chksm=fdf7f3d7ca807ac10080e9de204e0cd6138f7a4a47329dd0693a1a89500f0599bad4ce9ce3da&amp;scene=7&amp;key=61615b455c1fa1772017593446b81ea8b0fb9dd848a76e337ec007a64813046ff0b522bac062ae79dea201a32ec18e6204e70f74e619c57772d585ae3f2c00b206ec028abb4ddeb2866db77846e93cc2&amp;ascene=0&amp;uin=MjU1MDY2OTI0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=pdoJI3%2BSn6V4T3Hfaxyp%2FLAZx6FpYCaKbhu1NtjFtsrhyY9yGKrmq9h33iKr1bxQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU4NjczNzUwOA==&amp;mid=2247483868&amp;idx=1&amp;sn=e33526b478b47e9aa3985c68f2ff5bc6&amp;chksm=fdf7f3d7ca807ac10080e9de204e0cd6138f7a4a47329dd0693a1a89500f0599bad4ce9ce3da&amp;scene=7&amp;key=61615b455c1fa1772017593446b81ea8b0fb9dd848a76e337ec007a64813046ff0b522bac062ae79dea201a32ec18e6204e70f74e619c57772d585ae3f2c00b206ec028abb4ddeb2866db77846e93cc2&amp;ascene=0&amp;uin=MjU1MDY2OTI0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=pdoJI3%2BSn6V4T3Hfaxyp%2FLAZx6FpYCaKbhu1NtjFtsrhyY9yGKrmq9h33iKr1bxQ</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&amp;mid=2650496647&amp;idx=2&amp;sn=6466a5e357d2d376110d7f521569afc5&amp;chksm=83c8b97bb4bf306d2f3721b59db673e03467ba870ef1461e8bb150e3cff72a34e16abc25716d&amp;scene=7&amp;key=b872184137e9e0f6870d7355b1c1876c00085e79fbf69638101678b555ea346684701b1eeb37a5d64e847fb84dd90a1b5f33c99de66d1fdc603699e40cbfa645d44c7fb8ccbd347c9928050b7bf49f8e&amp;ascene=0&amp;uin=MjU1MDY2OTI0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=pdoJI3%2BSn6V4T3Hfaxyp%2FLAZx6FpYCaKbhu1NtjFtsrhyY9yGKrmq9h33iKr1bxQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxOTQxOTc5NQ==&amp;mid=2650496647&amp;idx=2&amp;sn=6466a5e357d2d376110d7f521569afc5&amp;chksm=83c8b97bb4bf306d2f3721b59db673e03467ba870ef1461e8bb150e3cff72a34e16abc25716d&amp;scene=7&amp;key=b872184137e9e0f6870d7355b1c1876c00085e79fbf69638101678b555ea346684701b1eeb37a5d64e847fb84dd90a1b5f33c99de66d1fdc603699e40cbfa645d44c7fb8ccbd347c9928050b7bf49f8e&amp;ascene=0&amp;uin=MjU1MDY2OTI0Mw%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=pdoJI3%2BSn6V4T3Hfaxyp%2FLAZx6FpYCaKbhu1NtjFtsrhyY9yGKrmq9h33iKr1bxQ</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合扩容原理分析</title>
    <url>/Java%E9%9B%86%E5%90%88%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>编程语言提供的集合类，虽然底层还是基于数组、链表这种最基本的数据结构，但是和我们直接使用数组不同，集合在容量不足时，会触发动态扩容来保证有足够的空间存储数据。<br>动态扩容，涉及到数据的拷贝，是一种「较重」的操作。那如果能够提前确定集合将要存储的数据量范围，就可以通过构造方法，指定集合的初始容量，来保证接下来的操作中，不至于触发动态扩容。</p><a id="more"></a>
<blockquote>
<p>几个常问问题：</p>
<p>到底是 <code>new ArrayList&lt;&gt;();</code>简单粗暴好，还是<code>new ArrayList&lt;&gt;(30);</code> 给他一个初始容量好呢？万一容量不够会怎么样呢？</p>
<p>如果给你一个<code>new HashMap&lt;&gt;(10000)</code>，你往里头存放 1w 条缓存数据，此时，你觉得 <code>HashMap</code>还会扩容吗？ 是否真的是占用超过75%，就会扩容呢？还是另有答案呢？</p>
</blockquote>
<p>以上的迷惑，下面给大家快速解答。</p>
<h1 id="Java集合类齐分析"><a href="#Java集合类齐分析" class="headerlink" title="Java集合类齐分析"></a>Java集合类齐分析</h1><p>首先，把常用的Java集合类摆上台，我们先观摩一下他们的主要特征：</p>
<table>
<thead>
<tr>
<th>集合类</th>
<th>线程安全</th>
<th>底层</th>
<th>数组初始大小</th>
<th>扩容因子</th>
<th>扩容增量</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>否</td>
<td>数组</td>
<td>10</td>
<td>1【当元素个数超过容量长度的100%时，进行扩容】</td>
<td>原容量 + 原容量&gt;&gt;1</td>
</tr>
<tr>
<td>Vector</td>
<td>是</td>
<td>数组</td>
<td>10</td>
<td>1</td>
<td>原容量 x 2</td>
</tr>
<tr>
<td>HashSet</td>
<td>否</td>
<td>HashMap</td>
<td>16</td>
<td>0.75</td>
<td>原容量 x 2</td>
</tr>
<tr>
<td>HashMap</td>
<td>否</td>
<td>元素是单向链表的数组</td>
<td>16</td>
<td>0.75</td>
<td>原容量 x 2</td>
</tr>
<tr>
<td>Hashtable</td>
<td>是</td>
<td>元素是单向链表的数组</td>
<td>11</td>
<td>0.75</td>
<td>原容量 x 2 + 1</td>
</tr>
</tbody></table>
<blockquote>
<p>为何是16：16是2^4，可以提高查询效率，另外，32=16&lt;&lt;1</p>
<p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的。</p>
</blockquote>
<p>好，我们接下来用源码来解答几个常见问题。</p>
<h1 id="问题一：初始化集合需不需要加初始容量？初始容量设置多大为妙？"><a href="#问题一：初始化集合需不需要加初始容量？初始容量设置多大为妙？" class="headerlink" title="问题一：初始化集合需不需要加初始容量？初始容量设置多大为妙？"></a>问题一：初始化集合需不需要加初始容量？初始容量设置多大为妙？</h1><p>答：如果能够大致确定集合中可能存储的元素总量，那么，建议还是根据不同集合的扩容因子来加个初始容量，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 我最多存 30个元素</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(30); // 30 除以 1</span><br><span class="line">// 我最多存 30个键值对</span><br><span class="line">Map&lt;String,String&gt; map = new HashMap&lt;&gt;(40); // 30 除以 0.75</span><br></pre></td></tr></table></figure>

<h1 id="问题二：HashMap扩容问题"><a href="#问题二：HashMap扩容问题" class="headerlink" title="问题二：HashMap扩容问题"></a>问题二：HashMap扩容问题</h1><p>给你一个<code>new HashMap&lt;&gt;(10000)</code>，你往里头存放 1w 条缓存数据，此时，你觉得 <code>HashMap</code>还会扩容吗？ 是否真的是占用超过75%，就会扩容呢？还是另有答案呢？</p>
<blockquote>
<p>其实每个集合的扩容思路大同小异，但是实现是不太一样的(比如：<code>Hashtable</code>的扩容方法叫做<code>rehash()</code>)，这里我们只分析HashMap的扩容原理。</p>
</blockquote>
<p>看看HashMap源码，首先看到它的几个默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认容量：必须是2的倍数，这里是 16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">// 如果具有参数的构造函数中的任何一个隐式指定了更高的值，则使用最大容量。</span><br><span class="line">// 取值范围：[2, 1&lt;&lt;30]</span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">// 默认增量因子</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<p>然后看到它的几个主要的fields：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 链表+数组 的 存储结构 --- table</span><br><span class="line">* 会分配一个2的N次幂 的数值大小，作为table的数组长度</span><br><span class="line">*/</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line">* for keySet() and values().</span><br><span class="line">*/</span><br><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 存在于此Map中的所有key-value （键值对） 数量</span><br><span class="line">* 也就是：已占用数</span><br><span class="line">*/</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* HashMap结构性改变的次数，包括：</span><br><span class="line">* mapping的数量改变、rehash、用于快速失败（fail-fast） (See ConcurrentModificationException).</span><br><span class="line">*/</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 扩容阈值：用于决定是否table需要扩容</span><br><span class="line">* threshold = capacity * load factor</span><br><span class="line">*/</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 加载因子（或者说扩容因子，默认是 0.75）</span><br><span class="line">*/</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure>
<p>好，我们看看HashMap初始化时做了什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//--------</span><br><span class="line">// 构造器</span><br><span class="line">//--------</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ...........</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 将传入的初始容量，计算得到一个 2的n次方 数，作为数组的容量 (table.size)</span><br><span class="line">*/</span><br><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n = cap - 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 1;</span><br><span class="line">    n |= n &gt;&gt;&gt; 2;</span><br><span class="line">    n |= n &gt;&gt;&gt; 4;</span><br><span class="line">    n |= n &gt;&gt;&gt; 8;</span><br><span class="line">    n |= n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又看到源码里头的不少方法，都会比较当前占用<code>size</code>和当前扩容阈值<code>threshold</code>，一言不合就要扩容的节奏！</p>
<p>比如这个<code>putVal()</code>方法，看看里头的一段code：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    // ..........</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续的update等操作，都会触发<code>resize()</code>。我们一睹它的主要逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* resize():    </span><br><span class="line">* 初始化或加倍表大小。 如果为 null，则根据字段阈值中保持的初始容量目标进行分配。</span><br><span class="line">否则，由于我们使用的是 加工后的2的N次幂数，因此每个 bin 中的元素必须保持相同的索引，或者在扩容后的新table中以2的偏移量移动。</span><br><span class="line">* @return the table</span><br><span class="line">*/</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    // 1. 拿到现在已存在的table，得到 原来的容量： oldCap</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line"></span><br><span class="line">    // 2. 拿到现在已存在的阈值（threshold）： oldThr</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line"></span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    // 3. 如果不是第一次创建table，那么，看看是否已经达到最大的可允许范围（1&lt;&lt;30），如果是，那么直接让阈值变成最大的INT值，且不进行扩容。</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">    // 4. 否则，如果 oldCap 乘以 2 ，都不超过 (1&lt;&lt;30)，那么，直接：newCap = oldCap &lt;&lt; 1</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold  阈值 乘以 2</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // Default: 容量 = 1&lt;&lt;4， 阈值 = 0.75 * 容量</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // .........</span><br><span class="line"></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 将 旧table的索引 往 新table 上面搬运。</span><br><span class="line">        // ............</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>HashMap 源码告诉我们：</p>
<ul>
<li>table就是那个链表数组的存储结构；</li>
<li>loadFactor 默认是 0.75；</li>
<li>initialCapacity 是初始容量，不设置，capacity则为默认16，取值范围是 [2, 1&lt;&lt;30]；</li>
<li>capacity 一定是 2的N次幂数，通过<code>tableSizeFor()</code> 方法保证；</li>
<li>threshold 是 扩容阈值；</li>
<li>threshold = table.size * loadFactor；</li>
<li>HashMap 是否扩容，由 threshold 决定，而 threshold 又由初始容量和 loadFactor 决定；</li>
<li><code>putVal(..)</code>方法告诉我们：在每次调用<code>put(k,v)</code>的过程中，里头会判断当前占用是否大于 threshold，如果大于，则做 扩容；</li>
<li><code>resize()</code>方法告诉我们：<ul>
<li>第一次初始化 容量（capacity）和 阈值（threshold）时：<ul>
<li>容量（capacity） = 1 &lt;&lt; 4 = 16</li>
<li>阈值（threshold） = 0.75 * 容量（capacity）</li>
</ul>
</li>
<li>后续的扩容：<ul>
<li>容量（capacity） = capacity * 2</li>
<li>阈值（threshold） = threshold * 2</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>那么，回到前面的问题：如果是一个初始入参<code>capacity=10000</code>的HashMap，那么，到底会不会在put 了 1w 条记录时 进行扩容？</p>
<p>我们带入源码，会得到：<br><img src="/images/hashMap/hashMap_1.png" alt></p>
<p>哦，其实此时，我们的table初始容量，并不是 <code>10000</code>，而是 <code>16384</code>。那么，阈值我们口算一下就能得到: <code>15384*0.75 = 12288</code>。所以，当我们插入1w条记录，HashMap的这段逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure>
<p>这段代码是无法走进来的！！所以，初始给1w的HashMap，往里扔1w条记录，是否会扩容？ <strong>答案是：不会扩容</strong>。</p>
<p>当然，如果给他初始容量设为1000，这又不一样了：<br><img src="/images/hashMap/hashMap_2.png" alt><br>好，可以看到，此时，它调整为<code>1024</code>，<code>阈值 = 1024  * 0.75 = 768</code>，那么，当我们插入1k条记录，那此时就会扩容了~</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://juejin.im/post/5db92860e51d4529ee588406" target="_blank" rel="noopener">https://juejin.im/post/5db92860e51d4529ee588406</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo架构图解分析</title>
    <url>/Dubbo%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="分析官方架构图"><a href="#分析官方架构图" class="headerlink" title="分析官方架构图"></a>分析官方架构图</h1><p><img src="/images/dubbo/%E5%AE%98%E6%96%B9%E6%9E%B6%E6%9E%84%E5%9B%BE_1.png" alt=""></p>
<a id="more"></a>

<p>角色说明：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Provider</code></td>
<td>服务提供方（暴露服务）</td>
</tr>
<tr>
<td><code>Consumer</code></td>
<td>服务消费者（调用远程服务）</td>
</tr>
<tr>
<td><code>Registry</code></td>
<td>注册中心（服务注册与发现）</td>
</tr>
<tr>
<td><code>Monitor</code></td>
<td>监控中心（统计服务调用次数和调用时间）</td>
</tr>
<tr>
<td><code>Container</code></td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<p>步骤：</p>
<ul>
<li>0 – 首先，服务容器负责启动，加载，运行服务提供者。</li>
<li>1 – 服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>2 – 服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>3 – 注册中心返回 <strong>服务提供者地址列表</strong> 给消费者，如果有变更，注册中心将基于 <strong>长连接</strong> 推送变更数据给消费者。</li>
<li>4 – 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>5 – 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
<h1 id="Dubbo的特点"><a href="#Dubbo的特点" class="headerlink" title="Dubbo的特点"></a>Dubbo的特点</h1><h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><ul>
<li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li>
<li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li>
<li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li>
<li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li>
<li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li>
<li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li>
<li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li>
<li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li>
</ul>
<blockquote>
<p>疑问： 如果服务提供者宕机了，而注册中心又没来得及通知消费者，此时如果消费者正好在调用 此服务提供者，那么，会发生什么？</p>
<p>答： 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复。</p>
</blockquote>
<h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><ul>
<li>监控中心宕掉不影响使用，只是丢失部分采样数据</li>
<li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li>
<li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li>
<li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
<li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li>
</ul>
<h2 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h2><ul>
<li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li>
<li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li>
</ul>
<h2 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h2><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：</p>
<p><img src="/images/dubbo/dubbo-architecture-future.jpg" alt=""></p>
<p>节点角色说明：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Deployer</code></td>
<td>自动部署服务的本地代理</td>
</tr>
<tr>
<td><code>Repository</code></td>
<td>仓库（用于存储服务应用发布包）</td>
</tr>
<tr>
<td><code>Scheduler</code></td>
<td>调度中心（基于访问压力自动增减服务提供者）</td>
</tr>
<tr>
<td><code>Admin</code></td>
<td>统一管理控制台</td>
</tr>
<tr>
<td><code>Registry</code></td>
<td>注册中心（服务注册与发现）</td>
</tr>
<tr>
<td><code>Monitor</code></td>
<td>监控中心（统计服务的调用次数和调用时间）</td>
</tr>
</tbody></table>
<p>整个流程解析：</p>
<ol>
<li>部署开始，在管理平台上trigger 上传一个版本到仓库</li>
<li>然后，启动调度器 并将让其开始调度</li>
<li>调度器执行其调度工作：当Deployer 执行 deploy 方法</li>
<li>从仓库中拉取服务提供者的新版本</li>
<li>Deployer作为本地代理，被调度器启动，会启动 容器</li>
<li>容器被启动后，其内部已下载的 服务提供者 则会跟随启动并初始化，注册自己到注册中心上</li>
<li>Admin 路由到 注册中心</li>
<li>消费者订阅 注册中心</li>
<li>消费者收到来自注册中心的更新提醒：“服务提供者有新版本已上线，可供使用了，其ip地址是：xxxx”</li>
<li>好，此时消费者就会根据注册中心的新名册，去调用新deploy的服务提供者。</li>
<li>同时，消费者将请求历史一一上报给监控中心Monitor</li>
<li>监控中心再发送报告给调度器，从而让调度器实时知道当前的负荷高低</li>
<li>管理控制台可以实时显示监控中心的统计数据</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池笔记</title>
    <url>/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="普通的新建线程去处理异步任务，有什么缺点？"><a href="#普通的新建线程去处理异步任务，有什么缺点？" class="headerlink" title="普通的新建线程去处理异步任务，有什么缺点？"></a>普通的新建线程去处理异步任务，有什么缺点？</h2><ol>
<li>创建和销毁线程造成资源消耗（包括时间、系统资源、cpu资源）。</li>
<li>线程无法管理。</li>
</ol><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p>线程池是：一组已经创建好的，一直在等待任务执行的线程的集合。</p><h2 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h2><ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。</li>
</ul><a id="more"></a>


<h2 id="jdk线程池详解"><a href="#jdk线程池详解" class="headerlink" title="jdk线程池详解"></a>jdk线程池详解</h2><p><code>java.util.concurrent</code><br>其中，蓝色表示 类/抽象类，绿色代表 接口：</p>
<pre class="mermaid">graph TB
A[ScheduledThreadPoolExecutor]
B[ThreadPoolExecutor]
C[AbstractExecutorService]
D[ScheduledExecutorService]
E[ExecutorService]
F[Executor]
A --extends--> B
B --extends--> C
C -.implements.-> E
A -.implements.-> D
D --extends--> E
E --extends--> F
style D fill:#c6d6af,stroke:#929296,stroke-width:2px,stroke-dasharray: 10,5
style E fill:#c6d6af,stroke:#929296,stroke-width:2px,stroke-dasharray: 10,5
style F fill:#c6d6af,stroke:#929296,stroke-width:2px,stroke-dasharray: 10,5</pre>

<h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><ul>
<li>自jdk1.5引入</li>
<li>只有一个方法<code>execute</code>(是线程池最基本的作用)</li>
</ul>
<h2 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h2><ul>
<li>继承 Executor 接口</li>
<li>更加丰富的方法：<ul>
<li><code>shutdown():void</code>：”优雅地”关闭线程。（因为这个线程池在关闭前会先等待线程池中已经有的任务执行完成，一般会配合方法<code>awaitTermination</code>一起使用，调用该方法后，线程池中不能再加入新的任务。）</li>
<li><code>shutdownNow():List&lt;Runnable&gt;</code>： “尝试”终止正在执行的线程，返回在正在等待的任务列表，调用这个方法后，会调用正在执行线程的interrupt（）方法，所以如果正在执行的线程如果调用了sleep，join，await等方法，会抛出InterruptedException异常。</li>
<li><code>awaitTermination(long timeout, TimeUnit unit):boolean</code>： 该方法是一个阻塞方法，参数分别为时间和时间单位。这个方法一般配合上面两个方法之后调用。如果先调用shutdown方法，所有任务执行完成返回true，超时返回false，如果先调用的是shutdownNow方法，正在执行的任务全部完成true，超时返回false。</li>
<li><code>isTerminated():boolean</code>：调用方法1或者2后，如果所有人物全部执行完毕则返回true，也就是说，就算所有任务执行完毕，但是不是先调用1或者2，也会返回false。</li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：提交一个能够返回结果的Callable任务，返回任务结果抽象对象是Future，调用Future.get()方法可以阻塞等待获取执行结果，例如：<code>result = exec.submit(aCallable).get();</code>，提交一个任务并且一直阻塞知道该任务执行完成获取到返回结果。</li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>：提交一个Runnable任务，执行成功后调用Future.get()方法返回的是result（这是什么骚操作？）。</li>
<li><code>Future&lt;?&gt; submit(Runnable task)</code>：和上一个方法不同的是调用Future.get（）方法返回的是null（这又是什么操作？）。</li>
<li><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code>：提交一组任务，并且返回每个任务执行结果的抽象对象List&lt;Future<t>&gt;，Future作用同上，值得注意的是：<br>当调用其中任一Future.isDone()(判断任务是否完成，正常，异常终止都算）方法时，必须等到所有任务都完成时才返回true，简单说：全部任务完成才算完成。</t></li>
<li><code>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code>： 同上，多了一个时间参数，不同的是：如果超时，Future.isDone()同样返回true。</li>
<li><code>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code>：这个看名字和上面对比就容易理解了，返回第一个正常完成的任务地执行结果，后面没有完成的任务将被取消。</li>
<li><code>&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)</code>：同前一个方法相比，多了一个超时参数。不同的是：在超时时间内，一个任务都没有完成，将抛出TimeoutException。</li>
</ul>
</li>
</ul>
<h2 id="AbstractExecutorService-抽象类"><a href="#AbstractExecutorService-抽象类" class="headerlink" title="AbstractExecutorService 抽象类"></a>AbstractExecutorService 抽象类</h2><p>仅仅实现了ExecutorService接口的三个方法：</p>
<ul>
<li><code>submit</code>：<ol>
<li>对传入的Runnable对象判空</li>
<li>然后创建一个RunnableFuture（Future的子类）对象</li>
<li>并执行这个future对象（<code>execute</code>方法交由子类实现）</li>
<li>最终返回这个future对象（<code>RunnableFuture</code>同时继承 <code>Runnable</code>和<code>Future</code>接口，其实现是<code>FutureTask</code>）</li>
</ol>
</li>
<li><code>invokeAll</code>：<ol>
<li>声明一个flag用于判断所有任务是否全部完成。</li>
<li>调用<code>newTaskFor</code>构建<code>RunnableFuture</code>对象，循环调用<code>execute</code>方法添加每个任务。</li>
<li>遍历每个任务的结果，判断是否执行完毕，没有完成则调用<code>get()</code>方法来等待它完成。</li>
<li>所有任务全部完成，将flag设置为true。</li>
<li>如果存在异常，且此时有任务还没有执行完毕，那么，所有任务取消（<code>Future.cancel()</code>实际内部调用<code>Thread.interrupt()</code>）</li>
</ol>
</li>
<li><code>invokeAny</code>：实际内部调用另一个方法<code>doInvokeAny</code><ol>
<li>声明一个ExecutorCompletionService ecs，这个对象实际是一个任务执行结果阻塞队列和线程池的结合，所以它可以加入任务，执行任务，将任务执行结果加入阻塞队列。</li>
<li>向ecs添加tasks中的第一个任务并且执行。</li>
<li>从ecs的阻塞队列中取出第一个（队头），如果为null（不为null跳到注释⑤），说明一个任务都还没执行完成，继续添加任务。</li>
<li>如果所有任务都被添加了，阻塞等待任务的执行结果，知道有任一任务执行完成。</li>
<li>如果取到了某个任务的执行结果，直接返回。</li>
<li>取消所有还没执行的任务。</li>
</ol>
</li>
</ul>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>它是线程池的具体实现。</p>
<p>分析它的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* corePoolSize: 核心线程数</span></span><br><span class="line"><span class="comment">* maximumPoolSize: 线程池最大允许线程数</span></span><br><span class="line"><span class="comment">* keepAliveTime, unit: 等待时长 （指的是非 CoreThread 的 线程在空闲情况下的存活时间）</span></span><br><span class="line"><span class="comment">* workQueue: 任务队列</span></span><br><span class="line"><span class="comment">* threadFactory: 线程创建工厂</span></span><br><span class="line"><span class="comment">* handler: 任务拒绝决策</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>以下是线程池的主要流程图：<br><img src="/images/20191027/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86flow1.png" alt="线程池flow1"><br><img src="/images/20191027/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E7%90%86flow2.png" alt="线程池flow2"><br>ThreadPoolExecutor执行<code>execute()</code>分4种情况：</p>
<ol>
<li>若当前运行的线程少于 corePoolSize,则创建新线程来执行任务(执行这一步需要获取全局锁)</li>
<li>若运行的线程多于或等于 corePoolSize,则将任务加入 BlockingQueue</li>
<li>若无法将任务加入 BlockingQueue,则创建新的线程来处理任务(执行这一步需要获取全局锁)</li>
<li>若创建新线程将使当前运行的线程超出 maximumPoolSize,任务将被拒绝,并调用 <code>RejectedExecutionHandler.rejectedExecution()</code></li>
</ol>
<p>采取上述思路,是为了在执行 <code>execute()</code>时,尽可能避免获取全局锁。在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize),几乎所有的execute()方法调用都是执行步骤2,而步骤2不需要获取全局锁。</p>
<blockquote>
<p>注意：<br>在线程池里头，核心线程在处理完当前任务后，会去取任务队列中队头的任务去执行。所以，如果核心线程全部都在跑耗时任务，那么，只有一种情况下，进来的新任务能够被执行：</p>
<p>答： 核心线程全部在工作，并且此时任务队列已经是满人状态，并且此时当前线程数仍然小于线程池的最大线程数，那么，就会创建新线程来处理这个新进来的任务。</p>
<p>另外，线程只要能够进入核心线程池，那他的身份就会是核心线程。所以不会有特别的核心线程的创建逻辑，线程池里头的每个线程的自身结构是一致的。</p>
</blockquote>
<h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><ul>
<li><code>corePoolSize</code>: 必须 &gt;= 0，否则报错</li>
<li><code>maximumPoolSize</code>: 必须 &gt;= 1, 否则报错</li>
<li><code>workQueue</code>：workQueue 的 任务 一定是 Runnable 类型 ，如果是Callable 类型，会在submit内部转换为 Runnable对象</li>
</ul>
<h3 id="线程池的特殊化"><a href="#线程池的特殊化" class="headerlink" title="线程池的特殊化"></a>线程池的特殊化</h3><ol>
<li><code>corePoolSize=maximuPoolSize</code>: 这里我们可以创建一个线程池线程数量固定的任务。</li>
<li><code>maximuPoolSize</code>设置很大(<code>Integer.MAX_VALUE</code>):  我们可以无限制的加入任务。</li>
<li><code>workQueue</code>设置足够大，线程池中的数量不会超过<code>corePoolSize</code>，此时<code>maximumPoolSize</code>参数无效。</li>
<li><code>corePoolSize=0</code>: 线程池一旦空闲（超过时间），线程都将被回收。</li>
<li>通过<code>allowCoreThreadTimeOut</code>方法，我们可以让TimeOut 应用到所有的线程（包括coreThread）。</li>
<li>workQueue的三种实现：<ul>
<li><code>SynchronousQueue</code>：【直连队列】一个空队列，不会保存提交的task（添加操作必须等待另外的移除操作），队列不会存储任何任务。当有任务提交线程试图向队列中添加待执行任务时会被阻塞，直到有任务处理线程试图从队列中获取待执行任务时会与阻塞状态中的任务提交线程发生直接联系，由任务提交线程把任务直接交给任务执行线程。吞吐量通常高于<code>LinkedBlockingQueue</code>，<code>Executors.newCachedThreadPool</code>使用此队列。</li>
<li><code>ArrayBlockingQueue</code>：【有界队列】数组实现的队列，可以指定队列的长度。</li>
<li><code>LinkedBlockingQueue</code>：【无界队列】链表实现的队列，所以理论上可以无限大，也可以指定链表长度。当使用无界队列时，线程池中的线程最多只能达到核心线程数就不会再增长了，最大线程数maximumPoolSize参数不会产生作用。此队列采用FIFO排序元素，吞吐量通常高于<code>ArrayBlockingQueue</code>，静态工厂方法<code>Executors.newFixedThreadPool()</code>采用此队列。</li>
</ul>
</li>
<li>RejectedExecutionHandler的四种实现：<ul>
<li>【default】<code>AbortPolicy</code>：直接抛出RejectedExecutionException，这是线程池中的默认实现。</li>
<li><code>DiscardPolicy</code>：什么都不做</li>
<li><code>DiscardOldestPolicy</code>：丢弃workQueue队头任务，加入新任务</li>
<li><code>CallerRunsPolicy</code>：直接在调用者的线程执行任务(直接绕过线程线程池，执行任务的<code>run()</code>方法)</li>
</ul>
</li>
</ol>
<h3 id="RejectedExecutionHandler有哪几种友好的拒绝策略？"><a href="#RejectedExecutionHandler有哪几种友好的拒绝策略？" class="headerlink" title="RejectedExecutionHandler有哪几种友好的拒绝策略？"></a>RejectedExecutionHandler有哪几种友好的拒绝策略？</h3><ol>
<li>save DB, 削峰填谷，等空闲时提取出来执行</li>
<li>转向某个提示页面</li>
<li>打印日志</li>
</ol>
<h3 id="ThreadFactory给线程起个好名字"><a href="#ThreadFactory给线程起个好名字" class="headerlink" title="ThreadFactory给线程起个好名字"></a>ThreadFactory给线程起个好名字</h3><p>开源框架guava提供ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledExecutorService-接口"><a href="#ScheduledExecutorService-接口" class="headerlink" title="ScheduledExecutorService 接口"></a>ScheduledExecutorService 接口</h2><p>继承自<code>ExecutorService</code>接口，多了一个功能：可以定时执行任务（执行一次）和定期执行任务（重复执行）。</p>
<p>方法：</p>
<ul>
<li><code>public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);</code>: 这个方法用于定时执行任务command，延迟的时间为delay*unit，它返回一个ScheduledFuture对象用于获取执行结果或者剩余延时，调用Future.get()方法将阻塞当前线程最后返回null。</li>
<li><code>public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);</code>：同上，不同的是，调用Future.get()方法将返回执行的结果，而不是null。</li>
<li><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period,TimeUnit unit);</code>: 重复执行任务command，第一次执行时间为initialDelay延迟后，以后的执行时间将在initialDelay + period * n，unit代表时间单位，值得注意的是，如果某次执行出现异常，后面该任务就不会再执行。或者通过返回对象Future手动取消，后面也将不再执行。</li>
<li><code>public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay, TimeUnit unit);</code>: 效果同上，不同点：如果command耗时为 y，则上面的计算公式为initialDelay + period * n + y，也就是说，它的定时时间会加上任务耗时，而上面的方法则是一个固定的频率，不会算上任务执行时间！</li>
</ul>
<h2 id="ScheduledThreadPoolExecutor类"><a href="#ScheduledThreadPoolExecutor类" class="headerlink" title="ScheduledThreadPoolExecutor类"></a>ScheduledThreadPoolExecutor类</h2><p>继承自ThreadPoolExecutor类，实现了ScheduledExecutorService接口。</p>
<p>它的构造器比它的父类构造器简洁，主要因为它的任务队列workQueue是默认的（DelayedWorkQueue），并且最大的线程数为最大值。</p>
<h3 id="关于DelayWorkQueue"><a href="#关于DelayWorkQueue" class="headerlink" title="关于DelayWorkQueue"></a>关于<code>DelayWorkQueue</code></h3><p>它内部使用数组维护了一个二叉树，提高了任务查找时间，而之所以ScheduledThreadPoolExecutor能够实现延时的关键也在于DelayedWorkQueue的<code>take()</code>方法：</p>
<ol>
<li>工作线程调用take方法获取剩余任务。</li>
<li>检查这个任务是否已经到了执行时间。</li>
<li>未到执行时间，await等待。</li>
<li>自己唤醒，进入循环再次计算时间。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK9~JDK11特性简读</title>
    <url>/JDK9-JDK11%E7%89%B9%E6%80%A7%E7%AE%80%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>JDK11 发布时间：2018/9/25。Java 11和2017年9月份发布的Java 9以及 2018年3月份发布的Java 10相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，Oracle表示会对Java 11提供大力支持，这一支持将会持续至2026年9月。这是据 Java 8 以后支持的首个长期版本。</p>
</blockquote><a id="more"></a>
<h1 id="新特性-（JDK-9-11）"><a href="#新特性-（JDK-9-11）" class="headerlink" title="新特性 （JDK 9-11）"></a>新特性 （JDK 9-11）</h1><h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var javaStack = &quot;hello&quot;;</span><br><span class="line">System.out.println(javaStack);</span><br></pre></td></tr></table></figure>
<p>局部变量类型推断就是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型，如上面的 String 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var javaStack = &quot;hello&quot;;</span><br><span class="line">相当于</span><br><span class="line">String javaStack = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="字符串增强"><a href="#字符串增强" class="headerlink" title="字符串增强"></a>字符串增强</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 判断字符串是否为空白</span><br><span class="line"></span><br><span class="line">&quot; &quot;.isBlank();                  //true</span><br><span class="line"></span><br><span class="line">// 去除首尾空格</span><br><span class="line"></span><br><span class="line">&quot; Javastack &quot;.strip();          //&quot;Javastack&quot;</span><br><span class="line"></span><br><span class="line">// 去除尾部空格</span><br><span class="line"></span><br><span class="line">&quot; Javastack &quot;.stripTrailing();  // &quot; Javastack&quot;</span><br><span class="line"></span><br><span class="line">// 去除首部空格</span><br><span class="line"></span><br><span class="line">&quot; Javastack &quot;.stripLeading();   // &quot;Javastack &quot;</span><br><span class="line"></span><br><span class="line">// 复制字符串</span><br><span class="line"></span><br><span class="line">&quot;Java&quot;.repeat(3);               //&quot;JavaJavaJava&quot;</span><br><span class="line"></span><br><span class="line">// 行数统计</span><br><span class="line">&quot;A\nB\nC&quot;.lines().count();      // 3</span><br></pre></td></tr></table></figure>
<h3 id="集合加强-不可变集合"><a href="#集合加强-不可变集合" class="headerlink" title="集合加强(不可变集合)"></a>集合加强(不可变集合)</h3><blockquote>
<p>Java 9 开始，Jdk里面为集合（List/Set/Map）都添加了of和copyOf方法，这两个方法都用来创建<strong>不可变集合</strong>。</p>
</blockquote>
<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list = List.of(&quot;java&quot;, &quot;Python&quot;, &quot;C&quot;);</span><br><span class="line">var copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);   // true</span><br></pre></td></tr></table></figure>
<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var list = new ArrayList&lt;String&gt;();</span><br><span class="line">var copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);   // false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>copyOf方法会先判断来源集合是否是<code>AbstractImmutableList</code>类型的，如果是，直接返回，否则，会自动调用<code>of</code>创建一个新集合。</p>
</blockquote>
<p>例子2中，<code>list</code>不属于不可变 <code>AbstractImmutableList</code> 类的子类，所以<code>copyOf</code>方法又创建了一个新的实例。</p>
<blockquote>
<p>注意：使用 <code>of</code> 和 <code>copyOf</code> 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 <code>java.lang.UnsupportedOperationException</code> 异常。</p>
</blockquote>
<h3 id="Stream加强"><a href="#Stream加强" class="headerlink" title="Stream加强"></a>Stream加强</h3><p>Stream 是JDK 8 的新特性，而 JDK 9 开始对Stream新增加了以下4个方法：</p>
<ol>
<li><p>增加单个参数构造方法，可为null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.ofNullable(null).count();</span><br></pre></td></tr></table></figure></li>
<li><p>takeWhile 和 DropWhile  两个截止执行方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.of(1,2,3,2,1)</span><br><span class="line">  .takeWhile(n -&gt; n &lt; 3)</span><br><span class="line">  .collect(Collectors.toList()); // [1,2]</span><br></pre></td></tr></table></figure>
<p>以上例子，从读到’3’时不满足条件，就已经截止执行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.of(1,2,3,2,1)</span><br><span class="line">  .dropWhile(n -&gt; n &lt; 3)</span><br><span class="line">  .collect(Collectors.toList()); // [3,2,1]</span><br></pre></td></tr></table></figure>
<p>第二个例子，就是从 <code>n &lt; 3</code> 不成立的那一刻开始算。</p>
</li>
<li><p>iterate重载</p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</p>
</li>
</ol>
<h3 id="Optional-加强"><a href="#Optional-加强" class="headerlink" title="Optional 加强"></a>Optional 加强</h3><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional.of(&quot;javaStack&quot;).orElseThrow();    // javaStack</span><br><span class="line">Optional.of(&quot;javaStack&quot;).stream().count(); // 1</span><br><span class="line">Optional.ofNullable(null)</span><br><span class="line">   .or(() -&gt; Optional.of(&quot;javaStack&quot;))</span><br><span class="line">   .get();                                // javaStack</span><br></pre></td></tr></table></figure>
<h3 id="InputStream-加强"><a href="#InputStream-加强" class="headerlink" title="InputStream 加强"></a>InputStream 加强</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// transferTo，可以用来将数据直接传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法</span><br><span class="line">var classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">var inputStream = classLoader.getResourceAsStream(&quot;javaStack.txt&quot;);</span><br><span class="line">var newFile = File.createTempFile(&quot;javaStack2&quot;, &quot;txt&quot;);</span><br><span class="line">try (var outputStream = new FileOutputStream(newFile)) &#123;</span><br><span class="line">   // inputStream 读取数据，然后丢到新文件中</span><br><span class="line">   inputStream.transferTo(outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTTP-Client-API-代替Apache的HttpClient的节奏"><a href="#HTTP-Client-API-代替Apache的HttpClient的节奏" class="headerlink" title="HTTP Client API (代替Apache的HttpClient的节奏)"></a>HTTP Client API (代替Apache的HttpClient的节奏)</h3><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的孵化 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 <code>java.net</code>包中找到这个 API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var request = HttpRequest.newBuilder()</span><br><span class="line">    .uri(URI.create(&quot;https://javastack.cn&quot;))</span><br><span class="line">    .GET()</span><br><span class="line">    .build();</span><br><span class="line">    </span><br><span class="line">var client = HttpClient.newHttpClient();</span><br><span class="line"></span><br><span class="line">// 同步</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br><span class="line"></span><br><span class="line">// 异步</span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">    .thenApply(HttpResponse::body)</span><br><span class="line">    .thenAccept(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="化繁为简，一个命令编译运行源码"><a href="#化繁为简，一个命令编译运行源码" class="headerlink" title="化繁为简，一个命令编译运行源码"></a>化繁为简，一个命令编译运行源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译</span><br><span class="line">javac Demo.java</span><br><span class="line"></span><br><span class="line">// 运行</span><br><span class="line">java Demo</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// JDK 11</span><br><span class="line">java Demo.java</span><br></pre></td></tr></table></figure>
<h1 id="更多新特性"><a href="#更多新特性" class="headerlink" title="更多新特性"></a>更多新特性</h1><blockquote>
<p>这是官方发布的 Java 11 包含的所有新特性，提供17个JEP（JDK Enhancement Proposal 特性增强提议）：</p>
<p>This release includes seventeen features:</p>
<ul>
<li>181: Nest- Based Access Control</li>
<li>309: Dynamic Class-File Constants</li>
<li>315: Improve Aarch64 Intrinsics</li>
<li>318: Epsilon: A No-Op Garbage Collector (Experimental)</li>
<li>320: Remove the Java EE and CORBA Modules</li>
<li>321: HTTP Client (Standard)</li>
<li>323: Local-Variable Syntax for Lambda Parameters</li>
<li>324: Key Agreement with Curve25519 and Curve448</li>
<li>327: Unicode 10328: Flight Recorder</li>
<li>329: ChaCha20 &amp; Poly1305 Cryptographic Algorithms</li>
<li>330: Launch single-File Source-Code Programs</li>
<li>331: Low-Overhead Heap Profiling</li>
<li>332: Transport Layer Security (TLS)1.3</li>
<li>333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental)</li>
<li>335: Deprecate the Nashorn JavaScript Engine</li>
<li>336: Deprecate the Pack200 Tools and API</li>
</ul>
<p>along with, of course, hundreds of smaller enhancements and countless bug fixes.</p>
<p>Thanks to everyone who contributed JDK 11, whether by creating features of enhancements, removing old features, fixing bugs, or downloading and testing the early-access builds.</p>
<p>Onward, to JDK 12!</p>
</blockquote>
<h3 id="ZGC-可扩展的低延迟垃圾收集器"><a href="#ZGC-可扩展的低延迟垃圾收集器" class="headerlink" title="ZGC: 可扩展的低延迟垃圾收集器"></a>ZGC: 可扩展的低延迟垃圾收集器</h3><p>ZGC是一款号称可以保证每次GC的停顿时间不超过10MS的垃圾回收器，并且和当前的默认垃圾回收起G1相比，吞吐量下降不超过15%。</p>
<h3 id="psilon：什么事也不做的垃圾回收器"><a href="#psilon：什么事也不做的垃圾回收器" class="headerlink" title="psilon：什么事也不做的垃圾回收器"></a>psilon：什么事也不做的垃圾回收器</h3><p>Java 11还加入了一个比较特殊的垃圾回收器——Epsilon，该垃圾收集器被称为“no-op”收集器，将处理内存分配而不实施任何实际的内存回收机制。 也就是说，这是一款不做垃圾回收的垃圾回收器。这个垃圾回收器看起来并没什么用，<u>主要可以用来进行性能测试、内存压力测试等，Epsilon GC可以作为度量其他垃圾回收器性能的对照组</u>。大神Martijn说，Epsilon GC至少能够帮助理解GC的接口，有助于成就一个更加模块化的JVM。</p>
<h3 id="增强var用法"><a href="#增强var用法" class="headerlink" title="增强var用法"></a>增强var用法</h3><p>Java 10中增加了本地变量类型推断的特性，可以使用var来定义局部变量。尽管这一特性被很多人诟病，但是并不影响Java继续增强他的用法，在Java 11中，var可以用来作为Lambda表达式的局部变量声明。</p>
<h3 id="移除Java-EE和CORBA模块"><a href="#移除Java-EE和CORBA模块" class="headerlink" title="移除Java EE和CORBA模块"></a>移除Java EE和CORBA模块</h3><p>早在发布Java SE 9的时候，Java就表示过，会在未来版本中将Java EE和CORBA模块移除，而这样举动终于在Java 11中实施。终于去除了Java EE和CORBA模块。</p>
<h3 id="HTTP客户端进一步升级"><a href="#HTTP客户端进一步升级" class="headerlink" title="HTTP客户端进一步升级"></a>HTTP客户端进一步升级</h3><p>JDK 9 中就已对 HTTP Client API 进行标准化，然后通过JEP 110，在 JDK 10 中进行了更新。在本次的Java 11的更新列表中，由以JEP 321进行进一步升级。该API通过CompleteableFutures提供非阻塞请求和响应语义，可以联合使用以触发相应的动作。 JDK 11完全重写了该功能。现在，在用户层请求发布者和响应发布者与底层套接字之间追踪数据流更容易了，这降低了复杂性，并最大程度上提高了HTTP / 1和HTTP / 2之间的重用的可能性。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 8</title>
    <url>/JDK-8/</url>
    <content><![CDATA[<blockquote>
<p>总结 JDK8 的所有新特性，在教你如何使用并深入学习JDK8。</p>
</blockquote>
<a id="more"></a>

<h1 id="新特性总览"><a href="#新特性总览" class="headerlink" title="新特性总览"></a>新特性总览</h1><ul>
<li>lambda表达式</li>
<li>Stream操作数组</li>
<li>Optional取代null</li>
<li>简洁的并发编程</li>
<li>LocalDateTime新的时间API</li>
</ul>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul>
<li>概念：Lambda表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应其中的Lambda抽象（lambda abstraction），是一个匿名函数，既没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义的不同）。你也可以理解为，简洁的表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出异常的列表。</li>
<li>作用：既然是匿名函数，那就类比于匿名内部类的用法咯，哪些地方，会用到一些代码量大但实际逻辑不算复杂的方法调用，就可以用到它。<blockquote>
<p>什么是函数式接口？</p>
<p>答：仅仅只有一个抽象方法的接口。</p>
</blockquote>
</li>
<li>语法：<ul>
<li><code>() -&gt; 表达式</code></li>
<li><code>() -&gt; {语句;}</code></li>
<li><code>() -&gt; 对象</code></li>
<li><code>(Class)() -&gt; {语句;}</code>【指定对象类型】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void doSomething(Runnable r) &#123; r.run(); &#125;</span><br><span class="line">public static void doSomething(Task a) &#123; a.execute(); &#125;</span><br><span class="line">....</span><br><span class="line">doSomething(() -&gt; System.out.println(&quot;DDDD&quot;));</span><br><span class="line">// 为了避免隐晦的方法调用，尝试显式地类型转换</span><br><span class="line">doSomething((Runnable)() -&gt; System.out.println(&quot;DDDD&quot;));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用场景（很多特殊场景都包含在内）<br>总的来说，只有在接受函数式接口的地方才可以使用Lambda表达式。<pre class="mermaid">  graph LR
A[如Comparable和Runnable和Callable等函数式接口]
B[自定义的只有一个方法的接口实现]
E[jdk8自带的一些常用的函数式接口]
E1[Predicate]
E2[Function T,R]
E3[Supplier]
E4[Consumer]
E5[BinaryOperatory]
C[Lambda]
A --> C
B --> C
E1 --- E
E2 --- E
E3 --- E
E4 --- E
E5 --- E
E --> C</pre></li>
<li>一些Jdk8的lambda语法糖：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lambda:(Apple a) -&gt; a.getWeight() </span><br><span class="line">方法引用:Apple::getWeight</span><br><span class="line"></span><br><span class="line">Lambda:() -&gt; Thread.currentThread().dumpStack() </span><br><span class="line">方法引用:Thread.currentThread()::dumpStack</span><br><span class="line">  </span><br><span class="line">Lambda:(str, i) -&gt; str.substring(i)</span><br><span class="line">方法引用:String::substring</span><br><span class="line">  </span><br><span class="line">Lambda:(String s) -&gt; System.out.println(s)</span><br><span class="line">方法引用:System.out::println</span><br></pre></td></tr></table></figure></li>
<li>构造函数引用<ul>
<li>无参构造器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple apple = c1.get();</span><br><span class="line">// 等价于</span><br><span class="line">Supplier&lt;Apple&gt; c2 = () -&gt; new Apple();</span><br></pre></td></tr></table></figure></li>
<li>一参构造器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple apple = c1.apply(123);</span><br></pre></td></tr></table></figure></li>
<li>两参构造器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;Integer, String, Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple apple = c2.apply(120, &quot;red&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>简化的数组排序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apples.sort(comparing(Apple::getWeight));</span><br><span class="line">// 其中：</span><br><span class="line">// ArrayList.sort() since：1.2</span><br><span class="line">// Comparator.comparing(Function&lt;Apple, Integer&gt;) since: 1.8</span><br></pre></td></tr></table></figure></li>
<li>更复杂的数组排序<ul>
<li>倒序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apples.sort(Comparator.comparing(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure></li>
<li>多条件排序<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apples.sort(Comparator.comparing(Apple::getWeight).reversed()</span><br><span class="line">            .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Predicate的复合<blockquote>
<p>以下三个基本谓词，可以配合已有的谓词（Predicate），来制造出更加复杂的谓词。</p>
</blockquote>
<ul>
<li>negate：“非”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; predicate) &#123;</span><br><span class="line">    List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    for (T t : list) &#123;</span><br><span class="line">        if (predicate.test(t)) &#123;</span><br><span class="line">            result.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">// 红苹果</span><br><span class="line">Predicate&lt;Apple&gt; redApplePd = a -&gt; &quot;red&quot;.equals(a.getColor());</span><br><span class="line">// 不是红苹果</span><br><span class="line">Predicate&lt;Apple&gt; notRedApplePd = a -&gt; redApplePd.negate();</span><br><span class="line">// 过滤</span><br><span class="line">List&lt;Apple&gt; redApple = filter(rawApples, redApplePd);</span><br><span class="line">List&lt;Apple&gt; notRedApple = filter(rawApples, notRedApplePd);</span><br></pre></td></tr></table></figure></li>
<li>and：“与”<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redHeavyApplePd = ((Predicate&lt;Apple&gt;) apple -&gt; apple.color.equals(&quot;red&quot;)).and(apple -&gt; false);</span><br></pre></td></tr></table></figure></li>
<li>or：“或”（同理）</li>
</ul>
</li>
<li>Function的复合<ul>
<li>andThen<br><code>f.andThen(g)</code>相当于 <code>g(f())</code>，先执行<code>f()</code>，后执行<code>g()</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; dbSelf = x -&gt; x * 2;</span><br><span class="line">Function&lt;Integer, Integer&gt; oppositeNum = x -&gt; -1 * x;</span><br><span class="line">Function&lt;Integer, String&gt; toStr = String::valueOf;</span><br><span class="line">String result = dbSelf.andThen(oppositeNum).andThen(toStr).apply(1); // &quot;-2&quot;</span><br></pre></td></tr></table></figure></li>
<li>compose<br><code>f.compose(g)</code>相当于 <code>f(g())</code>，先执行<code>g()</code>，后执行<code>f()</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, String&gt; toStr = x -&gt; &quot;ToString:&quot; + x;</span><br><span class="line">Function&lt;String, String&gt; split = x -&gt; x.split(&quot;:&quot;)[1];</span><br><span class="line">Function&lt;String, Integer&gt; toInt = Integer::valueOf;</span><br><span class="line">int result = toInt.compose(split.compose(toStr)).apply(123); // 123</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><ul>
<li><p>概念：流是Java API新成员，它允许你以声明性方式处理数据集合。</p>
</li>
<li><p>特点：</p>
<ul>
<li>流水线：类似“链式调用”，一步接一步。</li>
<li>内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>减少for循环</li>
<li>减少数组操作中可能声明的垃圾变量的数量</li>
<li>直观、提高可读性</li>
</ul>
</li>
<li><p>流和集合的区别：</p>
<ul>
<li>类似于看视频，无论点到视频的哪一段，它都能很快加载出来，这就是流。而集合相当于我要把整部电影down下来，才能点哪看哪。</li>
<li>集合是内存中的数据结构，它包含数据结构中目前所有的值，集合中每个元素都需要事先计算好，才被放入集合。</li>
<li>流是在概念上固定的数据结构，其元素时按需计算的（懒加载）。需要多少就给多少。换一个角度，流像是一个延迟创建的集合：只有在消费者要求的时候才会生成值。</li>
</ul>
</li>
<li><p>看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Apple&gt; filterApple(List&lt;Apple&gt; apples, Predicate&lt;Apple&gt; criteria) &#123;</span><br><span class="line">      List&lt;Apple&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">      apples.forEach(apple -&gt; &#123;</span><br><span class="line">          if (criteria.test(apple)) &#123;</span><br><span class="line">              result.add(apple);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果只用Lambda表达式，那操作数组起来，也还是需要一些for循环的加持。<br>而有了Stream，写起code就简单很多了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; redHeavyApples = apples.stream()</span><br><span class="line">  .filter(apple -&gt; &quot;red&quot;.equals(apple.color))</span><br><span class="line">  .filter(apple -&gt; apple.weight &gt; 120)</span><br><span class="line">  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li><p>相关包、类、方法</p>
<ul>
<li>包：<code>java.util.stream</code></li>
<li>接口：<ul>
<li><code>BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; extends AutoCloseable</code></li>
<li><code>Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt;</code></li>
<li><code>DoubleStream extends BaseStream&lt;Double, DoubleStream&gt;</code></li>
<li><code>IntStream extends BaseStream&lt;Integer, IntStream&gt;</code></li>
<li><code>LongStream extends BaseStream&lt;Long, LongStream&gt;</code></li>
</ul>
</li>
<li>方法：<ul>
<li><code>filter(Predicate&lt;? super T&gt;):Stream&lt;T&gt;</code></li>
<li><code>map(Function&lt;? super T, ? extends R&gt;):Stream&lt;R&gt;</code></li>
<li><code>mapToInt(ToIntFunction&lt;? super T&gt;):LongStream</code></li>
<li><code>mapToDouble(ToDoubleFunction&lt;? super T&gt;):DoubleStream</code></li>
<li><code>mapToLong</code></li>
<li><code>flatMap(Function&lt;? super T, ? super Stream&lt;? extends R&gt;&gt;):Stream&lt;R&gt;</code></li>
<li><code>flatMapToInt()</code></li>
<li><code>flatMapToLong()</code></li>
<li><code>flatMapToDouble()</code></li>
<li><code>distinct():Stream&lt;T&gt;</code></li>
<li><code>sorted():Stream&lt;T&gt;</code></li>
<li><code>sorted(Comparator&lt;? super T&gt;):Stream&lt;T&gt;</code></li>
<li><code>peek(Consumer&lt;? super T&gt;):Stream&lt;T&gt;</code></li>
<li><code>limit(long):Stream&lt;T&gt;</code></li>
<li><code>skip(long):Stream&lt;T&gt;</code></li>
<li><code>forEach(Consumer&lt;? super T&gt;):void</code></li>
<li><code>forEachOrdered()</code></li>
<li><code>toArray():Object[]</code></li>
<li><code>toArray(IntFunction&lt;A[]&gt;):Object[]</code></li>
<li><code>reduce(T, BinaryOperator&lt;T&gt;):T</code></li>
<li><code>reduce(BinaryOperator&lt;T&gt;):Optional&lt;T&gt;</code></li>
<li><code>reduce(U, BiFunction&lt;U, ? super T, U&gt;, BinaryOperator&lt;U&gt;):U</code></li>
<li><code>collect(Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R,R&gt;):R</code></li>
<li><code>collect(Collector&lt;? super T,A,R&gt;):R</code></li>
<li><code>min(Comparator&lt;? super T&gt;):Optional&lt;T&gt;</code></li>
<li><code>max</code></li>
<li><code>count():long</code></li>
<li><code>anyMatch(Predicate&lt;? super T&gt;):boolean</code></li>
<li><code>allMatch</code></li>
<li><code>noneMatch</code></li>
<li><code>findFirst():Optional&lt;T&gt;</code></li>
<li><code>findAny</code></li>
<li><code>builder():Builder&lt;T&gt;</code></li>
<li><code>empty():Stream&lt;T&gt;</code></li>
<li><code>of(T...):Stream&lt;T&gt;</code></li>
<li><code>iterate(T, UnaryOperator&lt;T&gt;):Steram&lt;T&gt;</code></li>
<li><code>generate(Supplier&lt;T&gt;):Stream&lt;T&gt;</code></li>
<li><code>concat(Stream&lt;? extends T&gt;, Stream&lt;? extends T&gt;):Stream&lt;T&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>例子：取重的绿苹果，然后升序排序，取它的重量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; greenHeavyAppleWeight = apples.stream()</span><br><span class="line">      .filter(apple -&gt; apple.weight &gt; 120)</span><br><span class="line">      .filter(apple -&gt; &quot;green&quot;.equals(apple.color))</span><br><span class="line">      .sorted(comparing(Apple::getWeight)) // Comparator.comparing()</span><br><span class="line">      .map(apple -&gt; apple.weight)</span><br><span class="line">      .collect(toList()); // Collectors.toList()</span><br></pre></td></tr></table></figure></li>
<li><p>流只能被消费一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(&quot;Java8&quot;, &quot;Lambdas&quot;, &quot;In&quot;, &quot;Action&quot;);</span><br><span class="line">  Stream&lt;String&gt; s = names.stream();</span><br><span class="line">  s.forEach(System.out::println);</span><br><span class="line">  // 再继续执行一次，则会抛出异常</span><br><span class="line">  s.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>用<code>flatMap()</code>实现流的扁平化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; streamOfWords = Arrays.stream(words);</span><br><span class="line"></span><br><span class="line">// 没有打平，是两个 String[]，我需要两个嵌套for 循环来打印内容</span><br><span class="line">List&lt;String[]&gt; a = streamOfWords.map(w -&gt; w.split(&quot;&quot;)).collect(toList());</span><br><span class="line">for (String[] itemStrings: a) &#123;</span><br><span class="line">    System.out.println(&quot;item.length: &quot; + itemStrings.length);</span><br><span class="line">    for (String item: itemStrings) &#123;</span><br><span class="line">        System.out.print(item);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有打平，出来的是两个String[]，我需要两个嵌套for 循环来打印内容。而如果用flatMap：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; streamOfWords = Arrays.stream(words);</span><br><span class="line"></span><br><span class="line">// 打平，一个for循环就搞定</span><br><span class="line">List&lt;String&gt; chars = streamOfWords</span><br><span class="line">        .map(w -&gt; w.split(&quot;&quot;))</span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .collect(toList());</span><br><span class="line">for (String item: chars) &#123;</span><br><span class="line">    System.out.print(item + &quot;-&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打平之后，直接操作一个数组就好。</p>
</li>
<li><p>例子：求最大最小值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(2, 5, 3, 4, 1, 6, 3, 5);</span><br><span class="line">// way 1</span><br><span class="line">Integer max = numbers.stream().max(Integer::compareTo).orElse(null);</span><br><span class="line">// way 2</span><br><span class="line">max = numbers.stream().reduce(Integer::max).orElse(null);</span><br></pre></td></tr></table></figure></li>
<li><p>原始类型流的特化（Stream转IntStream/LongStream/DoubleStream）</p>
<blockquote>
<p>作用：直接特化为原始类型：int、long、double，避免暗含的装箱成本。以及，有了一些额外的计算方法。</p>
</blockquote>
<ul>
<li>映射到数值流：<code>mapToInt/mapToLong/mapToDouble</code></li>
<li>转回对象流：<code>boxed</code></li>
</ul>
</li>
<li><p>特化流的一下额外方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获得 1到100 的所有偶数</span><br><span class="line">IntStream.rangeClosed(1, 100).filter(num -&gt; num%2 == 0).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li><p>构建流</p>
<ul>
<li>方式一：由值创建流<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;Java8&quot;, &quot;Lambda&quot;, &quot;In&quot;);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>方式二：由数组创建流<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] nums = &#123;2,4,6,7,8,12&#125;;</span><br><span class="line">int sum = Arrays.stream(nums).sum();</span><br></pre></td></tr></table></figure></li>
<li>方式三：由集合创建流<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(1,2,3,4,5);</span><br><span class="line">Stream&lt;Integer&gt; numStream = nums.stream();</span><br><span class="line">Stream&lt;Integer&gt; parallelStream = nums.parallelStream();</span><br></pre></td></tr></table></figure></li>
<li>方式四：文件 + NIO 创建流<blockquote>
<p>利用 <code>java.nio.file.Files</code>中的一些静态方法（静态方法 since JDK1.8）都返回一个流。<code>Files</code>since JDK1.7</p>
<p>一个很有用的方法是 <code>Files.lines</code> ，它会返回一个由指定文件中的各行构成的字符串流。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long uniqueWords;</span><br><span class="line">try (Stream&lt;String&gt; lines = Files.lines(Paths.get(ClassLoader.getSystemResource(&quot;data.txt&quot;).toURI()),</span><br><span class="line">        Charset.defaultCharset())) &#123;</span><br><span class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(&quot; &quot;)))</span><br><span class="line">            .distinct()</span><br><span class="line">            .count();</span><br><span class="line">    System.out.println(&quot;uniqueWords:&quot; + uniqueWords);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.fillInStackTrace();</span><br><span class="line">&#125; catch (URISyntaxException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式五：由函数生成流<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下两个操作，可以创建“无限流”，一般配合limit 使用</span><br><span class="line">Stream.iterate(&lt;初始值&gt;, &lt;值的变化函数&gt;)</span><br><span class="line">Stream.generate(Supplier&lt;? extends Object&gt; s)</span><br></pre></td></tr></table></figure>
不像从固定集合创建的流那样有固定大小的流。由 iterate和 generate 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 迭代：每次返回前一个元素加2的值</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2)</span><br><span class="line">    .limit(10)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 生成：接收一个Supplier类型的函数（有出无入的函数）</span><br><span class="line">Stream.generate(Math::random)</span><br><span class="line">    .limit(5)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
看下面这个例子，对比Lambda表达式（匿名函数）和匿名内部类：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// lambda</span><br><span class="line">IntStream twos = IntStream.generate(() -&gt; 2);</span><br><span class="line">// 匿名内部类</span><br><span class="line">IntStream twos = IntStream.generate(new IntSupplier() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int getAsInt() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
如果这个<code>IntSupplier</code>中不存在成员变量，那么，两者等价。总的来说，匿名内部类更加灵活，而且其output值不一定唯一不变，较为灵活。</li>
</ul>
</li>
<li><p>收集器的用法</p>
<ul>
<li><p>接口：<code>java.util.stream.Collector</code></p>
</li>
<li><p>作用：对<code>Stream</code>的处理结果做收集。</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>分组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = Arrays.asList(</span><br><span class="line">      new Apple(130, &quot;red&quot;),</span><br><span class="line">      new Apple(22, &quot;red&quot;),</span><br><span class="line">      new Apple(60, &quot;green&quot;),</span><br><span class="line">      new Apple(162, &quot;green&quot;),</span><br><span class="line">      new Apple(126, &quot;green&quot;),</span><br><span class="line">      new Apple(142, &quot;green&quot;),</span><br><span class="line">      new Apple(117, &quot;green&quot;)</span><br><span class="line">);</span><br><span class="line">// 根据颜色分组</span><br><span class="line">Map&lt;String, List&lt;Apple&gt;&gt; colorAppleMap = apples.stream().collect(groupingBy(apple -&gt; apple.color));</span><br></pre></td></tr></table></figure></li>
<li><p>多级分组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;Dish.CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</span><br><span class="line">menu.stream().collect(</span><br><span class="line">        groupingBy(Dish::getType,</span><br><span class="line">                groupingBy(dish -&gt; &#123;</span><br><span class="line">                    if (dish.getCalories() &lt;= 400) &#123;</span><br><span class="line">                        return Dish.CaloricLevel.DIET;</span><br><span class="line">                    &#125; else if (dish.getCalories() &lt;= 700) &#123;</span><br><span class="line">                        return Dish.CaloricLevel.NORMAL;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return Dish.CaloricLevel.FAT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>分组的一些配合操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.collect(groupingBy(Dish::getType, summingInt(Dish::getCalories)));</span><br><span class="line">Stream.collect(groupingBy(Dish::getType, mapping(...)));</span><br><span class="line">// 如：</span><br><span class="line">Map&lt;Dish.Type, Set&lt;Dish.CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">menu.stream().collect(</span><br><span class="line">     groupingBy(Dish::getType, mapping(</span><br><span class="line">          dish -&gt; &#123;</span><br><span class="line">              if (dish.getCalories() &lt;= 400) &#123;</span><br><span class="line">                  return Dish.CaloricLevel.DIET;</span><br><span class="line">              &#125; else if (dish.getCalories() &lt;= 700) &#123;</span><br><span class="line">                  return Dish.CaloricLevel.NORMAL;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  return Dish.CaloricLevel.FAT;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          toSet())));</span><br></pre></td></tr></table></figure></li>
<li><p>计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long count = apples.size();</span><br><span class="line">long count = apples.stream().collect(Collectors.counting());</span><br><span class="line">long count = apples.stream().count();</span><br></pre></td></tr></table></figure></li>
<li><p>汇总</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 求和</span><br><span class="line">int totalWeight = apples.stream().collect(summingInt(Apple::getWeight));</span><br><span class="line">totalWeight = apples.stream().mapToInt(Apple::getWeight).sum();</span><br><span class="line"></span><br><span class="line">// 平均数</span><br><span class="line">double avgWeight = apples.stream().collect(averagingDouble(Apple::getWeight));</span><br><span class="line">avgWeight = apples.stream().mapToDouble(Apple::getWeight).average().orElse(-1);</span><br><span class="line"></span><br><span class="line">// 汇总</span><br><span class="line">IntSummaryStatistics appleStatistics = apples.stream().collect(summarizingInt(Apple::getWeight));</span><br><span class="line">System.out.println(appleStatistics.getMax());</span><br><span class="line">System.out.println(appleStatistics.getMin());</span><br><span class="line">System.out.println(appleStatistics.getAverage());</span><br><span class="line">System.out.println(appleStatistics.getCount());</span><br><span class="line">System.out.println(appleStatistics.getSum());</span><br></pre></td></tr></table></figure></li>
<li><p>连接字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] strs = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">String result = Arrays.stream(strs).collect(joining([分隔符]));</span><br></pre></td></tr></table></figure></li>
<li><p>分区</p>
<blockquote>
<p>根据Predicate条件，分成true和false两部分集合。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Apple&gt;&gt; partitionApples = apples.stream().collect(partitioningBy(apple -&gt; &quot;green&quot;.equals(apple.color)));</span><br></pre></td></tr></table></figure>
<p>看似没有什么特点，但是其实和grouping类似，有一个<code>downStream:Collector</code>的一个第二参数，这就厉害了，扩展性很强。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 先划分了素食和非素食，然后，每一类里面，去热量最高的一个。</span><br><span class="line">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian = menu.stream().collect(</span><br><span class="line">  partitioningBy(Dish::isVegetarian, collectingAndThen(</span><br><span class="line">          maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">          Optional::get</span><br><span class="line">  )));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>自定义流（这个就再说咯）</p>
</li>
<li><p>并行流</p>
<blockquote>
<p>相对于<code>stream()</code>，用<code>parallelStream()</code>就能把集合转换为并行流。</p>
</blockquote>
<ul>
<li>概念：并行流就是一个把内容分成多个数据块，并用不同线程分别处理每个数据块的流。</li>
<li>方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">切换为并行流：Stream.parallel()</span><br><span class="line">切换为顺序流：Stream.sequential()</span><br><span class="line">// 注意，谁最后调用，流就apply谁。</span><br></pre></td></tr></table></figure></li>
<li>用并行流之前，要测试性能（如果遇到iterator装包解包等的情况，实际上并行锁会更加慢，能用特化流就尽量用特化流）</li>
<li>Spliterator 定义了并行流如何拆分它要遍历的数据</li>
</ul>
</li>
</ul>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><ul>
<li>class：<code>java.util.Optional</code></li>
<li>作用：解决和避免NPE异常</li>
<li>Optional对象的方法<ul>
<li><code>get()</code>：不推荐使用。如果变量存在，它直接返回封装的变量值，否则就抛出一个NPE或者NoSuchElementException异常。<table>
<thead>
<tr>
<th>Optional方法</th>
<th>调用get()后抛出异常</th>
</tr>
</thead>
<tbody><tr>
<td>Optional.of(null)</td>
<td>java.lang.NullPointerException</td>
</tr>
<tr>
<td>Optional.ofNullable(null)</td>
<td>java.util.NoSuchElementException</td>
</tr>
</tbody></table>
</li>
<li><code>orElse(T other)</code></li>
<li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：<code>orElse</code>的延迟调用版，<code>Supplier</code>方法只有在Optional对象不含值时才执行。<ul>
<li>适用场景：<ul>
<li>创建默认值是耗时的工作。</li>
<li>或者需要十分确定某个方法仅在Optional为空时才调用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p1 = null;</span><br><span class="line">Optional&lt;Person&gt; optP1 = Optional.ofNullable(p1);</span><br><span class="line">Person resultP = optP1.orElseGet(() -&gt; &#123;</span><br><span class="line">    Person p = new Person();</span><br><span class="line">    p.firstName = &quot;Fang&quot;;</span><br><span class="line">    return p;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;resultP.firstName: &quot; + resultP.firstName);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：定制抛出的异常。</li>
<li><code>ifPresent(Consumer&lt;? super T&gt;)</code>：当变量值存在时执行一个作为参数传入的方法，否则不做任何操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">Optional&lt;Person&gt; optP1 = Optional.ofNullable(p1);</span><br><span class="line">optP1.ifPresent(person -&gt; System.out.println(&quot;Haha&quot;));</span><br></pre></td></tr></table></figure></li>
<li><code>filter</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p1 = new Person();</span><br><span class="line">p1.firstName=&quot;Fang&quot;;</span><br><span class="line">p1.lastName=&quot;Hua&quot;;</span><br><span class="line">Person resP = Optional.ofNullable(p1).filter(person -&gt; &quot;Hua&quot;.equals(person.lastName)).orElseGet(() -&gt; &#123;</span><br><span class="line">    Person newP = new Person();</span><br><span class="line">    newP.firstName= &quot;Ming&quot;;</span><br><span class="line">    return newP;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(resP.firstName); // Ming</span><br></pre></td></tr></table></figure></li>
<li>当然，还有一些方法与Stream接口相似，如<code>map</code>和<code>flatMap</code></li>
</ul>
</li>
<li>例子：<ul>
<li>对象嵌套取值<ul>
<li>old<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_optional_1() &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    // 当然从重构角度来看，这里是不对的，我们知道太多这个类内部的东西，是需要重构的</span><br><span class="line">    String name = person.getCar().getInsurance().getName();</span><br><span class="line">&#125;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private Car car;</span><br><span class="line">    public Car getCar() &#123; return car; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Insurance insurance;</span><br><span class="line">    public Insurance getInsurance() &#123; return insurance; &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123; return name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>new<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String getCarInsuranceName(Person person) &#123;</span><br><span class="line">    return Optional.ofNullable(person).flatMap(Person::getCar)</span><br><span class="line">            .flatMap(Car::getInsurance)</span><br><span class="line">            .map(Insurance::getName)</span><br><span class="line">            .orElse(&quot;Unknown&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String sex;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Optional&lt;Car&gt; car = Optional.empty();</span><br><span class="line">    </span><br><span class="line">    public Optional&lt;Car&gt; getCar() &#123;</span><br><span class="line">        return car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public class Car &#123;</span><br><span class="line">    private Optional&lt;Insurance&gt; insurance = Optional.empty();</span><br><span class="line">    </span><br><span class="line">    public Optional&lt;Insurance&gt; getInsurance() &#123;</span><br><span class="line">        return insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public class Insurance &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>封装可能为空的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object value = map.get(&quot;key&quot;);</span><br><span class="line">// 加上 Optional</span><br><span class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(&quot;key&quot;));</span><br><span class="line"></span><br><span class="line">// 如： Map&lt;String, Person&gt; map</span><br><span class="line">String valA = Optional.ofNullable(map.get(&quot;A&quot;)).orElse(new Person()).firstName;</span><br></pre></td></tr></table></figure></li>
<li>异常与Optional 去替代 if-else判断<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Optional&lt;Integer&gt; stringToInt(String s) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return Optional.of(Integer.parseInt(s));</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>两个Optional对象的组合<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Insurance findBestInsurance(Person person, Car car) &#123;</span><br><span class="line">    Insurance insurance = new Insurance();</span><br><span class="line">    insurance.name = person.firstName + person.lastName + &quot; --insurance 01&quot;;</span><br><span class="line">    return insurance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Optional&lt;Insurance&gt; nullSafeFindBestInsurance(Optional&lt;Person&gt; person) &#123;</span><br><span class="line">    if (person.isPresent() &amp;&amp; person.get().getCar().isPresent()) &#123;</span><br><span class="line">        Car car = person.get().getCar().get();</span><br><span class="line">        return Optional.of(findBestInsurance(person.get(), car));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>原理：<ul>
<li>变量存在时，Optional类只是对类简单封装。</li>
<li>变量不存在时，缺失的值会被建模成一个“空”的Optional对象，由方法<code>Optional.empty()</code>返回。</li>
<li><code>Optional.empty()</code>是一个静态工厂方法，</li>
</ul>
</li>
</ul>
<h1 id="函数式编程（Stream-Lambda）"><a href="#函数式编程（Stream-Lambda）" class="headerlink" title="函数式编程（Stream+Lambda）"></a>函数式编程（Stream+Lambda）</h1><blockquote>
<p>函数式编程 VS 命令式编程</p>
<ul>
<li>命令式编程关注怎么做，而函数式编程关注做什么</li>
<li>函数式编程 可读性强，但运行速度不见得更快。</li>
</ul>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="1-for循环取数组最小值"><a href="#1-for循环取数组最小值" class="headerlink" title="1. for循环取数组最小值"></a>1. for循环取数组最小值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] nums = &#123;1,3,-1,6,-20&#125;;</span><br><span class="line">int min = Integer.MAX_VALUE;</span><br><span class="line">for (int i:nums) &#123;</span><br><span class="line">    if(i &lt; min) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int min2 = IntStream.of(nums).parallel().min().getAsInt();</span><br></pre></td></tr></table></figure>

<h4 id="2-接口的实现-匿名内部类转Lambda"><a href="#2-接口的实现-匿名内部类转Lambda" class="headerlink" title="2. 接口的实现/匿名内部类转Lambda"></a>2. 接口的实现/匿名内部类转Lambda</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 接口实现</span><br><span class="line">Object target = new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;新建一个线程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Thread((Runnable) target).start();</span><br><span class="line"></span><br><span class="line">/// 匿名内部类</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;BBB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object target2 = (Runnable)() -&gt; System.out.println(&quot;新建一个线程2&quot;);</span><br><span class="line">Runnable target3 = () -&gt; System.out.println(&quot;新建一个线程3&quot;);</span><br><span class="line">System.out.println(&quot;target2 == target3 ：&quot; + (target2 == target3)); // false</span><br><span class="line">new Thread((Runnable) target2).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;BBB&quot;)).start()</span><br></pre></td></tr></table></figure>
<h4 id="3-Lambda创建自定义接口的实例对象"><a href="#3-Lambda创建自定义接口的实例对象" class="headerlink" title="3. Lambda创建自定义接口的实例对象"></a>3. Lambda创建自定义接口的实例对象</h4><p>必备条件:</p>
<ol>
<li>该接口中只能有一个抽象方法</li>
<li>在接口上加上@FunctionalInterface注解（可选：为了编译器的校验，有这个注解的接口，当存在多个抽象方法时，是会编译报错的。）<blockquote>
<p>JDK8 中，接口中可以定义静态方法和默认方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface1 &#123;</span><br><span class="line">    int doubleNum(int i);</span><br><span class="line"></span><br><span class="line">    default int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int sub(int x, int y) &#123;</span><br><span class="line">        return x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface2 &#123;</span><br><span class="line">    int doubleNum(int i);</span><br><span class="line"></span><br><span class="line">    default int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface3 extends Interface1, Interface2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    default int add(int x, int y) &#123;</span><br><span class="line">        return Interface1.super.add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test_lambda_1() &#123;</span><br><span class="line">    Interface1 i1 = (i) -&gt; i * 2;</span><br><span class="line">    System.out.println(&quot;Interface1.sub(10, 3): &quot; + Interface1.sub(10, 3));</span><br><span class="line">    System.out.println(&quot;i1.add(3，7)：&quot; + i1.add(3, 7));</span><br><span class="line">    System.out.println(&quot;i1.doubleNum(20)：&quot; + i1.doubleNum(20));</span><br><span class="line"></span><br><span class="line">    Interface2 i2 = i -&gt; i * 2;</span><br><span class="line">    Interface3 i3 = (int i) -&gt; i * 2;</span><br><span class="line">    Interface3 i4 = (int i) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;.....&quot;);</span><br><span class="line">        return i * 2;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Lambda与Function"><a href="#4-Lambda与Function" class="headerlink" title="4. Lambda与Function"></a>4. Lambda与Function</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String cityName= &quot;HongKong&quot;;</span><br><span class="line">int stateCode=237;</span><br><span class="line">String street = &quot;东岸村黄皮树下街1号&quot;;</span><br><span class="line"></span><br><span class="line">String locationID = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; locationIDBuilder = locId -&gt; locId + cityName; // Step 1</span><br><span class="line">locationID = locationIDBuilder</span><br><span class="line">        .andThen(locId -&gt; locId + &quot;，区号：&quot; + stateCode) // Step 2</span><br><span class="line">        .andThen(locId -&gt; locId+&quot;，街道：&quot; + street).apply(locationID); // Step 3</span><br><span class="line">System.out.println(&quot;locationID:&quot; + locationID);</span><br></pre></td></tr></table></figure>



</li>
</ol>
<blockquote>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上</p>
</blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer</td>
<td>Consumer&lt; T &gt;</td>
<td>接收T对象，不返回值</td>
</tr>
<tr>
<td>Predicate</td>
<td>Predicate&lt; T &gt;</td>
<td>接收T对象并返回boolean</td>
</tr>
<tr>
<td>Function</td>
<td>Function&lt; T, R &gt;</td>
<td>接收T对象，返回R对象</td>
</tr>
<tr>
<td>Supplier</td>
<td>Supplier&lt; T &gt;</td>
<td>提供T对象（例如工厂），不接收值</td>
</tr>
<tr>
<td>UnaryOperator</td>
<td>UnaryOperator</td>
<td>接收T对象，返回T对象</td>
</tr>
<tr>
<td>BinaryOperator</td>
<td>BinaryOperator</td>
<td>接收两个T对象，返回T对象</td>
</tr>
</tbody></table>
<h1 id="Lambda-与-设计模式"><a href="#Lambda-与-设计模式" class="headerlink" title="Lambda 与 设计模式"></a>Lambda 与 设计模式</h1><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ValidationStrategy &#123;</span><br><span class="line">    boolean execute(String s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class IsAllLowerCase implements ValidationStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean execute(String s) &#123;</span><br><span class="line">        return s.matches(&quot;[a-z]+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class IsNumeric implements ValidationStrategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean execute(String s) &#123;</span><br><span class="line">        return s.matches(&quot;\\d+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Validator &#123;</span><br><span class="line">    private final ValidationStrategy validationStrategy;</span><br><span class="line"></span><br><span class="line">    public Validator(ValidationStrategy validationStrategy) &#123;</span><br><span class="line">        this.validationStrategy = validationStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean validate(String s) &#123;</span><br><span class="line">        return validationStrategy.execute(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常来说，要new一些策略来当参数传。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IsNumeric isNumeric = new IsNumeric();</span><br><span class="line">IsAllLowerCase isAllLowerCase = new IsAllLowerCase();</span><br><span class="line"></span><br><span class="line">Validator validatorA = new Validator(isNumeric);</span><br><span class="line">Validator validatorB = new Validator(isAllLowerCase);</span><br></pre></td></tr></table></figure>
<p>使用lambda，让<code>new</code>尽量少出现在code中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Validator validatorA = new Validator(s -&gt; s.matches(&quot;\\d+&quot;));</span><br><span class="line">Validator validatorB = new Validator(s -&gt; s.matches(&quot;[a-z]+&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="模板模式（抽象类的应用）"><a href="#模板模式（抽象类的应用）" class="headerlink" title="模板模式（抽象类的应用）"></a>模板模式（抽象类的应用）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractOnlineBank &#123;</span><br><span class="line">    public void processCustomer(int id) &#123;</span><br><span class="line">        Customer customer = Database.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract void makeCustomerHappy(Customer customer);</span><br><span class="line"></span><br><span class="line">    static class Customer &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Database &#123;</span><br><span class="line">        static Customer getCustomerWithId(int id) &#123;</span><br><span class="line">            return new Customer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">AbstractOnlineBank bank = new AbstractOnlineBank() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void makeCustomerHappy(Customer customer) &#123;</span><br><span class="line">        System.out.println(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bank.processCustomer(1);</span><br><span class="line">bank.processCustomer(2);</span><br></pre></td></tr></table></figure>
<p>用了Lambda，抽象方法都用不着了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AbstractOnlineBank &#123;</span><br><span class="line">    public void processCustomer(int id, Consumer&lt;Customer&gt; makeCustomerHappy) &#123;</span><br><span class="line">        Customer customer = Database.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy.accept(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Customer &#123;&#125;</span><br><span class="line"></span><br><span class="line">    static class Database &#123;</span><br><span class="line">        static Customer getCustomerWithId(int id) &#123;</span><br><span class="line">            return new Customer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">AbstractOnlineBank bank = new AbstractOnlineBank();</span><br><span class="line">bank.processCustomer(1, customer -&gt; System.out.println(&quot;Hello&quot;));</span><br><span class="line">bank.processCustomer(2, customer -&gt; System.out.println(&quot;Hi&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Observer&#123;</span><br><span class="line">        void inform(String tweet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private static class NYTimes implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inform(String tweet) &#123;</span><br><span class="line">        if (tweet != null &amp;&amp; tweet.contains(&quot;money&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Breaking news in NY!&quot; + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Guardian implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inform(String tweet) &#123;</span><br><span class="line">        if (tweet != null &amp;&amp; tweet.contains(&quot;queen&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;Yet another news in London... &quot; + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class LeMonde implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void inform(String tweet) &#123;</span><br><span class="line">        if(tweet != null &amp;&amp; tweet.contains(&quot;wine&quot;))&#123;</span><br><span class="line">            System.out.println(&quot;Today cheese, wine and news! &quot; + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Subject &#123;</span><br><span class="line">    void registerObserver(Observer o);</span><br><span class="line"></span><br><span class="line">    void notifyObserver(String tweet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Feed implements Subject &#123;</span><br><span class="line">    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerObserver(Observer o) &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObserver(String tweet) &#123;</span><br><span class="line">        observers.forEach(o -&gt; o.inform(tweet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，看到了有一个观察者接口，并且只有一个方法<code>inform</code>，那么，我们是不是就可以少声明这几个实现类呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Feed feedLambda = new Feed();</span><br><span class="line">feedLambda.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">    if (tweet != null &amp;&amp; tweet.contains(&quot;money&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;Breaking news in NY!&quot; + tweet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">feedLambda.registerObserver((String tweet) -&gt; &#123;</span><br><span class="line">    if (tweet != null &amp;&amp; tweet.contains(&quot;queen&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;Yet another news in London... &quot; + tweet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">feedLambda.notifyObserver(&quot;Money money money, give me money!&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static abstract class AbstractProcessingObject&lt;T&gt; &#123;</span><br><span class="line">    protected AbstractProcessingObject&lt;T&gt; successor;</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(AbstractProcessingObject&lt;T&gt; successor) &#123;</span><br><span class="line">        this.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T handle(T input) &#123;</span><br><span class="line">        T r = handleWork(input);</span><br><span class="line">        if (successor != null) &#123;</span><br><span class="line">            return successor.handle(r);</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract T handleWork(T input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一看到，又是抽象类加不同的实现，那就想到是不是可以用匿名函数实现，而这里，我们使用<code>UnaryOperator</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 流程A</span><br><span class="line">UnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;</span><br><span class="line">// 流程B</span><br><span class="line">UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);</span><br><span class="line">// A --&gt; B</span><br><span class="line">Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);</span><br><span class="line">String result2 = pipeline.apply(&quot;Aren&apos;t labdas really sexy?!!&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private interface Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class ProductFactory &#123;</span><br><span class="line">    public static Product createProduct(String name) &#123;</span><br><span class="line">        switch (name) &#123;</span><br><span class="line">            case &quot;loan&quot;:</span><br><span class="line">                return new Loan();</span><br><span class="line">            case &quot;stock&quot;:</span><br><span class="line">                return new Stock();</span><br><span class="line">            case &quot;bond&quot;:</span><br><span class="line">                return new Bond();</span><br><span class="line">            default:</span><br><span class="line">                throw new RuntimeException(&quot;No such product &quot; + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static private class Loan implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static private class Stock implements Product &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static private class Bond implements Product &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单情况下，可以用<code>Supplier</code>去实现引用方法式的构造器调用，并且减少switch。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class ProductFactory &#123;</span><br><span class="line">    private static final Map&lt;String, Supplier&lt;Product&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(&quot;loan&quot;, Loan::new);</span><br><span class="line">        map.put(&quot;stock&quot;, Stock::new);</span><br><span class="line">        map.put(&quot;bond&quot;, Bond::new);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Product createProduct(String name) &#123;</span><br><span class="line">        Supplier&lt;Product&gt; productSupplier = map.get(name);</span><br><span class="line">        if (productSupplier != null) &#123;</span><br><span class="line">            return productSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new RuntimeException(&quot;No such product &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果工厂方法 createProduct 需要接收多个传递给产品构造方法的参数，这种方式的扩展性不是很好。</p>
<h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h1><h3 id="Jdk8开始支持的东西"><a href="#Jdk8开始支持的东西" class="headerlink" title="Jdk8开始支持的东西"></a>Jdk8开始支持的东西</h3><p>Jdk8中的接口支持在声明方法的同时提供实现。</p>
<ul>
<li>Jdk8支持接口中有静态方法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IBoy &#123;</span><br><span class="line">      static String getCompany() &#123;</span><br><span class="line">          return &quot;OOL&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>Jdk8支持接口中有默认方法。【jdk8 新功能】<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// List.sort()</span><br><span class="line">default void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">      Object[] a = this.toArray();</span><br><span class="line">      Arrays.sort(a, (Comparator) c);</span><br><span class="line">      ListIterator&lt;E&gt; i = this.listIterator();</span><br><span class="line">      for (Object e : a) &#123;</span><br><span class="line">          i.next();</span><br><span class="line">          i.set((E) e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">// Collection.stream()</span><br><span class="line">default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">      return StreamSupport.stream(spliterator(), false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>为接口定义默认的方法实现</strong>：默认方法提供了接口的这个方法的默认实现，那么，在使用Lambda匿名地构造接口实现时，就不需要显示重写接口的这个方法，默认方法自动就会继承过来。</li>
<li><strong>新增的接口，只要加上<code>default</code>修饰符，就可以不被显式继承，因此，别的地方的代码是不用改动的！！</strong><blockquote>
<p>看个例子：jdk8以前的<code>Iterator</code>接口，实际上用户是不在乎<code>remove()</code>方法的，而且当时是没有<code>forEachRemaining()</code>方法的，那么，当时的做法，就是每次实现这个接口的时候，都需要显式继承并重写<code>remove()</code>方法，很烦。</p>
<p>到了jdk8， 有了<code>default</code>修饰符，那么，我们不想显式重写的<code>remove()</code>方法就可以不用重写了，然后，jdk8新增了<code>forEachRemaining()</code>方法，也不需要其他实现类再去修改code了，因为它压根不需要你显式重写。</p>
</blockquote>
</li>
</ul>
<h3 id="解决继承链上的冲突的规则"><a href="#解决继承链上的冲突的规则" class="headerlink" title="解决继承链上的冲突的规则"></a>解决继承链上的冲突的规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    default void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello from A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public interface B extends A &#123;</span><br><span class="line">    default void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello from B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class C implements A, B &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 猜猜打印的是什么？</span><br><span class="line">        new C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上问题，就是菱形继承问题，如果父子接口有同名的default方法，那么，以上代码编译不通过。<br>我们需要重写这个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class C implements A, B &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new C().hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">       A.super.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OR</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">       B.super.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OR</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hello() &#123;</span><br><span class="line">       System.out.println(&quot;Hello from C!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组合式异步编程"><a href="#组合式异步编程" class="headerlink" title="组合式异步编程"></a>组合式异步编程</h1><ul>
<li>术语： CompletableFuture</li>
<li>背景：<ul>
<li>Jdk 7 中引入了“并行/合并框架”<blockquote>
<p>注意：并行和并发的区别：</p>
<ul>
<li>并行（parallellism）：<ul>
<li>并行指的是同一个时刻，多个任务确实真的在同时运行。多个任务不抢对方资源。</li>
<li>例子：两个人，各自一边吃水果，吃完就吃pizza。【有多个CPU内核时，每个内核各自不占对方的资源，各做各的事，是可以达到真正意义上的“同时”的。】</li>
</ul>
</li>
<li>并发（concurrency）：<ul>
<li>并发是指在一段时间内宏观上多个程序同时运行。多个任务互相抢资源。</li>
<li>例子：一个人，同时做多件事情。【单核计算器中，是不可能“同时”做两件事的，只是时间片在进程间的切换很快，我们感觉不到而已。】</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li>Jdk 8 中引入了并行流</li>
<li>Jdk 8 中改进了<code>Future</code>接口，并且，新增了<code>CompletableFuture</code>接口。</li>
<li>如果我们现在有一个大的耗时任务要处理，我们可以将其拆分为多个小任务，让其并行处理，最终再将处理的结果统计合并起来， 那么，我们可以结合 并行/合并框架 + 并行流 来快速实现。</li>
</ul>
</li>
</ul>
<h3 id="RecursiveTask（JDK-1-7）"><a href="#RecursiveTask（JDK-1-7）" class="headerlink" title="RecursiveTask（JDK 1.7）"></a>RecursiveTask（JDK 1.7）</h3><p>例子：实现一个100000个自然数的求和。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SumTask extends RecursiveTask&lt;Long&gt; &#123;</span><br><span class="line">public static final int Flag = 50;</span><br><span class="line">long[] arr;</span><br><span class="line">int start;</span><br><span class="line">int end;</span><br><span class="line"></span><br><span class="line">public SumTask(long[] arr, int start, int end) &#123;</span><br><span class="line">    this.arr = arr;</span><br><span class="line">    this.start = start;</span><br><span class="line">    this.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SumTask(long[] arr) &#123;</span><br><span class="line">    this.arr = arr;</span><br><span class="line">    this.start = 0;</span><br><span class="line">    this.end = arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Long compute() &#123;</span><br><span class="line">    // 如果不能进行更小粒度的任务分配</span><br><span class="line">    int length = end - start;</span><br><span class="line">    if (length &lt;= Flag) &#123;</span><br><span class="line">        return processSequentially();</span><br><span class="line">    &#125;</span><br><span class="line">    //分治</span><br><span class="line">    int middle = (start + end) / 2;</span><br><span class="line">    SumTask sumTaskOne = new SumTask(arr, start, middle);</span><br><span class="line">    SumTask sumTaskTwo = new SumTask(arr, middle, end);</span><br><span class="line">    invokeAll(sumTaskOne, sumTaskTwo);</span><br><span class="line">    Long join1 = sumTaskOne.join();</span><br><span class="line">    Long join2 = sumTaskTwo.join();</span><br><span class="line">    return join1 + join2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 小任务具体是做什么</span><br><span class="line">private long processSequentially() &#123;</span><br><span class="line">    long sum = 0;</span><br><span class="line">    for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">  long[] arr = new long[1000];</span><br><span class="line">  for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      arr[i] = (long) (Math.random() * 10 + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  // 线程池（since 1.7）</span><br><span class="line">  ForkJoinPool forkJoinPool = new ForkJoinPool(5);</span><br><span class="line">  ForkJoinTask&lt;Long&gt; forkJoinTask = new SumTask(arr);</span><br><span class="line">  long result = forkJoinPool.invoke(forkJoinTask);</span><br><span class="line">  System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结： 分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果。</li>
</ul>
<h3 id="Spliterator（可分迭代器-JDK-1-8）"><a href="#Spliterator（可分迭代器-JDK-1-8）" class="headerlink" title="Spliterator（可分迭代器 JDK 1.8）"></a>Spliterator（可分迭代器 JDK 1.8）</h3><h4 id="（一）背景"><a href="#（一）背景" class="headerlink" title="（一）背景"></a>（一）背景</h4><ul>
<li>jdk 1.8 加入，和Iterator一样，也用于遍历数据源元素，但它是为了并行执行而设计的。</li>
<li>jdk8已经为集合框架中的所有数据结构提供了一个默认的Spliterator实现。</li>
<li>目的：<ul>
<li>为了优化在并行流做任务处理时的数据源拆分遍历时，使用Iterator的装包和解包的性能开销。</li>
<li>配合并行流更快地遍历和处理元素。</li>
</ul>
</li>
<li>内部方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Spliterator&lt;T&gt; &#123;</span><br><span class="line">  // 如果还有元素要遍历， 返回true</span><br><span class="line">  boolean tryAdvance(Consumer&lt;? super T&gt; action);</span><br><span class="line">  // 把一些元素拆分给第二个Spliterator,不断对 Spliterator 调用 trySplit直到它返回 null ，表明它处理的数据结构不能再分割</span><br><span class="line">  Spliterator&lt;T&gt; trySplit();</span><br><span class="line">  // 估计剩下多少元素要遍历</span><br><span class="line">  long estimateSize();</span><br><span class="line">  // 用于影响开分过程的配置参数</span><br><span class="line">  int characteristics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>延迟绑定的Spliterator：Spliterator可以在第一次遍历、第一次拆分或第一次查询估计大小时绑定元素的数据源，而不是在创建时就绑定。这种情况下，它称为延迟绑定（late-binding）的 Spliterator 。<h4 id="（二）例子"><a href="#（二）例子" class="headerlink" title="（二）例子"></a>（二）例子</h4>例子：一个自定义的并行迭代器，用于处理单词数量统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 首先，我们有一个英文句子，我们要统计它的单词数量</span><br><span class="line">public static final String SENTENCE =</span><br><span class="line">        &quot; Nel   mezzo del cammin  di nostra  vita &quot; +</span><br><span class="line">                &quot;mi  ritrovai in una  selva oscura&quot; +</span><br><span class="line">                &quot; che la  dritta via era   smarrita &quot;;</span><br></pre></td></tr></table></figure></li>
<li>方法一：通常手段，写一个方法，直接实现统计逻辑<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int countWords1(String s) &#123;</span><br><span class="line">      int counter = 0;</span><br><span class="line">      boolean lastSpace = true;</span><br><span class="line">      for (char c : s.toCharArray()) &#123;</span><br><span class="line">          if (Character.isWhitespace(c)) &#123;</span><br><span class="line">              lastSpace = true;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              if (lastSpace) &#123;</span><br><span class="line">                  counter ++;</span><br><span class="line">              &#125;</span><br><span class="line">              lastSpace = Character.isWhitespace(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return counter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>方法二：利用jdk8 stream的函数声明式来简化代码，但是要实现辅助对象了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class WordCounter &#123;</span><br><span class="line">      private final int counter;</span><br><span class="line">      private final boolean lastSpace;</span><br><span class="line"></span><br><span class="line">      public WordCounter(int counter, boolean lastSpace) &#123;</span><br><span class="line">          this.counter = counter;</span><br><span class="line">          this.lastSpace = lastSpace;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 如何改变WordCounter的属性状态</span><br><span class="line">      public WordCounter accumulate(Character c) &#123;</span><br><span class="line">          if (Character.isWhitespace(c)) &#123;</span><br><span class="line">              return lastSpace ? this : new WordCounter(counter, true);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return lastSpace ? new WordCounter(counter + 1, false):this;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 调用此方法时，会把两个子counter的部分结果进行汇总。</span><br><span class="line">      // 其实就是 把内部计数器相加</span><br><span class="line">      public WordCounter combine(WordCounter wordCounter) &#123;</span><br><span class="line">          return new WordCounter(counter + wordCounter.counter, wordCounter.lastSpace);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public int getCounter() &#123;</span><br><span class="line">          return counter;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
实现了辅助对象后，实现一个传stream处理的方法，去调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int countWords2(Stream&lt;Character&gt; stream) &#123;</span><br><span class="line">      WordCounter wordCounter = stream.reduce(new WordCounter(0, true),WordCounter::accumulate, WordCounter::combine);</span><br><span class="line">      return wordCounter.getCounter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
用以上这种方式，就只能实现串行的处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_2() &#123;</span><br><span class="line">     Stream&lt;Character&gt; stream = IntStream.range(0, SENTENCE.length())</span><br><span class="line">            .mapToObj(SENTENCE::charAt);</span><br><span class="line">    System.out.println(&quot;Found &quot; + countWords2(stream) + &quot; words&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方法三：使用jdk8中的可分迭代器，模拟jdk7的拆分/合并模式去实现并行迭代处理过程：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WordCounterSpliterator implements Spliterator&lt;Character&gt; &#123;</span><br><span class="line">      private final String string;</span><br><span class="line">      private int currentChar = 0;</span><br><span class="line">  </span><br><span class="line">      public WordCounterSpliterator(String string) &#123;</span><br><span class="line">          this.string = string;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 把String中当前位置的char 传给 Consumer，并让其位置+1，</span><br><span class="line">       * 作为参数传递的Consumer是一个java内部类，在遍历流时将要处理的char传给一系列要对其执行的函数。</span><br><span class="line">       * 这里只有一个归约函数，即 WordCounter 类的 accumulate方法。</span><br><span class="line">       * 如果新的指针位置小于 String 的总长，且还有要遍历的 Character ，则tryAdvance 返回 true 。</span><br><span class="line">       */</span><br><span class="line">      @Override</span><br><span class="line">      public boolean tryAdvance(Consumer&lt;? super Character&gt; action) &#123;</span><br><span class="line">          action.accept(string.charAt(currentChar++));</span><br><span class="line">          return currentChar &lt; string.length();</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public Spliterator&lt;Character&gt; trySplit() &#123;</span><br><span class="line">          // 像 RecursiveTask 的 compute 方法一样（分支/合并框架的使用方式）</span><br><span class="line">  </span><br><span class="line">          int currentSize = string.length() - currentChar;</span><br><span class="line">  </span><br><span class="line">          // 定义不再拆分的界限（不断拆分，直到返回null）</span><br><span class="line">          if (currentSize &lt; 10) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">          for (int splitPos = currentSize / 2 + currentChar;</span><br><span class="line">               splitPos &lt; string.length(); splitPos++) &#123;</span><br><span class="line">              if (Character.isWhitespace(string.charAt(splitPos))) &#123;</span><br><span class="line">                  // 类似RecursiveTask那样，递归拆分</span><br><span class="line">                  Spliterator&lt;Character&gt; spliterator =</span><br><span class="line">                          new WordCounterSpliterator(string.substring(currentChar,</span><br><span class="line">                                  splitPos));</span><br><span class="line">                  currentChar = splitPos;</span><br><span class="line">                  return spliterator;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public long estimateSize() &#123;</span><br><span class="line">          return string.length() - currentChar;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      @Override</span><br><span class="line">      public int characteristics() &#123;</span><br><span class="line">          return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有了自定义的可分迭代器，我们就可以用并行的处理方式了：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_3() &#123;</span><br><span class="line">      Spliterator&lt;Character&gt; spliterator = new WordCounterSpliterator(SENTENCE);</span><br><span class="line">      Stream&lt;Character&gt; stream = StreamSupport.stream(spliterator, true);</span><br><span class="line">      System.out.println(&quot;Found &quot; + countWords2(stream.parallel()) + &quot; words&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompletableFuture（Jdk-1-8）"><a href="#CompletableFuture（Jdk-1-8）" class="headerlink" title="CompletableFuture（Jdk 1.8）"></a>CompletableFuture（Jdk 1.8）</h3></li>
<li>翻译：可完备的Future</li>
<li>简单来说，就是写法更灵活、code可读性更好的Future。</li>
<li>是除了并行流之外的另一种并行方式，只是使用场景不同。</li>
</ul>
<h4 id="（一）一个商店商品报价的例子"><a href="#（一）一个商店商品报价的例子" class="headerlink" title="（一）一个商店商品报价的例子"></a>（一）一个商店商品报价的例子</h4><p>普通的方法去写一个同步的计算报价的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Shop &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final Random random;</span><br><span class="line"></span><br><span class="line">    public Shop(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        random = new Random(name.charAt(0) * name.charAt(1) * name.charAt(2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice(String product) &#123;</span><br><span class="line">        return calculatePrice(product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private double calculatePrice(String product) &#123;</span><br><span class="line">        delay(1000);</span><br><span class="line">        return random.nextDouble()*product.charAt(0) + product.charAt(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">@Test</span><br><span class="line">public void test_1() &#123;</span><br><span class="line">    Shop nike = new Shop(&quot;nike&quot;);</span><br><span class="line">    Shop adidas = new Shop(&quot;adidas&quot;);</span><br><span class="line">    System.out.println(&quot;nike Kobe1 price : &quot;+ nike.getPrice(&quot;Kobe1&quot;));</span><br><span class="line">    System.out.println(&quot;nike Rose3 price : &quot;+ adidas.getPrice(&quot;Rose3&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先用<code>CompletableFuture</code>来让计算变成异步。</p>
<ul>
<li>首先，用一个线程去执行对应逻辑，并且返回一个<code>CompletableFuture</code>实例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Shop &#123;</span><br><span class="line">     ............</span><br><span class="line">      public Future&lt;Double&gt; getPriceAsync(String product) &#123;</span><br><span class="line">          CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();</span><br><span class="line">          new Thread(() -&gt; &#123;</span><br><span class="line">              double price = calculatePrice(product);</span><br><span class="line">              futurePrice.complete(price);</span><br><span class="line">          &#125;).start();</span><br><span class="line">          return futurePrice;</span><br><span class="line">      &#125;</span><br><span class="line">      ............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>好，然后我们在执行此方法时，就实现了异步。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">      Shop nike = new Shop(&quot;nike&quot;);</span><br><span class="line">      Shop adidas = new Shop(&quot;adidas&quot;);</span><br><span class="line">      Future&lt;Double&gt; price1 = nike.getPriceAsync(&quot;Kobe1&quot;);</span><br><span class="line">      Future&lt;Double&gt; price2 = adidas.getPriceAsync(&quot;Kobe1&quot;);</span><br><span class="line">      System.out.printf(&quot;nike Kobe1 price :%.2f%n&quot;,price1.get());</span><br><span class="line">      System.out.printf(&quot;nike Kobe1 price :%.2f%n&quot;, price2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="（二）Future的局限性"><a href="#（二）Future的局限性" class="headerlink" title="（二）Future的局限性"></a>（二）Future的局限性</h4><p>看到上面，我们发现，其实，和用<code>Future</code>去handle结果返回，好像差不多。</p>
<ul>
<li>我们可以用<code>Future.get(timeout, TimeUnit)</code> 来防止一直拿不到值而等待的情况。</li>
<li>可以用<code>Future.isDone()</code>来判断当前任务是否跑完，然后做不同的handle逻辑。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_1() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;Double&gt; future = executor.submit(this::doSthAsync);</span><br><span class="line">    System.out.println(&quot;好，任务起来了，我去干别的先了&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">        System.out.println(&quot;主线程正在干活。。&quot;);</span><br><span class="line">        Thread.sleep(500L);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(&quot;异步任务返回了： &quot; + future.get(2, TimeUnit.SECONDS));</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        System.out.println(&quot;异步任务出了异常！！！&quot;);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里，就要说一下<code>Future</code>的<strong>局限性</strong>了。</li>
</ul>
<ol>
<li><strong>我们很难表述<code>Future</code>结果之间的依赖性</strong>。比如这样一个案例：“当长时间计算任务完成时，请将该计算的结果通知到另一个长时间运行的计算任务，这两个计算任务都完成后，将计算的结果与另一个查询操作结果合并”。</li>
<li><strong>以下场景，<code>Future</code>都难以表述：</strong><ul>
<li>将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果。</li>
<li>等待Future集合中的所有任务都完成。</li>
<li>仅等待Future集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同一个值），并返回它的结果。</li>
<li>通过编程方式完成一个Future任务的执行（即以手工设定异步操作结果的方式）。</li>
<li>应对Future的完成事件（即当Future的完成事件发生时会收到通知，并能使用Future计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）。</li>
</ul>
</li>
</ol>
<h4 id="（三）CompetableFuture与Future间的关系"><a href="#（三）CompetableFuture与Future间的关系" class="headerlink" title="（三）CompetableFuture与Future间的关系"></a>（三）CompetableFuture与Future间的关系</h4><p><code>CompetableFuture</code>之于<code>Future</code>，相当于<code>Stream</code>之于<code>Collection</code>。</p>
<h4 id="（四）CompetableFuture的一些用法"><a href="#（四）CompetableFuture的一些用法" class="headerlink" title="（四）CompetableFuture的一些用法"></a>（四）CompetableFuture的一些用法</h4><ul>
<li><p>CompetableFuture的一些静态方法，直接简化创建Thread的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Future&lt;Double&gt; getPriceAsync(String product) &#123;</span><br><span class="line">      CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();</span><br><span class="line">      new Thread(() -&gt; &#123;</span><br><span class="line">          double price = calculatePrice(product);</span><br><span class="line">          futurePrice.complete(price);</span><br><span class="line">      &#125;).start();</span><br><span class="line">      return futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接变成一句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Future&lt;Double&gt; getPriceAsync(String product) &#123;</span><br><span class="line">    return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>supplyAsync方法接受一个生产者（Supplier）作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。生产者方法会交由ForkJoinPool池中的某个执行线程（Executor）运行，但是你也可以使用supplyAsync方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。</p>
</blockquote>
</li>
<li><p>再来一个例子，之前是一家Shop做异步处理，这还不能发挥此接口的最大效用，所以，这次，来一打Shops，比较最佳售价。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final List&lt;Shop&gt; shops = Lists.newArrayList(new Shop(&quot;BestPrice&quot;),</span><br><span class="line">      new Shop(&quot;LetsSaveBig&quot;),</span><br><span class="line">      new Shop(&quot;MyFavoriteShop&quot;),</span><br><span class="line">      new Shop(&quot;BuyItAll&quot;));</span><br></pre></td></tr></table></figure>
<p>一般情况下，用并行流和CompletableFuture的异步效果是半斤八两的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 并行流的方式</span><br><span class="line">public List&lt;String&gt; findPricesParallel(String product) &#123;</span><br><span class="line">      return shops.parallelStream()</span><br><span class="line">              .map(shop -&gt; String.format(&quot;%s 价格 %.2f&quot;, shop.getName() , shop.getPrice(product)))</span><br><span class="line">              .collect(toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CompletableFuture的方式</span><br><span class="line">public List&lt;String&gt; findPricesFuture(String product) &#123;</span><br><span class="line">      List&lt;CompletableFuture&lt;String&gt;&gt; completableFutures = shops.stream()</span><br><span class="line">                  .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; String.format(&quot;%s 价格 %.2f&quot;, shop.getName(), shop.getPrice(product))))</span><br><span class="line">                  .collect(toList());</span><br><span class="line">      return completableFutures</span><br><span class="line">              .stream()</span><br><span class="line">              .map(CompletableFuture::join)</span><br><span class="line">              .collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认<code>CompletableFuture.supplyAsyn()</code>内部使用的线程池和<code>ParallelStream</code>使用的是同一个线程池，是默认的固定线程数量的线程池，这个线程数由CPU、JVM配置等决定。</p>
<blockquote>
<p>具体线程数取决于<code>Runtime.getRuntime().availableProcessors()</code>的返回值</p>
</blockquote>
<p><strong>但是，<code>CompletableFuture</code>是可以配置<code>supplyAsyn()</code>中使用的ThreadFactory的，而<code>ParallelStream</code>是不能的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用自定义的线程池</span><br><span class="line">  private final Executor executor = Executors.newFixedThreadPool(100, new ThreadFactory() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Thread newThread(Runnable runnable) &#123;</span><br><span class="line">          Thread t = new Thread(runnable);</span><br><span class="line">          t.setDaemon(true);</span><br><span class="line">          return t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">public List&lt;String&gt; findPricesFuture(String product) &#123;</span><br><span class="line">      return shops.stream()</span><br><span class="line">              .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; &quot;&quot; + shop.getPrice(), executor))</span><br><span class="line">              .collect(toList())</span><br><span class="line">              .stream()</span><br><span class="line">              .map(CompletableFuture::join)</span><br><span class="line">              .collect(toList());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="并发，用并行流还是CompletableFuture？"><a href="#并发，用并行流还是CompletableFuture？" class="headerlink" title="并发，用并行流还是CompletableFuture？"></a>并发，用并行流还是CompletableFuture？</h3><p>情况 | 推荐 | 原因</p>
</li>
</ul>
<p>— | — | —<br>如果你进行的是计算密集型的操作，并且没有I/O | Stream | 实现简单<br>如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待）| CompletableFuture | 高灵活性</p>
<h1 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>Java 1.0<ul>
<li>特点：只有java.util.Date类</li>
<li>缺点：这个类无法表示日期，只能以毫秒的精度表示时间。而且，易用性差，如：<code>Date date = new Date(114, 2, 18);</code>居然表示2014年3月18日。</li>
</ul>
</li>
<li>Java 1.1<ul>
<li>更新：Date类中的很多方法被废弃了，取而代之的是java.util.Calendar类</li>
<li>缺点：Calendar类同样很难用，比如：<ul>
<li>月份依旧是从0开始计算（不过，至少Calendar类拿掉了由1900年开始计算年份这一设计）</li>
<li>DateFormat方法也有它自己的问题，它不是线程安全的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="LocalDate和LocalTime"><a href="#LocalDate和LocalTime" class="headerlink" title="LocalDate和LocalTime"></a>LocalDate和LocalTime</h3><p>相关类：</p>
<ul>
<li><code>java.time.LocalDate</code></li>
<li><code>java.time.LocalTime</code></li>
<li><code>java.time.LocalDateTime</code></li>
</ul>
<p>三个类都实现了各种基本计算方法、parse方法、比较方法， 以及各种静态方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(2018, 11, 25);</span><br><span class="line">int year = localDate.getYear();// 2018</span><br><span class="line">Month month = localDate.getMonth(); // 11</span><br><span class="line">int day = localDate.getDayOfMonth(); // 25</span><br><span class="line">DayOfWeek dow = localDate.getDayOfWeek(); // SUNDAY</span><br><span class="line">int len = localDate.lengthOfMonth(); // 本月总天数： 30</span><br><span class="line">boolean leap = localDate.isLeapYear(); // 是不是闰年： false</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">int year = localDate.get(ChronoField.YEAR);</span><br><span class="line">int month = localDate.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">int day = localDate.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">int hour = localTime.get(ChronoField.HOUR_OF_DAY);</span><br><span class="line">int minute = localTime.get(ChronoField.MINUTE_OF_HOUR);</span><br><span class="line">int second = localTime.get(ChronoField.SECOND_OF_MINUTE);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime); // 2018-11-25T22:10:08.721</span><br><span class="line">System.out.println(localDateTime.atZone(ZoneId.of(&quot;GMT&quot;))); // 2018-11-25T22:11:08.778Z[GMT]</span><br><span class="line">System.out.println(localDateTime.atOffset(ZoneOffset.UTC)); // 2018-11-25T22:11:44.362Z</span><br></pre></td></tr></table></figure>

<h3 id="机器的日期和时间格式"><a href="#机器的日期和时间格式" class="headerlink" title="机器的日期和时间格式"></a>机器的日期和时间格式</h3><blockquote>
<p>从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。</p>
</blockquote>
<ul>
<li><p>相关类：</p>
<ul>
<li><code>java.time.Instant</code></li>
</ul>
</li>
<li><p>建模方式：以Unix元年时间（传统的设定为UTC时区1970年1月1日午夜时分）开始所经历的秒数进行计算。</p>
</li>
<li><p>作用：适用于计算机做高精度运算。</p>
</li>
<li><p>用法实例</p>
<ul>
<li>Instant.ofEpochSecond(秒/long, 纳秒/long)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Instant.ofEpochSecond(3); // 1970-01-01T00:00:03Z</span><br><span class="line">Instant.ofEpochSecond(3, 0);</span><br><span class="line">Instant.ofEpochSecond(2, 1_000_000_000); // 2 秒之后再加上100万纳秒（1秒）</span><br><span class="line">Instant.ofEpochSecond(4, -1_000_000_000); // 4秒之前的100万纳秒（1秒）</span><br></pre></td></tr></table></figure>
<h3 id="Duration-Period"><a href="#Duration-Period" class="headerlink" title="Duration/Period"></a>Duration/Period</h3><h4 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h4></li>
</ul>
</li>
<li><p>作用：Duration类主要用于以秒和纳秒衡量时间的长短</p>
</li>
<li><p>注意：不要用机器时间相关API来计算Duration，你看不懂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTime time1 = LocalTime.of(21, 50, 10);</span><br><span class="line">LocalTime time2 = LocalTime.of(22, 50, 10);</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.of(2018, 11, 17, 21, 50, 10);</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(2018, 11, 17, 23, 50, 10);</span><br><span class="line">Instant instant1 = Instant.ofEpochSecond(1000 * 60 * 2);</span><br><span class="line">Instant instant2 = Instant.ofEpochSecond(1000 * 60 * 3);</span><br><span class="line"></span><br><span class="line">// 可用工厂方法定义</span><br><span class="line">Duration threeMinutes = Duration.ofMinutes(3);</span><br><span class="line">Duration fourMinutes = Duration.of(4, ChronoUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">Duration d1 = Duration.between(time1, time2);</span><br><span class="line">Duration d2 = Duration.between(dateTime1, dateTime2);</span><br><span class="line">Duration d3 = Duration.between(instant1, instant2);</span><br><span class="line">// PT1H 相差1小时</span><br><span class="line">System.out.println(&quot;d1:&quot; + d1);</span><br><span class="line">// PT2H 相差2小时</span><br><span class="line">System.out.println(&quot;d2:&quot; + d2);</span><br><span class="line">// PT16H40M 相差16小时40分钟</span><br><span class="line">System.out.println(&quot;d3:&quot; + d3);</span><br></pre></td></tr></table></figure>
<p>而且，不要试图在这两类对象之间创建duration，会触发一个DateTimeException异常。而且，不要放一个LocalDate对象作为参数，不合适。</p>
</li>
</ul>
<h4 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h4><ul>
<li>作用：以年、月或者日的方式对多个时间单位建模</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可用工厂方法定义</span><br><span class="line">Period tenDay = Period.ofDays(10);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(3);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(2, 6, 1);</span><br><span class="line"></span><br><span class="line">Period period = Period.between(LocalDate.of(2018, 11, 7), LocalDate.of(2018, 11, 17));</span><br><span class="line">System.out.println(&quot;Period between:&quot; + period); // P10D 相差10天</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="修改、构造时间"><a href="#修改、构造时间" class="headerlink" title="修改、构造时间"></a>修改、构造时间</h3><p>简单来说，API给我们划分了读取和修改两类方法：</p>
<ul>
<li>读：<code>get</code></li>
<li>修改：<code>with</code></li>
</ul>
<p>下面这些方法都会生成一个新的时间对象，不会修改源对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 2018-11-17</span><br><span class="line">LocalDate date1 = LocalDate.of(2018, 11, 17);</span><br><span class="line">// 2019-11-17</span><br><span class="line">LocalDate date2 = date1.withYear(2019);</span><br><span class="line">// 2019-11-25</span><br><span class="line">LocalDate date3 = date2.withDayOfMonth(25);</span><br><span class="line">// 2019-09-25</span><br><span class="line">LocalDate date4 = date3.with(ChronoField.MONTH_OF_YEAR, 9);</span><br></pre></td></tr></table></figure>
<h4 id="特别：用TemporalAdjuster实现复杂操作"><a href="#特别：用TemporalAdjuster实现复杂操作" class="headerlink" title="特别：用TemporalAdjuster实现复杂操作"></a>特别：用TemporalAdjuster实现复杂操作</h4><p>利用重写各种<code>withXX</code>方法，并自定义<code>TemporalAdjuster</code>参数，就能实现复杂的时间操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 2018-11-17</span><br><span class="line">LocalDate date1 = LocalDate.of(2018, 11, 17);</span><br><span class="line">// 2018-11-19</span><br><span class="line">LocalDate date2 = date1.with(TemporalAdjusters.nextOrSame(DayOfWeek.MONDAY));</span><br><span class="line">// 2018-11-30</span><br><span class="line">LocalDate date3 = date2.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure>
<p>我们看看这个<code>用TemporalAdjuster</code>接口，其实要自定义很简单，因为它只有一个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface TemporalAdjuster &#123;</span><br><span class="line">    Temporal adjustInto(Temporal temporal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><ul>
<li>相关类：<ul>
<li><code>java.time.format.DateTimeFormatter</code></li>
<li><code>java.time.format.DateTimeFormatterBuilder</code>：用于实现更加复杂的格式化</li>
</ul>
</li>
<li>特点：<ul>
<li>所有的<code>DateTimeFormatter</code>实例都是<strong>线程安全</strong>的。（所以，你能够以单例模式创建格式器实例，就像DateTimeFormatter所定义的那些常量，并能在多个线程间共享这些实例。）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Date 转 String</span><br><span class="line">LocalDate date1 = LocalDate.of(2018, 11, 17);</span><br><span class="line">String s1 = date1.format(DateTimeFormatter.BASIC_ISO_DATE); // 20181117</span><br><span class="line">String s2 = date1.format(DateTimeFormatter.ISO_LOCAL_DATE); // 2018-11-17</span><br><span class="line">// String 转 Date</span><br><span class="line">LocalDate date2 = LocalDate.parse(&quot;20181117&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate date3 = LocalDate.parse(&quot;2018-11-17&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line"></span><br><span class="line">DateTimeFormatter italianFormatter = DateTimeFormatter.ofPattern(&quot;d. MMMM yyyy&quot;, Locale.ITALIAN);</span><br><span class="line">LocalDate date5 = LocalDate.of(2018, 11, 16);</span><br><span class="line">// 16. novembre 2018</span><br><span class="line">String formattedDate2 = date5.format(italianFormatter);</span><br><span class="line">// 2018-11-16</span><br><span class="line">LocalDate date6 = LocalDate.parse(formattedDate2, italianFormatter);</span><br></pre></td></tr></table></figure>
<p>用<code>DateTimeFormatterBuilder</code>实现细粒度格式化控制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter italianFormatter = new DateTimeFormatterBuilder()</span><br><span class="line">                .appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">                .appendLiteral(&quot;. &quot;)</span><br><span class="line">                .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">                .appendLiteral(&quot; &quot;)</span><br><span class="line">                .appendText(ChronoField.YEAR)</span><br><span class="line">                .parseCaseInsensitive()</span><br><span class="line">                .toFormatter(Locale.ITALIAN);</span><br><span class="line"></span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">// 17. novembre 2018</span><br><span class="line">String s1 = now.format(italianFormatter);</span><br></pre></td></tr></table></figure>

<h3 id="处理不同的时区和历法"><a href="#处理不同的时区和历法" class="headerlink" title="处理不同的时区和历法"></a>处理不同的时区和历法</h3><ul>
<li>相关类：<ul>
<li><code>java.time.ZoneId</code> </li>
<li><code>java.time.ZoneOffset</code></li>
</ul>
</li>
<li>特点：<ul>
<li>新的<code>java.time.ZoneId</code>类是老版<code>java.util.TimeZone</code>的替代品。</li>
<li>更容易处理日光时（Daylight Saving Time，DST）这种问题。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // 地区ID都为“&#123;区域&#125;/&#123;城市&#125;”的格式</span><br><span class="line">ZoneId shanghaiZone = ZoneId.of(&quot;Asia/Shanghai&quot;);</span><br><span class="line"></span><br><span class="line">LocalDate date = LocalDate.of(2018, 11, 17);</span><br><span class="line">ZonedDateTime zdt1 = date.atStartOfDay(shanghaiZone);</span><br><span class="line"></span><br><span class="line">LocalDateTime dateTime = LocalDateTime.of(2018, 11, 27, 18, 13, 15);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(shanghaiZone);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// LocalDateTime 转 Instant</span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.of(2018, 11, 17, 18, 45);</span><br><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(&quot;-05:00&quot;);</span><br><span class="line">Instant instantFromDateTime = dateTime2.toInstant(newYorkOffset);</span><br><span class="line"></span><br><span class="line">// 通过反向的方式得到LocalDateTime对象</span><br><span class="line">Instant instant2 = Instant.now();</span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant2, shanghaiZone);</span><br><span class="line"></span><br><span class="line">// OffsetDateTime，它使用ISO-8601的历法系统，以相对于UTC/格林尼治时间的偏差方式表示日期时间。</span><br><span class="line">LocalDateTime dateTime3 = LocalDateTime.of(2018, 11, 17, 18, 45);</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(dateTime3, newYorkOffset);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 深入源码 -- @Component 与 @Configuration</title>
    <url>/Spring%20Boot%20%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%20--%20@Component%20%E4%B8%8E%20@Configuration/</url>
    <content><![CDATA[<blockquote>
<p>看过笔者之前的文章 <a href="http://jpuneng.cn/Spring%20Boot%20%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%20--%20@Import/">《Spring Boot 深入源码 – @Import》</a>，大家会看到，一个例子中，我用<code>@Configuration</code>和<code>@Component</code> 好像效果没有什么区别呀~ <code>@Import</code>照样生效，<code>@Bean</code>方法也能生效呀。 那请问它们两者到底有什么区别呢？原理又是什么呢？ 本文尝试带你解读一番。</p>
</blockquote><a id="more"></a>
<h1 id="看看他们的源码注释"><a href="#看看他们的源码注释" class="headerlink" title="看看他们的源码注释"></a>看看他们的源码注释</h1><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Indexed</span><br><span class="line">public @interface Component &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * The value may indicate a suggestion for a logical component name,</span><br><span class="line">	 * to be turned into a Spring bean in case of an autodetected component.</span><br><span class="line">	 * @return the suggested component name, if any (or empty String otherwise)</span><br><span class="line">	 */</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * ....................</span><br><span class="line"> * &lt;h2&gt;Constraints when authoring &#123;@code @Configuration&#125; classes&lt;/h2&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;Configuration classes must be provided as classes (i.e. not as instances returned</span><br><span class="line"> * from factory methods), allowing for runtime enhancements through a generated subclass.</span><br><span class="line"> * &lt;li&gt;Configuration classes must be non-final.</span><br><span class="line"> * &lt;li&gt;Configuration classes must be non-local (i.e. may not be declared within a method).</span><br><span class="line"> * &lt;li&gt;Any nested configuration classes must be declared as &#123;@code static&#125;.</span><br><span class="line"> * &lt;li&gt;&#123;@code @Bean&#125; methods may not in turn create further configuration classes</span><br><span class="line"> * (any such instances will be treated as regular beans, with their configuration</span><br><span class="line"> * annotations remaining undetected).</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author Rod Johnson</span><br><span class="line"> * @author Chris Beams</span><br><span class="line"> * @since 3.0</span><br><span class="line"> * @see Bean</span><br><span class="line"> * @see Profile</span><br><span class="line"> * @see Import</span><br><span class="line"> * @see ImportResource</span><br><span class="line"> * @see ComponentScan</span><br><span class="line"> * @see Lazy</span><br><span class="line"> * @see PropertySource</span><br><span class="line"> * @see AnnotationConfigApplicationContext</span><br><span class="line"> * @see ConfigurationClassPostProcessor</span><br><span class="line"> * @see org.springframework.core.env.Environment</span><br><span class="line"> * @see org.springframework.test.context.ContextConfiguration</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Component</span><br><span class="line">public @interface Configuration &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Explicitly specify the name of the Spring bean definition associated with the</span><br><span class="line">	 * &#123;@code @Configuration&#125; class. If left unspecified (the common case), a bean</span><br><span class="line">	 * name will be automatically generated.</span><br><span class="line">	 * &lt;p&gt;The custom name applies only if the &#123;@code @Configuration&#125; class is picked</span><br><span class="line">	 * up via component scanning or supplied directly to an</span><br><span class="line">	 * &#123;@link AnnotationConfigApplicationContext&#125;. If the &#123;@code @Configuration&#125; class</span><br><span class="line">	 * is registered as a traditional XML bean definition, the name/id of the bean</span><br><span class="line">	 * element will take precedence.</span><br><span class="line">	 * @return the explicit component name, if any (or empty String otherwise)</span><br><span class="line">	 * @see org.springframework.beans.factory.support.DefaultBeanNameGenerator</span><br><span class="line">	 */</span><br><span class="line">	@AliasFor(annotation = Component.class)</span><br><span class="line">	String value() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码来看，<code>Configuration</code>本质还是<code>@Component</code>，所以，<code>&lt;context:component-scan/&gt;</code> 或 <code>@ComponentScan</code> 都能处理<code>@Configuration</code>注解的类。</p>
<h1 id="Configuration-与-Component-的区别"><a href="#Configuration-与-Component-的区别" class="headerlink" title="@Configuration 与 @Component 的区别"></a>@Configuration 与 @Component 的区别</h1><p>一句话概括：<code>@Configuration</code> 中所有带 <code>@Bean</code> 注解的方法都会被<strong>动态代理</strong>，因此调用该方法返回的都是同一个实例。</p>
<ul>
<li><code>@Component</code>可以注解在任何类上，但是<code>@Configuration</code>使用有条件。</li>
<li><code>@Configuration</code>中所有带<code>@Bean</code>注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。</li>
<li><code>@Configuration</code>本质上还是<code>@Component</code>，所以，<code>&lt;context:component-scan/&gt;</code>或者<code>@ComponentScan</code>都能处理<code>@Configuration</code>注解类。</li>
<li><code>@Configuration</code>标记的类必须符合一下要求：<ul>
<li>配置类必须以类的形式提供（不能是工厂方法返回的实例），允许通过生成子类在运行时增强（cglib 动态代理）。</li>
<li>配置类不能是 final 类（没法动态代理）。</li>
<li>配置注解通常为了通过 <code>@Bean</code> 注解生成 Spring 容器管理的类</li>
<li>配置类必须是非本地的（即不能在方法中声明，不能是 private）。</li>
<li>任何嵌套配置类都必须声明为static。</li>
<li><code>@Bean</code> 方法可能不会反过来创建进一步的配置类（也就是返回的 bean 如果带有 <code>@Configuration</code>，也不会被特殊处理，只会作为普通的 bean）。</li>
</ul>
</li>
</ul>
<h1 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h1><p>Spring 容器在启动时，会加载默认的一些 <code>PostProcessor</code>，其中就有 <code>ConfigurationClassPostProcessor</code>，这个后置处理程序专门处理带有 @Configuration 注解的类，这个程序会在 bean 定义加载完成后，在 bean 初始化前进行处理。主要处理的过程就是使用 cglib 动态代理增强类，而且是对其中带有 @Bean 注解的方法进行处理。</p>
<blockquote>
<p>这个加载过程，其实走的代码流程 和 我们之前分析 <code>@Import</code>时走的流程是十分相似的，同样会调用 <code>ConfigurationClassPostProcessor</code> 类，只是对于<code>@Component</code>和<code>@Configuration</code>调用的方法不同。</p>
</blockquote>
<p>注释如下：<br>Prepare the Configuration classes for servicing bean requests at runtime by replacing them with CGLIB-enhanced subclasses.</p>
<blockquote>
<p>通过用 CGLIB 增强的子类替换 Bean 请求，为运行时的 Bean 请求提供服务准备配置类。 </p>
</blockquote>
<p>在 <code>ConfigurationClassPostProcessor</code> 中的 <code>postProcessBeanFactory</code> 方法主要流程如下：</p>
<ol>
<li>传入<code>ConfigurableListableBeanFactory</code>对象，并获取其factoryId。</li>
<li>判断这个factoryId是否已经被处理过，如果已被处理，则抛异常。</li>
<li>如果 BeanDefinitionRegistryPostProcessor hook apparently not supported，则 Simply call processConfigurationClasses lazily at this point then，调用<code>processConfigBeanDefinitions</code>方法，其实和<code>@Component</code>注解跑的逻辑一样，去开始注入bean。</li>
<li><strong>调用 <code>enhanceConfigurationClasses</code> 方法</strong>：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * Post-processes a BeanFactory in search of Configuration class BeanDefinitions;</span><br><span class="line"> * any candidates are then enhanced by a &#123;@link ConfigurationClassEnhancer&#125;.</span><br><span class="line"> * Candidate status is determined by BeanDefinition attribute metadata.</span><br><span class="line"> * @see ConfigurationClassEnhancer</span><br><span class="line"> */</span><br><span class="line">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();</span><br><span class="line">	for (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">		BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">		if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">			// ...........</span><br><span class="line">			configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">		// nothing to enhance -&gt; return immediately</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();</span><br><span class="line">	for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">		AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">		// If a @Configuration class gets proxied, always proxy the target class</span><br><span class="line">		beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">		try &#123;</span><br><span class="line">			// Set enhanced subclass of the user-specified bean class</span><br><span class="line">			Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);</span><br><span class="line">			if (configClass != null) &#123;</span><br><span class="line">				Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);</span><br><span class="line">				if (configClass != enhancedClass) &#123;</span><br><span class="line">					// ..............</span><br><span class="line">					beanDef.setBeanClass(enhancedClass);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new IllegalStateException(&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个for循环：查找所有带有 <code>@Configuration</code> 注解的bean 定义；</li>
<li>第二个for循环：通过 <code>Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);</code> 方法 对类进行增强；</li>
<li>使用增强后的类 替换原有的 <code>beanClass</code>：<code>beanDef.setBeanClass(enhancedClass);</code>；</li>
<li>之后，所有带有<code>@Configuration</code>注解的 bean 都已经变成增强的类。</li>
</ul>
</li>
</ol>
<p>我们进一步看这个<code>enhance()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Loads the specified class and generates a CGLIB subclass of it equipped with</span><br><span class="line"> * container-aware callbacks capable of respecting scoping and other bean semantics.</span><br><span class="line"> * @return the enhanced subclass</span><br><span class="line"> */</span><br><span class="line">public Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    if (EnhancedConfiguration.class.isAssignableFrom(configClass)) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(String.format(&quot;Ignoring request to enhance %s as it has &quot; +</span><br><span class="line">                    &quot;already been enhanced. This usually indicates that more than one &quot; +</span><br><span class="line">                    &quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot; +</span><br><span class="line">                    &quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot; +</span><br><span class="line">                    &quot;want check your configuration and remove one CCPP if possible&quot;,</span><br><span class="line">                    configClass.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        return configClass;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(String.format(&quot;Successfully enhanced %s; enhanced class name is: %s&quot;,</span><br><span class="line">                configClass.getName(), enhancedClass.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    return enhancedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部调用了<code>newEnhancer()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new CGLIB &#123;@link Enhancer&#125; instance.</span><br><span class="line"> * 创建一个新的 CGLIB 实例（Enhancer 对象）</span><br><span class="line"> */</span><br><span class="line">private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    enhancer.setSuperclass(configSuperClass);</span><br><span class="line">    enhancer.setInterfaces(new Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(false);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    return enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面方法我们看到， 这个<code>enhancer.setCallbackFilter(CALLBACK_FILTER);</code> 实际上是将一个CallbackFilter接口实现类设置给到这个增强类。</p>
<p>通过 cglib 代理的类在调用方法时，会通过 <code>CallbackFilter</code> 调用，这里的 <code>CALLBACK_FILTER</code> 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// The callbacks to use. Note that these callbacks must be stateless.</span><br><span class="line">private static final Callback[] CALLBACKS = new Callback[] &#123;</span><br><span class="line">        new BeanMethodInterceptor(),</span><br><span class="line">        new BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">        NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);</span><br></pre></td></tr></table></figure>
<p>其实是一个<code>ConditionalCallbackFilter</code>类对象，它的构造器传入了对象，分别是：</p>
<ul>
<li><code>new BeanMethodInterceptor()</code><ul>
<li><code>ConfigurationClassEnhancer</code>的一个静态内部类</li>
</ul>
</li>
<li><code>new BeanFactoryAwareMethodInterceptor()</code><ul>
<li><code>ConfigurationClassEnhancer</code>的一个静态内部类</li>
</ul>
</li>
<li><code>NoOp.INSTANCE</code></li>
</ul>
<p>其中，<code>BeanMethodInterceptor</code> 匹配方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean isMatch(Method candidateMethod) &#123;</span><br><span class="line">    // 方法有 @Bean 注解，则返回true</span><br><span class="line">    return BeanAnnotationHelper.isBeanAnnotated(candidateMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BeanAnnotationHelper</span><br><span class="line">public static boolean isBeanAnnotated(Method method) &#123;</span><br><span class="line">    // 方法有没有 @Bean 注解</span><br><span class="line">    return AnnotatedElementUtils.hasAnnotation(method, Bean.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个 <code>BeanFactoryAwareMethodInterceptor</code> 匹配的方法则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean isMatch(Method candidateMethod) &#123;</span><br><span class="line">    return (candidateMethod.getName().equals(&quot;setBeanFactory&quot;) &amp;&amp;</span><br><span class="line">            candidateMethod.getParameterTypes().length == 1 &amp;&amp;</span><br><span class="line">            BeanFactory.class == candidateMethod.getParameterTypes()[0] &amp;&amp;</span><br><span class="line">            BeanFactoryAware.class.isAssignableFrom(candidateMethod.getDeclaringClass())); // 当前类需要实现 `BeanFactoryAware`接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前类还需要实现 <code>BeanFactoryAware</code> 接口，上面的 <code>isMatch</code> 就是匹配的这个接口的方法。</p>
<h1 id="Bean-注解方法执行策略"><a href="#Bean-注解方法执行策略" class="headerlink" title="@Bean 注解方法执行策略"></a>@Bean 注解方法执行策略</h1><p>先看看一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyBeanConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Country country()&#123;</span><br><span class="line">        return new Country();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserInfo userInfo()&#123;</span><br><span class="line">        return new UserInfo(country());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相信大多数人第一次看到上面 userInfo() 中调用 country() 时，会认为这里的 Country 和上面 @Bean 方法返回的 Country 可能不是同一个对象，因此可能会通过下面的方式来替代这种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 或者 @Resource</span><br><span class="line">@Autowired</span><br><span class="line">private Country country;</span><br></pre></td></tr></table></figure>
<p>实际上不需要这么做（后面会给出需要这样做的场景），直接调用 <code>country()</code> 方法返回的是同一个实例。</p>
</blockquote>
<p>下面看调用 <code>country()</code> 和 <code>userInfo()</code> 方法时的逻辑。</p>
<p>现在我们已经知道 <code>@Configuration</code> 注解的类是如何被处理的了，现在关注上面的 <code>BeanMethodInterceptor</code>，看看带有 <code>@Bean</code> 注解的方法执行的逻辑。下面分解来看 <code>BeanMethodInterceptor.intercept</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Enhance a &#123;@link Bean @Bean&#125; method to check the supplied BeanFactory for the</span><br><span class="line"> * existence of this bean object.</span><br><span class="line"> * @throws Throwable as a catch-all for any exception that may be thrown when invoking the</span><br><span class="line"> * super implementation of the proxied method i.e., the actual &#123;@code @Bean&#125; method</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span><br><span class="line">            MethodProxy cglibMethodProxy) throws Throwable &#123;</span><br><span class="line">    // 1. 首先通过反射从增强的 Configuration 注解类中获取 beanFactory</span><br><span class="line">    ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">    </span><br><span class="line">    // 2. 通过方法获取 beanName，默认是方法名，可通过 @Bean 注解指定</span><br><span class="line">    String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line">    // 3. 确定这个bean 是否指定了代理的范围（默认下面的if 条件为 false，不会执行）</span><br><span class="line">    // Determine whether this bean is a scoped-proxy</span><br><span class="line">    if (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">        String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line">        if (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">            beanName = scopedBeanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分 Factorybean 相关代码 ...........</span><br><span class="line"></span><br><span class="line">    // 判断当前执行的方法是否为正在执行的 @Bean 方法</span><br><span class="line">    // 因为存在在 userInfo() 方法中调用 country() 方法</span><br><span class="line">    // 如果 country() 也有 @Bean 注解，那么这个返回值就是 false.</span><br><span class="line">    if (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">        // 判断返回值类型，如果是 BeanFactoryPostProcessor 就写警告日志</span><br><span class="line">        if (logger.isInfoEnabled() &amp;&amp;</span><br><span class="line">                BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">            logger.info(String.format(&quot;@Bean method %s.%s is non-static and returns an object &quot; +</span><br><span class="line">                            &quot;assignable to Spring&apos;s BeanFactoryPostProcessor interface. This will &quot; +</span><br><span class="line">                            &quot;result in a failure to process annotations such as @Autowired, &quot; +</span><br><span class="line">                            &quot;@Resource and @PostConstruct within the method&apos;s declaring &quot; +</span><br><span class="line">                            &quot;@Configuration class. Add the &apos;static&apos; modifier to this method to avoid &quot; +</span><br><span class="line">                            &quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;,</span><br><span class="line">                    beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接调用原方法创建 bean</span><br><span class="line">        return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果不满足上面 if，也就是在 userInfo() 中调用的 country() 方法</span><br><span class="line">    return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于 <code>isCurrentlyInvokedFactoryMethod</code> 方法</strong>:</p>
<p>可以参考 <code>SimpleInstantiationStrategy</code> 中的 <code>instantiate</code> 方法，这里先设置的调用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">currentInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">return factoryMethod.invoke(factoryBean, args); // 反射</span><br></pre></td></tr></table></figure>
<p>而通过方法内部直接调用 country() 方法时，不走上面的逻辑，直接进的代理方法，也就是当前的 intercept方法，因此当前的工厂方法和执行的方法就不相同了。</p>
</blockquote>
<p><code>obtainBeanInstanceFromFactory</code> 方法比较简单，就是通过 <code>beanFactory.getBean</code> 获取 <code>Country</code>，如果已经创建了就会直接返回，如果没有执行过，就会通过 <code>invokeSuper</code> 首次执行。</p>
<p>因此我们在 <code>@Configuration</code> 注解定义的 bean 方法中可以直接调用方法，不需要 <code>@Autowired</code> 注入后使用。</p>
<h1 id="回头看看-Component"><a href="#回头看看-Component" class="headerlink" title="回头看看 @Component"></a>回头看看 @Component</h1><p><code>@Component</code> 注解并没有通过 cglib 来代理 <code>@Bean</code>方法的调用，因此像下面这样配置时，就是两个不同的 <code>country</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBeanConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Country country()&#123;</span><br><span class="line">        return new Country();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserInfo userInfo()&#123;</span><br><span class="line">        return new UserInfo(country());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些特殊情况下，我们不希望 <code>MyBeanConfig</code> 被代理（代理后会变成 <code>WebMvcConfig$$EnhancerBySpringCGLIB$$8bef3235293</code>）时，就得用 <code>@Component</code>，这种情况下，上面的写法就需要改成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBeanConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Country country;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Country country()&#123;</span><br><span class="line">        return new Country();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserInfo userInfo()&#123;</span><br><span class="line">        return new UserInfo(country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就能保证使用的是同一个 <code>country</code> 实例。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过源码分析，我们知道了一些关于<code>@Configuration</code>的知识点：</p>
<ol>
<li>为什么<code>@Configuration</code>不能是 final？ <blockquote>
<p>因为源码告诉我们，<code>@Configuration</code> bean需要被动态代理，进行运行时增强，而动态代理无法搞定final 类（所以我们在写unit test 的时候，想要mock 一些 final的类和成员属性，基本是无从下手的，比如，你想mock一个<code>String</code>对象，是不给的）</p>
</blockquote>
</li>
<li><code>@Configuration</code>和<code>@Component</code>都会为其下的<code>@Bean</code>方法 解析注入对象。 <blockquote>
<p>对的，源码告诉我们，因为<code>@Configuration</code>属于<code>@Component</code>，那么，就一定会走<code>ConfigurationClassPostProcessor.processConfigBeanDefinitions()</code>方法，去构建并验证其结构，最终都会调用<code>ConfigurationClassParser.parse</code>方法。</p>
<p><code>processConfigBeanDefinitions</code>方法做了以下关键两个步骤：</p>
<ol>
<li><code>checkConfigurationClassCandidate()</code>：查看一个BeanDefinition是不是可以被parser解析，逻辑是如果有<code>@Configuration</code>的那么是full，如果是有<code>@Component</code>，<code>@ComponentScan</code>，<code>@Import</code>， <code>@ImportResource</code>四个注解，或者方法里面有<code>@Bean</code>注解，那么也可以被解析，属于lite。</li>
<li><code>ConfigurationClassParser.parse()</code>：用于分析<code>@Configuration</code>注解的配置类，产生一组<code>ConfigurationClass</code>对象。它的分析过程会接受一组种子配置类(调用者已知的配置类，通常很可能只有一个)，从这些种子配置类开始分析所有关联的配置类，分析过程主要是递归分析配置类的注解@Import，配置类内部嵌套类，找出其中所有的配置类，然后返回这组配置类。这个工具类自身的逻辑并不注册bean定义，它的主要任务是发现<code>@Configuration</code>注解的所有配置类并将这些配置类交给调用者(调用者会通过其他方式注册其中的bean定义)，而对于非<code>@Configuration</code>注解的其他bean定义，比如<code>@Component</code>注解的bean定义，该工具类使用另外一个工具<code>ComponentScanAnnotationParser</code>扫描和注册它们。</li>
</ol>
</blockquote>
</li>
<li>为什么<code>@Configuration</code> 中的<code>@Bean</code>方法使用另一个bean对象时，可以直接调用另一个带有<code>@Bean</code>的方法来获取同一个bean， 而<code>@Component</code>却不行呢？<blockquote>
<p>源码告诉我们，因为<code>@Configuration</code>修饰的bean，在扫描验证过程结束后，会多一步 增强过程，会将自身的<code>@Bean</code>方法调用处理过程给到代理类是执行，从而控制调用方法时是否依然创建新的对象。</p>
</blockquote>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://blog.csdn.net/isea533/article/details/78072133" target="_blank" rel="noopener">https://blog.csdn.net/isea533/article/details/78072133</a></li>
<li><a href="http://makaidong.com/chuliang/970048_20893468.html" target="_blank" rel="noopener">http://makaidong.com/chuliang/970048_20893468.html</a></li>
<li><a href="https://blog.csdn.net/andy_zhang2007/article/details/78549773" target="_blank" rel="noopener">https://blog.csdn.net/andy_zhang2007/article/details/78549773</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 深入源码 -- @Import</title>
    <url>/Spring%20Boot%20%E6%B7%B1%E5%85%A5%E6%BA%90%E7%A0%81%20--%20@Import/</url>
    <content><![CDATA[<h1 id="Import的作用"><a href="#Import的作用" class="headerlink" title="@Import的作用"></a>@Import的作用</h1><p>允许通过它引入 <code>@Configuration</code> 注解的类 (java config)， 引入<code>ImportSelector</code>接口(这个比较重要， 因为要通过它去判定要引入哪些<code>@Configuration</code>) 和 <code>ImportBeanDefinitionRegistrar</code> 接口的实现，也包括 <code>@Component</code>注解的普通类。</p><a id="more"></a>
<p>看看其源码以及注释（摘自 spring-context-5.1.8.RELEASE）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Indicates one or more &#123;@link Configuration @Configuration&#125; classes to import.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Provides functionality equivalent to the &#123;@code &lt;import/&gt;&#125; element in Spring XML.</span><br><span class="line"> * Allows for importing &#123;@code @Configuration&#125; classes, &#123;@link ImportSelector&#125; and</span><br><span class="line"> * &#123;@link ImportBeanDefinitionRegistrar&#125; implementations, as well as regular component</span><br><span class="line"> * classes (as of 4.2; analogous to &#123;@link AnnotationConfigApplicationContext#register&#125;).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&#123;@code @Bean&#125; definitions declared in imported &#123;@code @Configuration&#125; classes should be</span><br><span class="line"> * accessed by using &#123;@link org.springframework.beans.factory.annotation.Autowired @Autowired&#125;</span><br><span class="line"> * injection. Either the bean itself can be autowired, or the configuration class instance</span><br><span class="line"> * declaring the bean can be autowired. The latter approach allows for explicit, IDE-friendly</span><br><span class="line"> * navigation between &#123;@code @Configuration&#125; class methods.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;May be declared at the class level or as a meta-annotation.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If XML or other non-&#123;@code @Configuration&#125; bean definition resources need to be</span><br><span class="line"> * imported, use the &#123;@link ImportResource @ImportResource&#125; annotation instead.</span><br><span class="line"> *</span><br><span class="line"> * @author Chris Beams</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @since 3.0</span><br><span class="line"> * @see Configuration</span><br><span class="line"> * @see ImportSelector</span><br><span class="line"> * @see ImportResource</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Import &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * &#123;@link Configuration&#125;, &#123;@link ImportSelector&#125;, &#123;@link ImportBeanDefinitionRegistrar&#125;</span><br><span class="line">	 * or regular component classes to import.</span><br><span class="line">	 */</span><br><span class="line">	Class&lt;?&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="说说其背景"><a href="#说说其背景" class="headerlink" title="说说其背景"></a>说说其背景</h2><p>在Spring 3.0 以前，创建Bean可通过xml配置文件和扫描特定包下的类 来达到类注入Spring IoC容器的效果。而在Spring 3.0 之后，提供了所谓了 Java Config 的方式，也就是可以通过java代码的形式去注入类，将IOC容器里Bean的元信息以java代码的方式进行描述。我们可以通过<code>@Configuration</code>与<code>@Bean</code>这两个注解配合使用来将原来配置在xml文件里的bean通过java代码的方式进行描述。</p>
<h1 id="写例子，用一下-Import"><a href="#写例子，用一下-Import" class="headerlink" title="写例子，用一下@Import"></a>写例子，用一下@Import</h1><p>通过上面贴出来的<code>@Import</code> 源码，可以了解到它是配合<code>Configuration</code>,<code>ImportSelector</code>以及<code>ImportBeanDefinitionRegistrar</code>来使用的，也可以把<code>@Import</code>修饰的类当做普通的Bean来使用。</p>
<p>这是例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Service01 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，bean容器没有service01。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">class Service01 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，bean容器存在bean <code>service01</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Bean(Service02.class)</span><br><span class="line">class Service01 &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Service02 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，bean容器存在bean <code>service01</code> 和 <code>com.xxx.Service02</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Bean(Service02.class)</span><br><span class="line">class Service01 &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Service02 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，bean容器存在bean <code>service01</code> 和 <code>com.xxx.Service02</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean(Service02.class)</span><br><span class="line">class Service01 &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Service02 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，bean容器不存在bean。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Bean(Service02.class)</span><br><span class="line">class Service01 &#123;&#125;</span><br><span class="line"></span><br><span class="line">class Service02 &#123;</span><br><span class="line">    Service02(String id) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，报错。由于<code>@Import</code>注入的bean 只能默认调用其无参构造器。</p>
<p>下面我们来看看<code>ImportBeanDefinitionRegistrar</code>接口的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface to be implemented by types that register additional bean definitions when</span><br><span class="line"> * processing @&#123;@link Configuration&#125; classes. Useful when operating at the bean definition</span><br><span class="line"> * level (as opposed to &#123;@code @Bean&#125; method/instance level) is desired or necessary.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Along with &#123;@code @Configuration&#125; and &#123;@link ImportSelector&#125;, classes of this type</span><br><span class="line"> * may be provided to the @&#123;@link Import&#125; annotation (or may also be returned from an</span><br><span class="line"> * &#123;@code ImportSelector&#125;).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;An &#123;@link ImportBeanDefinitionRegistrar&#125; may implement any of the following</span><br><span class="line"> * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces, and their respective</span><br><span class="line"> * methods will be called prior to &#123;@link #registerBeanDefinitions&#125;:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;See implementations and associated unit tests for usage examples.</span><br><span class="line"> *</span><br><span class="line"> * @author Chris Beams</span><br><span class="line"> * @since 3.1</span><br><span class="line"> * @see Import</span><br><span class="line"> * @see ImportSelector</span><br><span class="line"> * @see Configuration</span><br><span class="line"> */</span><br><span class="line">public interface ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Register bean definitions as necessary based on the given annotation metadata of</span><br><span class="line">	 * the importing &#123;@code @Configuration&#125; class.</span><br><span class="line">	 * &lt;p&gt;Note that &#123;@link BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span><br><span class="line">	 * registered here, due to lifecycle constraints related to &#123;@code @Configuration&#125;</span><br><span class="line">	 * class processing.</span><br><span class="line">	 * @param importingClassMetadata annotation metadata of the importing class</span><br><span class="line">	 * @param registry current bean definition registry</span><br><span class="line">	 */</span><br><span class="line">	void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>importingClassMetadata</code>: 正在被导入的类的元数据信息；</li>
<li><code>registry</code>: 中文翻译：“登记处”，可通过它来操作IOC容器。</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Service02 &#123;&#125;</span><br><span class="line"></span><br><span class="line">public class Service02BeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        BeanDefinitionBuilder service02 = BeanDefinitionBuilder.rootBeanDefinition(Service02.class);</span><br><span class="line">        registry.registerBeanDefinition(&quot;service00000002&quot;, service02.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(Service02BeanDefinitionRegistrar.class)</span><br><span class="line">public class Service01 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>最终能够得到<code>service01</code> 和 <code>service00000002</code>。</p>
<p>实际上，其作用是：在项目启动时，全局扫描<code>@Import</code>，将其中的类进行Bean注入，注入过程中发现是<code>ImportBeanDefinitionRegistrar</code>的实现类，则会给到xxx 执行，以注入满足我们自定义注入规则的类。</p>
<p>下面再看看<code>ImportSelector</code>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Interface to be implemented by types that determine which @&#123;@link Configuration&#125;</span><br><span class="line"> * class(es) should be imported based on a given selection criteria, usually one or</span><br><span class="line"> * more annotation attributes.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;An &#123;@link ImportSelector&#125; may implement any of the following</span><br><span class="line"> * &#123;@link org.springframework.beans.factory.Aware Aware&#125; interfaces,</span><br><span class="line"> * and their respective methods will be called prior to &#123;@link #selectImports&#125;:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125;&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanFactoryAware BeanFactoryAware&#125;&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.beans.factory.BeanClassLoaderAware BeanClassLoaderAware&#125;&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;&#123;@link org.springframework.context.ResourceLoaderAware ResourceLoaderAware&#125;&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&#123;@code ImportSelector&#125; implementations are usually processed in the same way</span><br><span class="line"> * as regular &#123;@code @Import&#125; annotations, however, it is also possible to defer</span><br><span class="line"> * selection of imports until all &#123;@code @Configuration&#125; classes have been processed</span><br><span class="line"> * (see &#123;@link DeferredImportSelector&#125; for details).</span><br><span class="line"> *</span><br><span class="line"> * @author Chris Beams</span><br><span class="line"> * @since 3.1</span><br><span class="line"> * @see DeferredImportSelector</span><br><span class="line"> * @see Import</span><br><span class="line"> * @see ImportBeanDefinitionRegistrar</span><br><span class="line"> * @see Configuration</span><br><span class="line"> */</span><br><span class="line">public interface ImportSelector &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Select and return the names of which class(es) should be imported based on</span><br><span class="line">	 * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class.</span><br><span class="line">	 */</span><br><span class="line">	String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用也是可以给我们自定义想要注入哪些bean 类型，配置起来更简单，如以下例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AAAImportSelector implements ImportSelector &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        return new String[]&#123;Service02.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果混用三者，加以分析Spring Boot启动上下文，其加载顺序为：</p>
<ol>
<li>Application的 <code>main</code>方法中的 <code>SpringApplication.run(...)</code>；</li>
<li>所有<code>@Import({xxx})</code>中的<code>ImportSelector</code>实现类；</li>
<li>所有<code>@Import({xxx})</code>中的<code>ImportBeanDefinitionRegistrar</code>实现类；</li>
<li>所有 <code>ApplicationContextAware</code> 的实现类的 <code>setApplicationContext(...)</code>方法；</li>
<li>所有<code>@Import({xxx})</code>中的<code>ImportSelector</code>实现类中想要注入的类的无参构造器；</li>
<li>所有<code>@Import({Service02.class})</code>中的 <code>Service02</code>类的构造器；</li>
<li>类内部的带有<code>@Bean</code>的方法；</li>
<li>所有<code>@Import({xxx})</code>中的<code>ImportBeanDefinitionRegistrar</code>实现类中想要注入的类的无参构造器；</li>
<li>对下一个<code>@Component/@Configuration</code>修饰的类循环第5、6、7、8步。（注意：这里不是优先执行<code>@Configuration</code>后执行<code>@Component</code>, 而是按照类名称字典排序来顺序扫描的。）</li>
</ol>
<h1 id="跟着源码的步伐"><a href="#跟着源码的步伐" class="headerlink" title="跟着源码的步伐"></a>跟着源码的步伐</h1><h2 id="（一）SpringBoot程序启动过程"><a href="#（一）SpringBoot程序启动过程" class="headerlink" title="（一）SpringBoot程序启动过程"></a>（一）SpringBoot程序启动过程</h2><p>以下过程是SpringBoot程序启动过程的代码执行过程：</p>
<ol>
<li><code>SpringApplication.run(String... args)</code><ol>
<li><code>stopWatch.start();</code>：启动秒表</li>
<li><code>System.setProperty(&quot;java.awt.headless&quot;, true/false);</code>：设置headless 为<code>true</code>or<code>false</code>。<blockquote>
<p>Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。后端开发者往往需要这个模式，因为服务器（如提供Web服务的主机）往往可能缺少前述设备，但又需要使用他们提供的功能，生成相应的数据，以提供给客户端（如浏览器所在的配有相关的显示设备、键盘和鼠标的主机）。</p>
</blockquote>
</li>
<li>获取<code>SpringApplicationRunListeners</code>并让<code>listeners.starting()</code><ol>
<li>实际上，是找到<code>EventPublishingRunListener</code>等bean 对象，并遍历让这些listener执行其<code>starting()</code>方法。</li>
<li><code>SpringApplicationRunListener</code>接口专门监听<code>SpringApplication.run()</code>，每次程序启动都会创建一个其实现类（如：<code>EventPublishingRunListener</code>）。</li>
<li>背后是让<code>EventPublishingRunListener</code>里头的<code>initialMulticaster</code>去分发一个<code>ApplicationStartingEvent</code>，这个event 是在 <code>Environment</code>和<code>ApplicationContext</code>可用之前，且<code>ApplicationListener</code>注册之后，发出的。</li>
</ol>
</li>
<li><code>prepareEnvironment()</code><ol>
<li>创建environment（<code>StandardServletEnvironment</code> or <code>StandardReactiveWebEnvironment</code> or <code>StandardEnvironment</code>）</li>
<li>发送<code>ApplicationEnvironmentPreparedEvent</code></li>
</ol>
</li>
<li>创建<code>ConfigurableApplicationContext</code>，同样有三种选择：Servlet、Reactive、default。</li>
<li>…..</li>
<li><code>prepareContext()</code><ol>
<li><code>postProcessApplicationContext(context)</code></li>
</ol>
</li>
<li><code>refreshContext(context)</code><ol>
<li><code>refresh(context)</code><ol>
<li>判断applicationContext 属于 AbstractApplicationContext 类，并 调用其 <code>refresh()</code><ol>
<li>进入同步块（this.startupShutdownMonitor 的对象锁）</li>
<li><code>prepareRefresh();</code></li>
<li>Tell the subclass to refresh the internal bean factory</li>
<li>Prepare the bean factory for use in this context. 此时， beanFactory 中的 beanDefinedMap 中，只有几个bean。</li>
<li><code>postProcessBeanFactory();</code>   Allows post-processing of the bean factory in context subclasses.</li>
<li><code>invokeBeanFactoryPostProcessors();</code>     Invoke factory processors registered as beans in the context.<ol>
<li><strong><code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code></strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><code>afterRefresh(context);</code></li>
<li><code>stopWatch.stop();</code></li>
<li><code>listeners.started(context);</code></li>
<li><code>callRunners(context, {});</code></li>
</ol>
</li>
</ol>
<h2 id="（二）ConfigurationClassPostProcessor"><a href="#（二）ConfigurationClassPostProcessor" class="headerlink" title="（二）ConfigurationClassPostProcessor"></a>（二）ConfigurationClassPostProcessor</h2><p>好，然后我们看看<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code>里头到底做了什么？</p>
<blockquote>
<p>答： for 循环 遍历 <code>postProcessors</code>，拿到每一个 <code>BeanDefinitionRegistryPostProcessor</code>或其子类，然后，对每一个postProcessoer item 都调用其<code>postProcessBeanDefinitionRegistry()</code> 方法，把 <code>registry</code> 传给它。</p>
</blockquote>
<p>其中，就会找到<code>ConfigurationClassPostProcessor</code>类对象，并调用其方法。</p>
<p>看看这个 <code>ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()</code> 方法：</p>
<ul>
<li>作用：看方法源码注释：Derive further bean definitions from the configuration classes in the registry.【从注册表中的配置类派生更多的bean定义。】</li>
<li>内部方法注释： Build and validate a configuration model based on the registry of 带有<code>@Configuration</code>的classes. 【基于带有<code>@Configuration</code>的类的注册表构建和验证配置模型。】</li>
<li>内部方法过程：<ol>
<li>首先查看是否是配置类，如果是就加入<code>configCandidates</code>候选者列表中。</li>
<li>如果<code>configCandidates</code>为空，则直接返回。</li>
<li>否则，对这些配置类根据<code>@Order</code>排序(如果有配<code>@Order</code>)，如果一个有<code>@Order</code>，另一个没有配，那么，有<code>@Order</code>的排在前面。</li>
<li>Detect any custom bean name generation strategy supplied through the enclosing application context 【检测通过封闭应用程序上下文提供的任何自定义bean名称生成策略。】</li>
<li>创建 <code>ConfigurationClassParser</code> （配置类的解析类）</li>
<li>调用<code>ConfigurationClassParser.parse()</code>方法，开始解析<code>@Configuration</code>配置类。</li>
</ol>
</li>
</ul>
<h2 id="（三）ConfigurationClassParser-parse"><a href="#（三）ConfigurationClassParser-parse" class="headerlink" title="（三）ConfigurationClassParser.parse()"></a>（三）ConfigurationClassParser.parse()</h2><p>好，再去看，到底这个<code>ConfigurationClassParser.parse()</code>方法会做什么事情？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123;</span><br><span class="line">    this.deferredImportSelectors = new LinkedList&lt;DeferredImportSelectorHolder&gt;();</span><br><span class="line">    </span><br><span class="line">    for (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        BeanDefinition bd = holder.getBeanDefinition();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (bd instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(</span><br><span class="line">                    &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processDeferredImportSelectors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>遍历每一个 <code>BeanDefinitionHolder</code> 候选者 （实际上只有一个候选者，那就是我们程序的入口类<code>Application.java</code>的对象，名叫<code>application</code>）</li>
<li>看看这个候选者的<code>BeanDefinition</code>属于三种类型中的哪一种（一般会进第一种），但背后都是调用一个<code>parse()</code>方法。</li>
<li>然后，在方法内部调用<code>processConfigurationClass()</code>方法，进行处理。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void processConfigurationClass(ConfigurationClass configClass) throws IOException &#123;</span><br><span class="line">    if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConfigurationClass existingClass = this.configurationClasses.get(configClass);</span><br><span class="line">    //在这里处理Configuration重复import</span><br><span class="line">    //如果同一个配置类被处理两次，两次都属于被import的则合并导入类，返回。如果配置类不是被导入的，则移除旧使用新的配置类</span><br><span class="line">    if (existingClass != null) &#123;</span><br><span class="line">        if (configClass.isImported()) &#123;</span><br><span class="line">            if (existingClass.isImported()) &#123;</span><br><span class="line">                existingClass.mergeImportedBy(configClass);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            this.configurationClasses.remove(configClass);</span><br><span class="line">            for (Iterator&lt;ConfigurationClass&gt; it = this.knownSuperclasses.values().iterator(); it.hasNext();) &#123;</span><br><span class="line">                if (configClass.equals(it.next())) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归地处理配置类及其超类层次结构。</span><br><span class="line">    SourceClass sourceClass = asSourceClass(configClass);</span><br><span class="line">    do &#123;</span><br><span class="line">      //接着往下看吧</span><br><span class="line">        sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">    &#125;</span><br><span class="line">    while (sourceClass != null);</span><br><span class="line"></span><br><span class="line">    this.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line"></span><br><span class="line">    if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">			// 处理递归类</span><br><span class="line">			processMemberClasses(configClass, sourceClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    // 处理@PropertySource注解</span><br><span class="line">    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">            org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">        if (this.environment instanceof ConfigurableEnvironment) &#123;</span><br><span class="line">            processPropertySource(propertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            logger.warn(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                    &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理 @ComponentScan 注解</span><br><span class="line">    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">            sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">    if (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">            !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">        for (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">            // The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span><br><span class="line">            Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                    this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">            // Check the set of scanned definitions for any further config classes and parse recursively if needed</span><br><span class="line">            for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">                if (bdCand == null) &#123;</span><br><span class="line">                    bdCand = holder.getBeanDefinition();</span><br><span class="line">                &#125;</span><br><span class="line">                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123;</span><br><span class="line">                    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //处理Import注解，这个是咱们的菜</span><br><span class="line">    processImports(configClass, sourceClass, getImports(sourceClass), true);</span><br><span class="line"></span><br><span class="line">    // 处理@ImportResource 注解</span><br><span class="line">    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;</span><br><span class="line">        AnnotationAttributes importResource =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">        String[] resources = importResource.getStringArray(&quot;locations&quot;);</span><br><span class="line">        Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;);</span><br><span class="line">        for (String resource : resources) &#123;</span><br><span class="line">            String resolvedResource = this.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">            configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理包含@Bean注解的方法</span><br><span class="line">    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">    for (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理普通方法</span><br><span class="line">    processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    if (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">        String superclass = sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">        if (!superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">            this.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">            // Superclass found, return its annotation metadata and recurse</span><br><span class="line">            return sourceClass.getSuperClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们就会发现，实际上，上面的代码就会处理<code>@Bean</code>、<code>@ImportSource</code>、<code>@Import</code>、<code>@ComponentScan</code>、<code>@PropertySource</code>。</p>
<p>我们focus 看 <code>@Import</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processImports(ConfigurationClass configClass, SourceClass currentSourceClass,</span><br><span class="line">        Collection&lt;SourceClass&gt; importCandidates, boolean checkForCircularImports) &#123;</span><br><span class="line"></span><br><span class="line">    if (importCandidates.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">        this.problemReporter.error(new CircularImportProblem(configClass, this.importStack));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        this.importStack.push(configClass);</span><br><span class="line">        try &#123;</span><br><span class="line">            for (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">                // 首先， 判断如果被import的是 ImportSelector.class 接口的实现， 那么初始化这个被Import的类， 然后调用它的selectImports方法去获得所需要的引入的configuration， 然后递归处理</span><br><span class="line">                if (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    ImportSelector selector = BeanUtils.instantiateClass(candidateClass, ImportSelector.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            selector, this.environment, this.resourceLoader, this.registry);</span><br><span class="line">                    if (this.deferredImportSelectors != null &amp;&amp; selector instanceof DeferredImportSelector) &#123;</span><br><span class="line">                        this.deferredImportSelectors.add(</span><br><span class="line">                                new DeferredImportSelectorHolder(configClass, (DeferredImportSelector) selector));</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">                        Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">                        processImports(configClass, currentSourceClass, importSourceClasses, false);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 其次， 判断如果被import的是 ImportBeanDefinitionRegistrar 接口的实现， 那么初始化后将对当前对象的处理委托给这个ImportBeanDefinitionRegistrar</span><br><span class="line">                else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">                    ImportBeanDefinitionRegistrar registrar =</span><br><span class="line">                            BeanUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class);</span><br><span class="line">                    ParserStrategyUtils.invokeAwareMethods(</span><br><span class="line">                            registrar, this.environment, this.resourceLoader, this.registry);</span><br><span class="line">                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                     // 最后，将import引入的类作为一个正常的类来处理</span><br><span class="line">                    this.importStack.registerImport(</span><br><span class="line">                            currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">                    processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(</span><br><span class="line">                    &quot;Failed to process import candidates for configuration class [&quot; +</span><br><span class="line">                    configClass.getMetadata().getClassName() + &quot;]&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            this.importStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们知道， 如果你引入的是一个正常的component， 那么会作为 <code>@Compoent</code> 或者 <code>@Configuration</code> 来处理， 这样在<code>BeanFactory</code>里边可以通过<code>getBean()</code>拿到， 但如果你是 <code>ImportSelector</code> 或者 <code>ImportBeanDefinitionRegistrar</code> 接口的实现， 那么spring并不会将他们注册到<code>beanFactory</code>中，而只是调用他们的方法。</p>
<p>好，由此可见<code>@Import</code>导入流程和导入顺序。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发修炼--volatile关键字</title>
    <url>/Java%E5%B9%B6%E5%8F%91%E4%BF%AE%E7%82%BC-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="如何理解volatile关键字"><a href="#如何理解volatile关键字" class="headerlink" title="如何理解volatile关键字"></a>如何理解volatile关键字</h1><p>被 <code>volatile</code> 修饰的共享变量，会满足以下两个性质：</p><ul>
<li>保证了不同线程对该变量操作的内存可见性;</li>
<li>禁止指令重排序</li>
</ul><h1 id="什么是内存可见性"><a href="#什么是内存可见性" class="headerlink" title="什么是内存可见性"></a>什么是内存可见性</h1><p>我们先回顾以下JMM（Java内存模型）。</p><p>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级（就速度而言：CPU高速缓存 &gt;&gt; 内存 &gt;&gt; 磁盘），所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</p><a id="more"></a>



<p>JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p>
<blockquote>
<p>相当于：我和妈妈分别在各自手机中缓存我的vlog，虽然vlog在网络上是大家共享的资源，但是还是缓存在各自的手机上，想看不用等。看完后我和妈妈都可以修改我的vlog，修改好可以立即上传到网络，也可以等一会再上传。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/01/12/loAC2d.png" alt="loAC2d.png"></p>
<p>线程执行时：</p>
<ol>
<li>首先会从主存中read变量值；</li>
<li>再将变量值load到工作内存中的副本中；</li>
<li>然后再传给处理器执行；</li>
<li>在执行完毕后再给工作内存中的副本赋值；</li>
<li>随后工作内存再把值传回给主内存，此时，主存更新</li>
</ol>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i = i = 1;</span><br></pre></td></tr></table></figure>
<p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>load i from 主存（i = 0）</td>
<td></td>
</tr>
<tr>
<td>i+1（i = 1）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>load i from 主存（i = 0）</td>
</tr>
<tr>
<td></td>
<td>i+1（i = 1）</td>
</tr>
<tr>
<td>save i to 主存（i = 1）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>save i to 主存（i = 1）</td>
</tr>
</tbody></table>
<p>这样一来，就可能出现 “少加” 的情况，如果最后的写回生效的慢，你再读取i的值，都可能是0，也就是<strong>缓存不一致问题</strong>。</p>
<p>JMM主要就是围绕着如何在并发过程中如何处理<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而<code>volatile</code>跟<strong>可见性</strong>和<strong>有序性</strong>都有关。</p>
<blockquote>
<p>注意，这里说的几个特征，是说的JMM要解决和保证的特征，类似的，事务也有几大特性：ACID</p>
<ul>
<li>Atomicity 原子性</li>
<li>Consistency 一致性</li>
<li>Isolcation 隔离性</li>
<li>Durability 持久性</li>
</ul>
<p>这两者所说的，也就只有 “原子性”可以相提并论。所以，不要搞混！</p>
</blockquote>
<h2 id="1-原子性（Atomicty）"><a href="#1-原子性（Atomicty）" class="headerlink" title="1. 原子性（Atomicty）"></a>1. 原子性（Atomicty）</h2><p>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i = 2;     // 原子性操作</span><br><span class="line">j = i;     // 2步操作：先读取i的值，然后赋值给j</span><br><span class="line">i++;       // 3步操作：先读取i的值，然后加1，最后写回主内存</span><br><span class="line">i = i + 1; // 3步操作：同上</span><br></pre></td></tr></table></figure>
<p>所以，严格来说，只有<code>i = 2;</code> 满足原子性。</p>
<blockquote>
<p>有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</p>
</blockquote>
<p>JMM只实现了基本的原子性，像上面<code>i++</code>那样的操作，必须借助于<code>synchronized</code>和<code>Lock</code>来保证整块代码的原子性了。线程在释放锁之前，必然会把 <code>i</code> 的值刷回到主存的。</p>
<h2 id="2-可见性（Visibility）"><a href="#2-可见性（Visibility）" class="headerlink" title="2. 可见性（Visibility）"></a>2. 可见性（Visibility）</h2><p>说到可见性，Java就是利用volatile来提供可见性的。<br>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。<br>其实通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是<code>synchronized</code>和<code>Lock</code>的开销都更大。</p>
<p>综上所述，我们得有一个认识：<code>volatile</code>和<code>synchronized</code>所说的“可见性”，实际上都是基于锁，或者一种约定，这个在后面会说。</p>
<h2 id="3-有序性（Ordering）"><a href="#3-有序性（Ordering）" class="headerlink" title="3. 有序性（Ordering）"></a>3. 有序性（Ordering）</h2><p>JMM是允许编译器和处理器对指令重排序的，但是规定了<strong>as-if-serial</strong>语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double pi = 3.14;    //A</span><br><span class="line">double r = 1;        //B</span><br><span class="line">double s= pi * r * r;//C</span><br></pre></td></tr></table></figure>
<p>以上代码，可以是 <code>A -&gt; B -&gt; C</code>，也可以是 <code>B -&gt; A -&gt; C</code>，因为A和B相互不依赖，而C则依赖A和B，所以，A和B随便怎么换，但是C不能排到A或B前面。<strong>JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题</strong>。</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，如果单线程执行<code>write() -&gt; multiply()</code> 是完全没问题的。但是，如果线程A执行<code>write</code>，线程B执行<code>multiply</code>，那就可能出现<strong>多线程时指令重排序问题（无法保证多线程时的结果最终一致性）</strong></p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody><tr>
<td>flag = true;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>if(flag)</td>
</tr>
<tr>
<td></td>
<td>int ret = a * a;</td>
</tr>
<tr>
<td>a = 2;</td>
<td></td>
</tr>
</tbody></table>
<p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p>
<h1 id="JMM具备一些先天的有序性"><a href="#JMM具备一些先天的有序性" class="headerlink" title="JMM具备一些先天的有序性"></a>JMM具备一些先天的有序性</h1><p>JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。<code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code>定义了如下happens-before规则：</p>
<blockquote>
<ol>
<li><strong>程序顺序规则</strong>： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li><strong>监视器锁规则</strong>：对一个线程的解锁，happens-before于随后对这个线程的加锁</li>
<li><strong>volatile变量规则</strong>： 对一个volatile域的<strong>写</strong>，happens-before于后续对这个volatile域的<strong>读</strong></li>
<li><strong>传递性</strong>：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</li>
<li><strong>start()规则</strong>： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作</li>
<li><strong>join()原则</strong>： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li><strong>interrupt()原则</strong>： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</li>
<li><strong>finalize()原则</strong>：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
</ol>
</blockquote>
<p>第1条规则—程序顺序规则，是说在一个线程里，所有的操作都是按顺序的，<strong>但是</strong>在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p>
<p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p>
<p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p>
<p>第4条规则，就是happens-before的传递性。<br>后面几条就不再一一赘述了。</p>
<h1 id="volatile关键字如何保证可见性和有序性"><a href="#volatile关键字如何保证可见性和有序性" class="headerlink" title="volatile关键字如何保证可见性和有序性"></a>volatile关键字如何保证可见性和有序性</h1><p>那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。<br>这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p>
<p>如果这样不能理解，或者我们重看文章开头的图：<br><img src="https://s2.ax1x.com/2020/01/12/loAC2d.png" alt="loAC2d.png"><br>volatile的特殊性在于：</p>
<ol>
<li>操作 <code>use</code> 之前必须先执行 <code>read</code>和<code>load</code>操作。</li>
<li>操作 <code>assign</code> 之后必须执行 <code>store</code>和<code>write</code>操作。</li>
</ol>
<p>由特性性保证了read、load和use的操作连续性，assign、store和write的操作连续性，从而达到工作内存读取前必须刷新主存最新值；工作内存写入后必须同步到主存中。读取的连续性和写入的连续性，看上去像线程直接操作了主存，又因为主存实际是多线程可见的，于是可见性就体现了出来。</p>
<blockquote>
<p> 扩展：<br>上图的lock和unlock操作并不直接开放给用户使用，而是提供给像Synchronize关键字指定monitorenter和monitorexit隐式使用。关于Synchronize的监听器锁monitor，javac编译后会在作用的方法前后增加monitorenter和monitorexit指令，详细的可以查看Synchronize原理。</p>
</blockquote>
<p>继续看回上面提到的case代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种正常在多线程情况下，除了指令重排序的风险，也会有线程执行先后顺序的问题。也就是说，即使<code>1 --&gt; 2</code> 不会变成<code>2 --&gt; 1</code>，<code>2</code>和<code>3</code>的执行顺序也不一定就是<code>2--&gt;3</code>，因为是多个线程在跑。</p>
<p>我们让<code>flag</code>加上<code>volatile</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么线程A先执行<code>write</code>,线程B再执行<code>multiply</code>。根据happens-before原则，这个过程会满足以下3类规则：</p>
<ol>
<li>程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在 2 之前执行)</li>
<li>volatile规则：2 happens-before 3</li>
<li>传递性规则：1 happens-before 4</li>
</ol>
<p>从内存语义上来看:</p>
<ul>
<li><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</strong></li>
<li><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量</strong></li>
</ul>
<h1 id="volatile关键字能否保证原子性"><a href="#volatile关键字能否保证原子性" class="headerlink" title="volatile关键字能否保证原子性"></a>volatile关键字能否保证原子性</h1><p><strong>不能</strong>。</p>
<p>硬要说能，就是得看角度了。前面我们说单个变量的读/写操作，具有原子性，这个性质在Java里头是基本规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread.sleep(6000L);</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你很容易得到一个小于10000的值。</p>
<p>有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p>
<p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p>
<p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p>
<p>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</p>
<p>有人说，<code>volatile不是会使缓存行无效的吗？</code>但是这里线程A读取时，线程B还没有进行修改操作，所以并没有修改inc值，并不会触发volatile功能，所以线程B读取的时候，还是读的10，因为B不知道A要修改inc。</p>
<p>又有人说，线程B将11写回主存，<code>不会把线程A的缓存行设为无效吗？</code>但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p>
<p>因此，要想保证原子性，只能借助于<code>synchronized</code>,<code>Lock</code>以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<h1 id="volatile底层实现机制"><a href="#volatile底层实现机制" class="headerlink" title="volatile底层实现机制"></a>volatile底层实现机制</h1><p>通过在volatile变量的操作前后插入<strong>内存屏障</strong>的方式，控制后置指令排序无法排到屏障之前，并且使得CPU的Cache写入内存，写入动作也会触发别的CPU或内核无效化其Cache。</p>
<p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p>
<p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p>
<ol>
<li>重排序时不能把后面的指令重排序到内存屏障之前的位置；</li>
<li>使得本CPU的Cache写入内存；</li>
<li>写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</li>
</ol>
<h1 id="volatile-与-synchronized-的关系"><a href="#volatile-与-synchronized-的关系" class="headerlink" title="volatile 与 synchronized 的关系"></a>volatile 与 synchronized 的关系</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>volatile 与 synchronized 都属于关键字。</p>
<p>volatile 与 synchronized 都能保证可见性和有序性。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>只是分别对应的有序性规则不同，且实现方式也不同：</p>
<ul>
<li>volatile角度的有序性偏向于对目标对象的“写”操作必须保证在“读”操作之前，并通过内存屏障去保证目标对象相关代码的执行顺序。</li>
<li>synchronized 角度来看并不是说代码连执行顺序都不能变，而是想要保证最终结果一致性，然后，相关可优化的代码还是可以被重排序的。并通过加锁机制，并不是锁定代码执行顺序，而是锁定“厕所门”，同一时间片下，只能也给一个线程执行这一段被“锁”住的代码。</li>
</ul>
<blockquote>
<p>synchronized是无法禁止指令重排和处理器优化的。那么他是如何保证的有序性呢？</p>
<p>答： 这和as-if-serial语义有关。as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。简单说就是，as-if-serial语义保证了单线程中，不管指令怎么重排，最终的执行结果是不能被改变的。</p>
</blockquote>
<p>volatile关键字是无法保证原子性的，而synchronized通过monitorenter和monitorexit两个指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，即可保证不会出现CPU时间片在多个线程间切换，即可保证原子性。</p>
<h2 id="synchronized-比-volatile-重"><a href="#synchronized-比-volatile-重" class="headerlink" title="synchronized 比 volatile 重"></a>synchronized 比 volatile 重</h2><p>synchronized其实是一种加锁机制，那么既然是锁，天然就具备以下几个缺点：</p>
<ol>
<li><p>有性能损耗</p>
<blockquote>
<p>虽然在JDK 1.6中对synchronized做了很多优化，如如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等，但是他毕竟还是一种锁。</p>
<p>以上这几种优化，都是尽量想办法避免对Monitor进行加锁，但是，并不是所有情况都可以优化的，况且就算是经过优化，优化的过程也是有一定的耗时的。</p>
<p>所以，无论是使用同步方法还是同步代码块，在同步操作之前还是要进行加锁，同步操作之后需要进行解锁，这个加锁、解锁的过程是要有性能损耗的。</p>
<p>关于二者的性能对比，由于虚拟机对锁实行的许多消除和优化，使得我们很难量化这两者之间的性能差距，但是我们可以确定的一个基本原则是：volatile变量的读操作的性能小号普通变量几乎无差别，但是写操作由于需要插入内存屏障所以会慢一些，即便如此，volatile在大多数场景下也比锁的开销要低。</p>
</blockquote>
</li>
<li><p>产生阻塞</p>
<blockquote>
<p>无论是同步方法还是同步代码块，无论是ACC_SYNCHRONIZED还是monitorenter、monitorexit都是基于Monitor实现的。</p>
<p>基于Monitor对象，当多个线程同时访问一段同步代码时，首先会进入Entry Set，当有一个线程获取到对象的锁之后，才能进行The Owner区域，其他线程还会继续在Entry Set等待。并且当某个线程调用了wait方法后，会释放锁并进入Wait Set等待。</p>
</blockquote>
</li>
</ol>
<p>所以，synchronize实现的锁本质上是一种阻塞锁，也就是说多个线程要排队访问同一个共享对象。</p>
<p>而volatile是Java虚拟机提供的一种轻量级同步机制，他是基于内存屏障实现的。说到底，他并不是锁，所以他不会有synchronized带来的阻塞和性能损耗的问题。</p>
<h1 id="为什么DSL的单例模式中，instance要有volatile？"><a href="#为什么DSL的单例模式中，instance要有volatile？" class="headerlink" title="为什么DSL的单例模式中，instance要有volatile？"></a>为什么DSL的单例模式中，instance要有volatile？</h1><p>看看以下这个单例，一个典型的不完善的DSL（双重锁检查）单例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    privat Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized(Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么说它不完善呢？ 虽然在<code>synchronized</code>同步代码块内，能够保证同一时刻只会有一个线程执行，但是，<code>instance = new Singleton();</code> 始终是一个复合操作，相当于 2个步骤：</p>
<ol>
<li>JVM为对象分配一块内存M；</li>
<li>在内存M上为对象进行初始化<code>new Singleton()</code>；</li>
<li>将内存M的地址复制给instance变量：<code>instance = addr</code></li>
</ol>
<p>所以可能会出现 <code>1 --&gt; 3 --&gt; 2</code>这样的指令重排序情况，最终拿到了一个不完整的singleton对象，极有可能发生NPE异常，所以，加上<code>volatile</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    privat Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized(Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让线程顺序执行</title>
    <url>/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BA%BF%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p>看看Java 多线程 顺序执行的各种实现方式，并从中引申出各种多线程相关知识点。</p>
</blockquote>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这里有一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test01 &#123;</span><br><span class="line">    ThreadPoolExecutor pool = new ThreadPoolExecutor(3, 5, 6000, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    public void first()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;first .........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void second()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;second .........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void third()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;third .........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test01() &#123;</span><br><span class="line">        pool.submit(this::first);</span><br><span class="line">        pool.submit(this::second);</span><br><span class="line">        pool.submit(this::third);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test01 test = new Test01();</span><br><span class="line">        test.test01();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">third .........2019-10-11T09:25:17.421</span><br><span class="line">second .........2019-10-11T09:25:18.083</span><br><span class="line">first .........2019-10-11T09:25:19.082</span><br></pre></td></tr></table></figure>


<h1 id="方式一：用一个引用类型的共享对象"><a href="#方式一：用一个引用类型的共享对象" class="headerlink" title="方式一：用一个引用类型的共享对象"></a>方式一：用一个引用类型的共享对象</h1><blockquote>
<p>原理：<code>Object.wait()</code> 和 <code>Object.notifyAll()</code> 让线程进入<code>wait</code> 和 <code>blocked</code> 状态。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; lockList = new ArrayList&lt;&gt;();</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    synchronized (lockList) &#123;</span><br><span class="line">        first();</span><br><span class="line">        lockList.add(1);</span><br><span class="line">        lockList.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    synchronized (lockList) &#123;</span><br><span class="line">        while (lockList.size() != 1) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lockList.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        second();</span><br><span class="line">        lockList.add(1);</span><br><span class="line">        lockList.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    synchronized (lockList) &#123;</span><br><span class="line">        while (lockList.size() != 2) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lockList.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        third();</span><br><span class="line">        lockList.add(1);</span><br><span class="line">        lockList.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    synchronized (lockList) &#123;</span><br><span class="line">        while (lockList.size() != 3) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lockList.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fourth();</span><br><span class="line">        lockList.add(1);</span><br><span class="line">        lockList.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    synchronized (lockList) &#123;</span><br><span class="line">        while (lockList.size() != 4) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lockList.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fifth();</span><br><span class="line">        lockList.add(1);</span><br><span class="line">        lockList.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="方式二：利用-volatile关键字的特性"><a href="#方式二：利用-volatile关键字的特性" class="headerlink" title="方式二：利用 volatile关键字的特性"></a>方式二：利用 <code>volatile</code>关键字的特性</h1><blockquote>
<p>原理： <code>volatile</code>修饰的变量会控制读写时变量在线程间的可见性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile List&lt;Integer&gt; lockList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//.................</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    first();</span><br><span class="line">    lockList.add(1);</span><br><span class="line">&#125;);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    while (lockList.size() != 1);</span><br><span class="line">    second();</span><br><span class="line">    lockList.add(1);</span><br><span class="line">&#125;);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    while (lockList.size() != 2);</span><br><span class="line">    third();</span><br><span class="line">    lockList.add(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    while (lockList.size() != 3);</span><br><span class="line">    fourth();</span><br><span class="line">    lockList.add(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + &quot; start...&quot;);</span><br><span class="line">    while (lockList.size() != 4);</span><br><span class="line">    fifth();</span><br><span class="line">    lockList.add(1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="方式三：利用CountDownLatch"><a href="#方式三：利用CountDownLatch" class="headerlink" title="方式三：利用CountDownLatch"></a>方式三：利用CountDownLatch</h1><p>CountDownLatch 是 线程协同工作的招式之一，可读性会好一点，CountDownLatch 的 <code>count</code> 降低至 0，主线程才能继续运作，否则阻塞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CountDownLatch countDownLatchA = new CountDownLatch(1);</span><br><span class="line">CountDownLatch countDownLatchB = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    first();</span><br><span class="line">    countDownLatchA.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        countDownLatchA.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    second();</span><br><span class="line">    countDownLatchB.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        countDownLatchB.await();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    third();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="方式四：信号量Semaphore"><a href="#方式四：信号量Semaphore" class="headerlink" title="方式四：信号量Semaphore"></a>方式四：信号量Semaphore</h1><blockquote>
<p>利用信号量Semaphore初始permit值为0时，任何调用其<code>acquire()</code>方法的线程都会因为当前没有available的permit 而进入阻塞状态；而当调用<code>release()</code>方法即可将原本被持有的permit从原来线程中解放，并通知那些阻塞状态的等待permit 的线程去持有这个permit。</p>
<p>简单理解，就是：<code>acquire()</code>使得信号量的可用的permit 减一，而<code>release()</code>让可用的permit 加一。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore spa = new Semaphore(0);</span><br><span class="line">Semaphore spb = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    first();</span><br><span class="line">    spa.release();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        spa.acquire();</span><br><span class="line">        second();</span><br><span class="line">        spb.release();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        spb.acquire();</span><br><span class="line">        third();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h1 id="妙用线程池，否则阻塞你"><a href="#妙用线程池，否则阻塞你" class="headerlink" title="妙用线程池，否则阻塞你"></a>妙用线程池，否则阻塞你</h1><p>上述的case，我们都使用这样的一个线程池，去模拟三个线程去执行三个异步任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool = new ThreadPoolExecutor(3, 5, 6000, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>一般情况下，用它和用<code>new Thread()</code>在结果上并没有区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool.submit(() -&gt; &#123;print(&quot;first&quot;);&#125;);</span><br><span class="line">pool.submit(() -&gt; &#123;print(&quot;second&quot;);&#125;);</span><br><span class="line">pool.submit(() -&gt; &#123;print(&quot;third&quot;);&#125;);</span><br></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(() -&gt; &#123;print(&quot;first&quot;);&#125;).start();</span><br><span class="line">new Thread(() -&gt; &#123;print(&quot;second&quot;);&#125;).start();</span><br><span class="line">new Thread(() -&gt; &#123;print(&quot;third&quot;);&#125;).start();</span><br></pre></td></tr></table></figure>
<p>一样结果。</p>
<p>但是，像上面的case，如果我将执行<code>first()</code>的线程延迟一点执行，那么，用<code>new Thread()</code>没有问题，但是用线程池就得小心了！！</p>
<p>如果我现在使用一个这样的线程池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 6000, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(2));</span><br></pre></td></tr></table></figure>
<p>这个线程池，有一个常驻线程，另外有一个容量大小是2的队列。那么，如果我让<code>first()</code>线程慢一点跑，会怎么样呢？ 看看以下的例子：</p>
<p>正常情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test05 &#123;</span><br><span class="line">    ThreadPoolExecutor pool = new ThreadPoolExecutor(3, 3, 0, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(2));</span><br><span class="line"></span><br><span class="line">    public void first() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;等了2s&quot;);</span><br><span class="line">        System.out.println(&quot;first .........&quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void second() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;等了1s&quot;);</span><br><span class="line">        System.out.println(&quot;second .........&quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void third() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(300L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;等了300ms&quot;);</span><br><span class="line">        System.out.println(&quot;third .........&quot; + LocalDateTime.now());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        Semaphore spa = new Semaphore(0);</span><br><span class="line">        Semaphore spb = new Semaphore(0);</span><br><span class="line"></span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                spa.acquire();</span><br><span class="line">                second();</span><br><span class="line">                spb.release();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                spb.acquire();</span><br><span class="line">                third();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(400L);</span><br><span class="line">        pool.submit(() -&gt; &#123;</span><br><span class="line">            first();</span><br><span class="line">            spa.release();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Test05 test05 = new Test05();</span><br><span class="line">        test05.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool-1-thread-3等了2s</span><br><span class="line">first .........2019-10-14T19:55:12.376</span><br><span class="line">pool-1-thread-1等了1s</span><br><span class="line">second .........2019-10-14T19:55:13.377</span><br><span class="line">pool-1-thread-2等了300ms</span><br><span class="line">third .........2019-10-14T19:55:13.677</span><br></pre></td></tr></table></figure>

<p>如果将线程池从：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool = new ThreadPoolExecutor(3, 3, 0, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(2));</span><br></pre></td></tr></table></figure>
<p>改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 0, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(2));</span><br></pre></td></tr></table></figure>
<p>然后同样执行以上代码，去并发执行3个异步任务，那么，得到的结果是： <strong>无任何输出</strong></p>
<p><strong>为什么呢？</strong></p>
<p>我们知道，执行<code>first()</code>的线程被我们延时了400ms 才执行，并且现在，coreThreadCount + queueSize = 3，那么，整个执行过程如下：</p>
<ol>
<li>首先，submit第一个task，执行的是<code>second()</code>，发现此时核心线程池中的线程数小于coreThreadCount，于是创建常驻线程来执行，但是由于是<code>second()</code>方法，于是一直<code>while</code>等待；</li>
<li>然后，submit第二个task，执行的是<code>third()</code>，发现此时核心线程池已经满了(=1)，于是，去看看队列满了没？队列还没满（此时，空位是2），于是，扔进队列中等待常驻线程执行完毕后去队列找它；</li>
<li>400ms，整个过程中，唯一的常驻线程还在一直跑着第一个task；</li>
<li>最后，submit第三个task，执行的是<code>first()</code>方法，很关键，但是，由于发现核心线程池满了，但是队列还没满（此时，空位是1），于是，扔进队列中等待常驻线程执行完毕去队列找它；</li>
<li>最终，循环等待！（常驻线程等待<code>first()</code>执行，但是<code>first()</code>又在等待常驻线程来执行）</li>
</ol>
<p>于是，会一直pending！</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://juejin.im/post/5a2b53b7f265da432a7b821c#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5a2b53b7f265da432a7b821c#heading-4</a></li>
<li><a href="https://www.cnblogs.com/xz816111/p/8470048.html" target="_blank" rel="noopener">https://www.cnblogs.com/xz816111/p/8470048.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/75880892" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75880892</a></li>
<li><a href="https://leetcode-cn.com/problems/print-in-order/solution/javayou-jie-by-no-one-9/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/print-in-order/solution/javayou-jie-by-no-one-9/</a></li>
<li><a href="http://www.hollischuang.com/archives/1883" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1883</a></li>
<li><a href="https://www.hollischuang.com/archives/2637" target="_blank" rel="noopener">https://www.hollischuang.com/archives/2637</a></li>
<li><a href="https://www.hollischuang.com/archives/3928" target="_blank" rel="noopener">https://www.hollischuang.com/archives/3928</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 公式与数学表达式</title>
    <url>/Markdown%20%E5%85%AC%E5%BC%8F%E4%B8%8E%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>教你如何用Markdown写公式！！</p>
<a id="more"></a>

<blockquote>
<p><a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">在线MD公式生成器</a></p>
<p>如果是遇到一些MD编辑器是不支持公式的，不妨可以借助MathJax引擎:</p>
<ol>
<li>在markdown写作首部添加如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>之后就可以像在Latex或者Overleaf里面一样写公式喽</li>
</ol>
</blockquote>
<p>更复杂的公式写法，请参考：<a href="https://www.zybuluo.com/codeep/note/163962" target="_blank" rel="noopener">这里</a>，如果这个link出问题了，请看印象笔记，已剪辑。</p>
<h1 id="数学表达式的写法"><a href="#数学表达式的写法" class="headerlink" title="数学表达式的写法"></a>数学表达式的写法</h1><p>写一个累加表达式：$f(x)=\sum_{i=1}^n{k_i}$</p>
<p>常见公式汇总：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>案例</th>
<th>写法实现</th>
</tr>
</thead>
<tbody><tr>
<td><code>\times</code></td>
<td>乘</td>
<td>$x\times{y}$</td>
<td><code>$x\times{y}$</code></td>
</tr>
<tr>
<td><code>\cdot</code></td>
<td>乘</td>
<td>$x\cdot{y}$</td>
<td><code>$x\cdot{y}$</code></td>
</tr>
<tr>
<td><code>\ast</code></td>
<td>乘</td>
<td>$x\ast{y}$</td>
<td><code>$x\ast{y}$</code></td>
</tr>
<tr>
<td><code>\div</code></td>
<td>除</td>
<td>$x\div{y}$</td>
<td><code>$x\div{y}$</code></td>
</tr>
<tr>
<td><code>\frac</code></td>
<td>分数</td>
<td>$\frac{x}{y}$</td>
<td><code>$\frac{x}{y}$</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>上标</td>
<td>$x^y$</td>
<td><code>$x^y$</code></td>
</tr>
<tr>
<td><code>_</code></td>
<td>下标</td>
<td>$x_y$</td>
<td><code>$x_y$</code></td>
</tr>
<tr>
<td><code>\sqrt</code></td>
<td>开二次方</td>
<td>$\sqrt{x}$</td>
<td><code>$\sqrt{x}$</code></td>
</tr>
<tr>
<td><code>\sqrt</code></td>
<td>开方</td>
<td>$\sqrt[x]{y^4+3y-1}$</td>
<td><code>$\sqrt[x]{y^4+3y-1}$</code></td>
</tr>
<tr>
<td><code>\pm</code></td>
<td>加减</td>
<td>$x\pm{y}$</td>
<td><code>$x\pm{y}$</code></td>
</tr>
<tr>
<td><code>\mp</code></td>
<td>减加</td>
<td>$x\mp{y}$</td>
<td><code>$x\mp{y}$</code></td>
</tr>
<tr>
<td><code>\leq</code></td>
<td>小于等于</td>
<td>$x\leq{y}$</td>
<td><code>$x\leq{y}$</code></td>
</tr>
<tr>
<td><code>\geq</code></td>
<td>大于等于</td>
<td>$x\geq{y}$</td>
<td><code>$x\geq{y}$</code></td>
</tr>
<tr>
<td><code>\ngeq</code></td>
<td>不大于等于</td>
<td>$x\ngeq{y}$</td>
<td><code>$x\ngeq{y}$</code></td>
</tr>
<tr>
<td><code>\not\geq</code></td>
<td>不大于等于</td>
<td>$x\not\geq{y}$</td>
<td><code>$x\not\geq{y}$</code></td>
</tr>
<tr>
<td><code>\neq</code></td>
<td>不等于</td>
<td>$x\neq{y}$</td>
<td><code>$x\neq{y}$</code></td>
</tr>
<tr>
<td><code>\approx</code></td>
<td>约等于</td>
<td>$x\approx{y}$</td>
<td><code>$x\approx{y}$</code></td>
</tr>
<tr>
<td><code>\equiv</code></td>
<td>恒等于</td>
<td>$x\equiv{y}$</td>
<td><code>$x\equiv{y}$</code></td>
</tr>
<tr>
<td><code>\bigodot</code></td>
<td>定义运算符</td>
<td>$x\bigodot{y}=x+y^2$</td>
<td><code>$x\bigodot{y}=x+y^2$</code></td>
</tr>
<tr>
<td><code>\bigotimes</code></td>
<td>定义运算符</td>
<td>$x\bigotimes{y}=x+y^2$</td>
<td><code>$x\bigotimes{y}=x+y^2$</code></td>
</tr>
<tr>
<td><code>\in</code></td>
<td>属于</td>
<td>$x\in{y}$</td>
<td><code>$x\in{y}$</code></td>
</tr>
<tr>
<td><code>\notin</code></td>
<td>不属于</td>
<td>$x\notin{y}$</td>
<td><code>$x\notin{y}$</code></td>
</tr>
<tr>
<td><code>\subset</code></td>
<td>子集</td>
<td>$x\subset{y}$</td>
<td><code>$x\subset{y}$</code></td>
</tr>
<tr>
<td><code>\not\subset</code></td>
<td>非子集</td>
<td>$x\not\subset{y}$</td>
<td><code>$x\not\subset{y}$</code></td>
</tr>
<tr>
<td><code>\subseteq</code></td>
<td>子集</td>
<td>$x\subseteq{y}$</td>
<td><code>$x\subseteq{y}$</code></td>
</tr>
<tr>
<td><code>\supset</code></td>
<td>超集</td>
<td>$x\supset{y}$</td>
<td><code>$x\supset{y}$</code></td>
</tr>
<tr>
<td><code>\supseteq</code></td>
<td>超集</td>
<td>$x\supseteq{y}$</td>
<td><code>$x\supseteq{y}$</code></td>
</tr>
<tr>
<td><code>\cup</code></td>
<td>并</td>
<td>$x\cup{y}$</td>
<td><code>$x\cup{y}$</code></td>
</tr>
<tr>
<td><code>\cap</code></td>
<td>交</td>
<td>$x\cap{y}$</td>
<td><code>$x\cap{y}$</code></td>
</tr>
<tr>
<td><code>\log</code></td>
<td>对数</td>
<td>$\log(x)$</td>
<td><code>$\log(x)$</code></td>
</tr>
<tr>
<td><code>\overline</code></td>
<td>平均数</td>
<td>$\overline{x}$</td>
<td><code>$\overline{x}$</code></td>
</tr>
<tr>
<td><code>\overline</code></td>
<td>连线符号</td>
<td>$\overline{a+b+c+d}$</td>
<td><code>$\overline{a+b+c+d}$</code></td>
</tr>
<tr>
<td><code>\underline</code></td>
<td>下划线</td>
<td>$\underline{a+b+c+d}$</td>
<td><code>$\underline{a+b+c+d}$</code></td>
</tr>
<tr>
<td><code>\overbrace</code></td>
<td>上大括号</td>
<td>$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</td>
<td><code>$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</code></td>
</tr>
<tr>
<td><code>\underbrace</code></td>
<td>下大括号</td>
<td>$\underbrace{a+d}_3$</td>
<td><code>$\underbrace{a+d}_3$</code></td>
</tr>
<tr>
<td><code>\partial</code></td>
<td>部分</td>
<td>$\frac{\partial x}{\partial y}$</td>
<td><code>$\frac{\partial x}{\partial y}$</code></td>
</tr>
<tr>
<td><code>\lim</code></td>
<td>极限</td>
<td>$\lim_{x\to\infty}$</td>
<td><code>$\lim_{x\to\infty}$</code></td>
</tr>
<tr>
<td><code>\displaystyle</code></td>
<td>块公式格式</td>
<td>$\displaystyle\lim_{x\to\infty}$</td>
<td><code>$\displaystyle\lim_{x\to\infty}$</code></td>
</tr>
<tr>
<td><code>\sum</code></td>
<td>求和</td>
<td>$\sum_1^n$</td>
<td><code>$\sum_1^n$</code></td>
</tr>
<tr>
<td><code>\infty</code></td>
<td>极限</td>
<td>$\sum_{i=0}^\infty{i^2}$</td>
<td><code>$\sum_{i=0}^\infty{i^2}$</code></td>
</tr>
<tr>
<td><code>\int</code></td>
<td>积分</td>
<td>$\int_0^1{x^2}{dx}$</td>
<td><code>$\int_0^1{x^2}{dx}$</code></td>
</tr>
<tr>
<td><code>\ldots</code></td>
<td>底端对齐的省略号</td>
<td>$1,2,\ldots,n$</td>
<td><code>$1,2,\ldots,n$</code></td>
</tr>
<tr>
<td><code>\cdots</code></td>
<td>中线对齐的省略号</td>
<td>$x_1^2 + x_2^2 + \cdots + x_n^2$</td>
<td><code>$x_1^2 + x_2^2 + \cdots + x_n^2$</code></td>
</tr>
<tr>
<td><code>\uparrow</code></td>
<td>上箭头</td>
<td>$\uparrow$</td>
<td><code>$\uparrow$</code></td>
</tr>
<tr>
<td><code>\Uparrow</code></td>
<td>上箭头</td>
<td>$\Uparrow$</td>
<td><code>$\Uparrow$</code></td>
</tr>
</tbody></table>
<h1 id="数学符号输出"><a href="#数学符号输出" class="headerlink" title="数学符号输出"></a>数学符号输出</h1><table>
<thead>
<tr>
<th>数学符号</th>
<th>写法</th>
</tr>
</thead>
<tbody><tr>
<td>$\alpha$</td>
<td><code>$\alpha$</code></td>
</tr>
<tr>
<td>$\beta$</td>
<td><code>$\beta$</code></td>
</tr>
<tr>
<td>$\gamma$</td>
<td><code>$\gamma$</code></td>
</tr>
<tr>
<td>$\delta$</td>
<td><code>$\delta$</code></td>
</tr>
<tr>
<td>$\epsilon$</td>
<td><code>$\epsilon$</code></td>
</tr>
<tr>
<td>$\zeta$</td>
<td><code>$\zeta$</code></td>
</tr>
<tr>
<td>$\eta$</td>
<td><code>$\eta$</code></td>
</tr>
<tr>
<td>$\theta$</td>
<td><code>$\theta$</code></td>
</tr>
<tr>
<td>$\iota$</td>
<td><code>$\iota$</code></td>
</tr>
<tr>
<td>$\kappa$</td>
<td><code>$\kappa$</code></td>
</tr>
<tr>
<td>$\lambda$</td>
<td><code>$\lambda$</code></td>
</tr>
<tr>
<td>$\mu$</td>
<td><code>$\mu$</code></td>
</tr>
<tr>
<td>$\Xi$</td>
<td><code>$\Xi$</code></td>
</tr>
<tr>
<td>$\omicron$</td>
<td><code>$\omicron$</code></td>
</tr>
<tr>
<td>$\pi$</td>
<td><code>$\pi$</code></td>
</tr>
<tr>
<td>$\rho$</td>
<td><code>$\rho$</code></td>
</tr>
<tr>
<td>$\sigma$</td>
<td><code>$\sigma$</code></td>
</tr>
<tr>
<td>$\chi$</td>
<td><code>$\chi$</code></td>
</tr>
<tr>
<td>$\upsilon$</td>
<td><code>$\upsilon$</code></td>
</tr>
<tr>
<td>$\phi$</td>
<td><code>$\phi$</code></td>
</tr>
<tr>
<td>$\psi$</td>
<td><code>$\psi$</code></td>
</tr>
<tr>
<td>$\omega$</td>
<td><code>$\omega$</code></td>
</tr>
</tbody></table>
<h2 id="相关快捷键"><a href="#相关快捷键" class="headerlink" title="相关快捷键"></a>相关快捷键</h2><ol>
<li>喊出命令提示：<code>ctrl+shift+P / ctrl+ shift+ A</code></li>
<li>format 内容：<code>Format Document</code></li>
<li>加粗：<code>Ctrl + B</code></li>
<li>倾斜：<code>Ctrl + I</code></li>
<li>导出 PDF：<code>Convert Markdown to PDF</code></li>
<li>导出 Html：<code>Markdown: Print current document to HTML</code></li>
<li>导出支持公式显示的 Html：<code>Markdown: Clip Markdown+Math to HTML</code></li>
</ol>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>git指南</title>
    <url>/git%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="/images/git_01.png" alt=""></p>
<a id="more"></a>

<h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><ul>
<li>克隆到githome目录  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone ssh://xxx.com:myProject ./githome</span><br></pre></td></tr></table></figure></li>
<li>只克隆Dev分支到本地  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b Dev ssh://xxx.com:myProject</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="拉取与推送"><a href="#拉取与推送" class="headerlink" title="拉取与推送"></a>拉取与推送</h1><h2 id="fetch-和-pull-的区别"><a href="#fetch-和-pull-的区别" class="headerlink" title="fetch 和 pull 的区别"></a>fetch 和 pull 的区别</h2><ul>
<li><code>$ git fetch origin develop</code>：只是拉取远程的develop分支的最新提交版本，到本地的<code>.git/refs/remotes</code> 目录【远程版本库】中，并没有合并到本地分支，也就是本地分支仍然只有<code>master</code>，没有<code>develop</code>.【本地版本库目录：<code>.git/refs/heads</code>】</li>
<li><code>$ git pull origin develop</code>：相当于：<code>git fetch origin develop</code>+<code>git merge develop</code>; 获取远程develop分支，并将其合并到当前你所在的本地分支。</li>
<li>将本地当前分支推送到远程仓库的master分支  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li>
<li>将dev分支推送到远程仓库的master分支  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master:dev</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Commit-的简写"><a href="#Commit-的简写" class="headerlink" title="Commit 的简写"></a>Commit 的简写</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;something&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;something&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="区分-merge-和-rebase"><a href="#区分-merge-和-rebase" class="headerlink" title="区分 merge 和 rebase"></a>区分 merge 和 rebase</h2><p>将 <from> 的内容整合过来，在当前分支生成一个新的commit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge &lt;from&gt;</span><br></pre></td></tr></table></figure>
<p>将当前分支的内容挂在<to>分支之上，相当于在<to>分支上长了一个新的commit。[如果当前分支在<to>分支的继承链中，直接当前分支的指针前移]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase &lt;to&gt;</span><br></pre></td></tr></table></figure>

<h2 id="拉取远程git项目的某个分支"><a href="#拉取远程git项目的某个分支" class="headerlink" title="拉取远程git项目的某个分支"></a>拉取远程git项目的某个分支</h2><ul>
<li>master分支：默认会拉取的分支，直接<code>git clone URL</code>就可以获取到。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://git.oschina.net/androidJP/Demo.git</span><br></pre></td></tr></table></figure></li>
<li>非master分支：需要<code>git fetch</code>和<code>git checkout -b XXX remote仓库/XXX</code>结合使用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://git.oschina.net/androidJP/Demo.git</span><br><span class="line">///项目的默认分支被克隆下来了</span><br><span class="line">$ git branch</span><br><span class="line">/// 输出：如master 等已经拉取到的分支名和当前分支</span><br><span class="line">$ git fetch</span><br><span class="line">$ git checkout -b develop origin/develop</span><br><span class="line">/// 拉取远程的develop分支并本地切换到了develop分支</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="远程分支pull不了"><a href="#远程分支pull不了" class="headerlink" title="远程分支pull不了"></a>远程分支pull不了</h2><p>原因：你的本地分支没有关联上远程分支。</p>
<ul>
<li>方法一：直接指定要pull哪个远程分支（默认会merge）：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull origin &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>方法二：绑定某个分支，之后就直接<code>git pull</code> 即可：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/&lt;远程分支名&gt;  &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="本地创建一个新分支并推送到远程，让远程也生成新分支"><a href="#本地创建一个新分支并推送到远程，让远程也生成新分支" class="headerlink" title="本地创建一个新分支并推送到远程，让远程也生成新分支"></a>本地创建一个新分支并推送到远程，让远程也生成新分支</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b branchA</span><br><span class="line">....</span><br><span class="line">$ git add . </span><br><span class="line">$ git commit -m &quot;what you change&quot;</span><br><span class="line">/// 将本地分支推到远程的同名分支上</span><br><span class="line">$ git push origin branchA</span><br><span class="line">或者  (-u 的作用是选定默认远程仓库)</span><br><span class="line">$ git push -u origin branchA</span><br></pre></td></tr></table></figure>

<h2 id="将本地project-push到自己的github-码云仓库中"><a href="#将本地project-push到自己的github-码云仓库中" class="headerlink" title="将本地project push到自己的github/码云仓库中"></a>将本地project push到自己的github/码云仓库中</h2><p>无论如何，得在相应平台上事先创建一个项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://github.com/androidjp/&lt;你的远程项目名&gt;.git</span><br><span class="line">git remote add origin https://gitee.com/androidJP/&lt;你的远程项目名&gt;.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h1 id="看Log"><a href="#看Log" class="headerlink" title="看Log"></a>看Log</h1><ul>
<li><code>git log --pretty=oneline</code>: 查看当前分支的所有的提交记录</li>
<li><code>git log --oneline -3</code>: 查看最近三次提交</li>
<li><code>git log --graph --decorate --oneline --all</code>: 查看所有分支的所有提交记录树状图</li>
<li><code>git log --graph --decorate --oneline --simplify-by-decoration A B C</code>: 查看A,B,C三个分支的树状图</li>
</ul>
<blockquote>
<p>说明：</p>
<ul>
<li><code>--decorate</code> 标记会让git log显示每个commit的引用(如:分支、tag等) </li>
<li><code>--oneline</code> 一行显示</li>
<li><code>--simplify-by-decoration</code> 只显示被branch或tag引用的commit</li>
<li><code>--all</code> 表示显示所有的branch</li>
</ul>
</blockquote>
<h1 id="回滚的艺术"><a href="#回滚的艺术" class="headerlink" title="回滚的艺术"></a>回滚的艺术</h1><h2 id="版本回滚和还原"><a href="#版本回滚和还原" class="headerlink" title="版本回滚和还原"></a>版本回滚和还原</h2><ol>
<li>回滚<ul>
<li>法一：通过<code>git log</code>查看版本号，然后通过版本号来定位<code>HEAD</code>应该指向哪里。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">$ git reset --hard 12345</span><br></pre></td></tr></table></figure></li>
<li>法二：通过<code>HEAD^</code> 等，回滚到上一个/上N个版本<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 上个版本</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">//上上个版本</span><br><span class="line">$ git reset --hard HEAD^^</span><br><span class="line">// 前100个版本</span><br><span class="line">$ git reset --hard HEAD~100</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>还原 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog  // 可查看历史操作记录，最新的记录在第一条</span><br><span class="line">$ git reset --hard &lt;版本号&gt;</span><br></pre></td></tr></table></figure>
原理：还是使用<code>reset --hard &lt;版本号&gt;</code>的方式实现，并通过<code>git reflog</code>来获取以前的git操作记录，从而得到对应的版本号。</li>
</ol>
<h2 id="不小心写了句“老板真欠扁”，怎么办？"><a href="#不小心写了句“老板真欠扁”，怎么办？" class="headerlink" title="不小心写了句“老板真欠扁”，怎么办？"></a>不小心写了句“老板真欠扁”，怎么办？</h2><ul>
<li>【修改处于工作区】幸好，我的文件还在工作区，没有被add。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///将我这个文件myFile.txt的所有修改都清空</span><br><span class="line">$ git checkout -- myFile.txt</span><br></pre></td></tr></table></figure></li>
<li>【修改处理暂存区】哦哦，我的文件add进了暂存区。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 第一步，还原 add 这个操作（暂存区 --&gt; 工作区）</span><br><span class="line">$ git reset HEAD myFile.txt</span><br><span class="line">// 第二步，清空工作区（工作区 --&gt; 未修改）</span><br><span class="line">$ git checkout -- myFile.txt</span><br></pre></td></tr></table></figure></li>
<li>【修改已提交】如果你已经commit了<br>恭喜你，只能用版本回滚了。（如果老板没有你最新提交版本的版本号的话）<ul>
<li>法一：<code>git rebase -i head~&lt;N&gt;</code> 把包含你的错误提交在内的前N的提交，重新选择，其中，选择<code>drop</code>给你的错误提交，这样，就删除了你的错误提交了。</li>
<li>法二：<code>git reset --hard HEAD~1</code> 把你骂老板的本地提交强行回滚到之前的一个提交，虽然这样本地依然存在这样的一个记录，但是当你push时，这个记录是不会推送到远程仓库里面的。</li>
</ul>
</li>
<li>【修改已push】如果已经push code了，那怎么办呢？****理论上，是无论如何，骂老板的记录都会在的。<ul>
<li>法一：<code>git revert &lt;错误提交id&gt;</code> 把错误纠正，然后提交，这么做，这棵commit树上的记录中，你的错误提交记录依然存在，能被人看到。（所以，在这种case下，不推荐）</li>
<li>法二：<code>git rebase -i head~&lt;N&gt;</code>，这种方式，在这种情况下，类似revert，对远程分支<code>origin/master</code>是不会达到删除提交记录的效果的，类似于和本地<code>master</code>分支做merge/rebase，最终和revert的效果一致  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i head~&lt;N&gt; // 只选择正确的commit</span><br><span class="line">....</span><br><span class="line">git merge / git rebase</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h2 id="git-reset-详解"><a href="#git-reset-详解" class="headerlink" title="git reset 详解"></a>git reset 详解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>--mixed</code>：【默认】回退版本库，暂存区。</li>
<li><code>--hard</code>：回退版本库，暂存区，工作区</li>
<li><code>--soft</code>：回退版本库</li>
</ul>
<h3 id="–keep例子"><a href="#–keep例子" class="headerlink" title="–keep例子"></a>–keep例子</h3><p>假设你正在编辑一些文件，并且已经提交，接着继续工作，但是现在你发现当前在working tree中的内容应该属于另一个branch，与这之前的commit没有什么关系。此时，你可以开启一个新的branch，并且保留着working tree中的内容。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag start </span><br><span class="line">$ git checkout -b branch1 </span><br><span class="line">$ edit </span><br><span class="line">$ git commit ...                            (1) </span><br><span class="line">$ edit </span><br><span class="line">$ git checkout -b branch2                   (2) </span><br><span class="line">$ git reset --keep start                    (3)</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) 这次是把在branch1中的改变提交了。 </li>
<li>(2) 此时发现，之前的提交不属于这个branch，此时你新建了branch2，并切换到了branch2上。 </li>
<li>(3) 此时你可以用reset –keep把在start之后的commit清除掉，但是保持working tree不变。 </li>
</ul>
<h3 id="–merge例子"><a href="#–merge例子" class="headerlink" title="–merge例子"></a>–merge例子</h3><p>在被污染的working tree中回滚merge或者pull </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull                         (1) </span><br><span class="line">Auto-merging nitfol </span><br><span class="line">Merge made by recursive. </span><br><span class="line">nitfol                |   20 +++++---- </span><br><span class="line">... </span><br><span class="line">$ git reset --merge ORIG_HEAD      (2)</span><br></pre></td></tr></table></figure>
<ul>
<li>(1) 即便你已经在本地更改了一些你的working tree，你也可安全的git pull，前提是你知道将要pull的内容不会覆盖你的working tree中的内容。 </li>
<li>(2) git pull完后，你发现这次pull下来的修改不满意，想要回滚到pull之前的状态，从前面的介绍知道，我们可以执行<code>git reset --hard ORIG_HEAD</code>，但是这个命令有个副作用就是清空你的working tree，即丢弃你的本地未add的那些改变。为了避免丢弃working tree中的内容，可以使用<code>git reset --merge ORIG_HEAD</code>，注意其中的<code>--hard</code>换成了<code>--merge</code>，这样就可以避免在回滚时清除working tree。 </li>
</ul>
<h1 id="关于HEAD"><a href="#关于HEAD" class="headerlink" title="关于HEAD"></a>关于HEAD</h1><p>一整个分支树上，同时只有一个HEAD指针。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="1-看-HEAD-指向"><a href="#1-看-HEAD-指向" class="headerlink" title="1. 看 HEAD 指向"></a>1. 看 HEAD 指向</h3><p>看 HEAD 指向，可以通过 <code>cat .git/HEAD</code> 查看， 如果 HEAD 指向的是一个引用，还可以用 <code>git symbolic-ref HEAD</code> 查看它的指向</p>
<h3 id="2-让-HEAD-指向某个指定的commit，而不是某个分支"><a href="#2-让-HEAD-指向某个指定的commit，而不是某个分支" class="headerlink" title="2. 让 HEAD 指向某个指定的commit，而不是某个分支"></a>2. 让 HEAD 指向某个指定的commit，而不是某个分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git chekout &lt;commit id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="让master分支强行指向dev分支的第3个的commit"><a href="#让master分支强行指向dev分支的第3个的commit" class="headerlink" title="让master分支强行指向dev分支的第3个的commit"></a>让master分支强行指向dev分支的第3个的commit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout dev // 首先让master分支的HEAD指向对应的分支dev</span><br><span class="line">git branch -f master HEAD~3</span><br></pre></td></tr></table></figure>
<h2 id="如何在几个提交记录间随意穿梭"><a href="#如何在几个提交记录间随意穿梭" class="headerlink" title="如何在几个提交记录间随意穿梭"></a>如何在几个提交记录间随意穿梭</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 查看logId</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">// 选择logID来跳转</span><br><span class="line">git reset --hard &lt;logId&gt;</span><br></pre></td></tr></table></figure>

<h1 id="用git快速debug"><a href="#用git快速debug" class="headerlink" title="用git快速debug"></a>用git快速debug</h1><ul>
<li><code>git bisect start [终点] [起点]</code>: 开始检查某一段提交中的哪一次提交出了问题，每次都用二分法，看中间的这次提交有没有问题，一般：<code>git bisect start HEAD 4d83cf</code></li>
<li><code>git bisect good</code>: 如果当前的提交是没问题的，那么就标记为good</li>
<li><code>git bisect bad</code>: 如果当前的提交是有问题的，那么就标记为bad</li>
<li><code>git bisect reset</code>: 推出差错过程，指针回到HEAD</li>
</ul>
<h1 id="cherry-pick-和-rebase-i"><a href="#cherry-pick-和-rebase-i" class="headerlink" title="cherry-pick 和 rebase -i"></a>cherry-pick 和 rebase -i</h1><h2 id="抽取想要的几个commit"><a href="#抽取想要的几个commit" class="headerlink" title="抽取想要的几个commit"></a>抽取想要的几个commit</h2><p><code>git cherry-pick &lt;logId[空格..]&gt;</code>: 选择某个分支，merge到本分支。</p>
<h2 id="如何合并历史的几个commit到一个commit"><a href="#如何合并历史的几个commit到一个commit" class="headerlink" title="如何合并历史的几个commit到一个commit"></a>如何合并历史的几个commit到一个commit</h2><p>这里有个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192eb39de1fdbb56f1f2693c99611365855d58d0 (HEAD -&gt; master) xx</span><br><span class="line">f0819adfb5e1bed8bc2fa86d1ce3f6ee878c6f0c add `333`</span><br><span class="line">8f26c03c69a06928b6045087e0b01b6ac88a106a add `222`</span><br><span class="line">01579e444c53c20f1ef3bfa18a0832f1ae5b26cd add `111`</span><br><span class="line">436c7d3166d95bd1a0626ea660fec9c50714441d init abc.txt &amp; add `abc`</span><br></pre></td></tr></table></figure>
<p>现在我想变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">352f0d9fe36c0e38938be8cb3a881f93f8158f18 (HEAD -&gt; master) add `111` -&gt; add `222` -&gt; add `333` -&gt; xx</span><br><span class="line">436c7d3166d95bd1a0626ea660fec9c50714441d init abc.txt &amp; add `abc`</span><br></pre></td></tr></table></figure>
<ol>
<li><code>git rebase -i HEAD~4</code>: 首先基于<code>HEAD~4</code>这个父commit，选择最顶端4个commit</li>
<li>会弹出一个交互框，内部可以看到<code>pick</code>, <code>squash</code>等字样，我们会这样写： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pick commit_1 111</span><br><span class="line">squash commit_2 222</span><br><span class="line">squash commit_3 333</span><br><span class="line">squash commit_4 xx</span><br></pre></td></tr></table></figure>
 这里是想把前3个子commit合并到前面的第一个父commit中。</li>
<li><code>git rebase --continue</code>: 填写一波description并生成一个新的commit，覆盖原来的4个子commit。</li>
</ol>
<h1 id="和远程仓库打交道"><a href="#和远程仓库打交道" class="headerlink" title="和远程仓库打交道"></a>和远程仓库打交道</h1><ol>
<li>创建<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure></li>
<li>推送<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 第一次推送，-u 作用是将本地仓库与远程仓库origin 绑定</span><br><span class="line">$ git push -u origin master </span><br><span class="line"></span><br><span class="line">/// 以后的推送，则不需要再次绑定了</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li>
<li>查看远程库信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote  /// 远程库名</span><br><span class="line">$ git remote -v ///详细信息</span><br></pre></td></tr></table></figure></li>
<li>查看远程分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -a  ///查看所有分支（包括本地和远程仓库）</span><br><span class="line">$ git branch</span><br></pre></td></tr></table></figure></li>
<li>删除远程分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -r -d origin/develop    /// 删除远程分支develop</span><br><span class="line">$ git push origin :develop   ///删除远程的develop分支</span><br></pre></td></tr></table></figure>
<h2 id="分支重命名"><a href="#分支重命名" class="headerlink" title="分支重命名"></a>分支重命名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch [&lt;options&gt;] (-m | -M) [&lt;old-branch&gt;] &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>
例子：将<code>feature/canvas</code>重命名为：<code>feature/canvas2</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -M feature/canvas feature/canvas2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="让本地分支追溯到远程某个分支"><a href="#让本地分支追溯到远程某个分支" class="headerlink" title="让本地分支追溯到远程某个分支"></a>让本地分支追溯到远程某个分支</h2><hr>
<p>如果发现，自己创建的本地分支pull不了，那么，可能是本地分支没有与远程分支建立关联，这时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/&lt;branch&gt; develop</span><br></pre></td></tr></table></figure>
<p>就可以建立连接，之后，就是各种push、pull和merge了！</p>
<h2 id="Pull-不下来怎么办？"><a href="#Pull-不下来怎么办？" class="headerlink" title="Pull 不下来怎么办？"></a>Pull 不下来怎么办？</h2><hr>
<ul>
<li>如果发现是这种报错：<code>fatal: refusing to merge unrelated histories</code>【在新建Ionic项目的时候经常这样】，那么，用这条语句来pull: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
<h2 id="git-clone-指定目录"><a href="#git-clone-指定目录" class="headerlink" title="git clone 指定目录"></a>git clone 指定目录</h2></li>
</ul>
<hr>
<p>如果我们不想每次先cd到那个目录在进行clone操作，那么，这句命令很有用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;git url&gt; &quot;C:\a\b&quot;</span><br></pre></td></tr></table></figure>
<p>其中：<code>a</code>表示指定目录，<code>b</code>表示你自定义的文件夹名，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;git clone https://github.com/androidjp/xxxxx.git &quot;D:\aaa\bbb&quot;</span><br></pre></td></tr></table></figure>
<p>最终，会创建<code>aaa\bbb</code>目录和文件夹，然后在内部拉取所有代码。</p>
<h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><h2 id="dev分支码到一半，发现master分支的版本有bug，要马上改"><a href="#dev分支码到一半，发现master分支的版本有bug，要马上改" class="headerlink" title="dev分支码到一半，发现master分支的版本有bug，要马上改"></a>dev分支码到一半，发现master分支的版本有bug，要马上改</h2><p><strong>思路：</strong>dev的修改先保存起来，然后切换到master分支，再打bug分支修复bug，修复成功并合并后，最终切回dev分支，并取回之前保存的dev分支的修改内容，继续码。<br><strong>步骤</strong>：</p>
<ol>
<li>暂存dev工作现场<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure></li>
<li>切回master, 打bug修复分支，修复并合并<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git checkout -b bug-solve-101</span><br><span class="line">////修复bug中。。。。</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff -m &quot;bug 101修复成功&quot; bug-solve-101</span><br></pre></td></tr></table></figure></li>
<li>最终，切回dev分支，并还原工作现场<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash pop   /// 还原现场，并清除存储栈中的内容</span><br><span class="line">/// $ git stash list /// 查看存储栈中的工作现场列表</span><br><span class="line">/// $ git stash apply  ///只恢复，不删除栈</span><br><span class="line">/// $ git stash drop /// 删除栈存储区</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Lag标签"><a href="#Lag标签" class="headerlink" title="Lag标签"></a>Lag标签</h1><ol>
<li><code>git tag &lt;name&gt;</code>：新建一个标签，默认为HEAD，也可以指定一个commit id；</li>
<li><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>：可以指定标签信息；</li>
<li><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>：可以用PGP签名标签；</li>
<li><code>git tag</code>：可以查看所有标签</li>
<li><code>git push origin &lt;tagname&gt;</code>：可以推送一个本地标签；</li>
<li><code>git push origin --tags</code>：可以推送全部未推送过的本地标签；</li>
<li><code>git tag -d &lt;tagname&gt;</code>：可以删除一个本地标签；</li>
<li><code>git push origin :refs/tags/&lt;tagname&gt;</code>：可以删除一个远程标签。</li>
</ol>
<h1 id="解决每次拉取、提交代码时都需要输入用户名和密码"><a href="#解决每次拉取、提交代码时都需要输入用户名和密码" class="headerlink" title="解决每次拉取、提交代码时都需要输入用户名和密码"></a>解决每次拉取、提交代码时都需要输入用户名和密码</h1><p>1.在~/.gitconfig目录下多出一个文件，用来记录你的密码和帐号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>再最后输入一次正确的用户名和密码，就可以成功的记录下来</li>
</ol>
<h1 id="git-使用-push-提交到远程仓库出现-The-requested-URL-returned-error-403-错误"><a href="#git-使用-push-提交到远程仓库出现-The-requested-URL-returned-error-403-错误" class="headerlink" title="git 使用 push 提交到远程仓库出现 The requested URL returned error: 403 错误"></a>git 使用 push 提交到远程仓库出现 The requested URL returned error: 403 错误</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>电脑已经注册过一个 github 帐号，一直在本机使用，配置过 SSH。</p>
<p>新建另一个 github 帐号，本地建立好项目之后，使用命令：$ git push -u origin master 时出现以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: Permission to userName/repositorieName.git denied to clxering.</span><br><span class="line">fatal: unable to access &apos;https://github.com/userName/repositorieName.git/&apos;: The requested URL returned error: 403</span><br></pre></td></tr></table></figure>

<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>问题主要出在原注册账号上，系统保存了账号的信息。在使用新帐号时，信息不一致，所以报错。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>打开cmd，输入命令：<code>rundll32.exe keymgr.dll,KRShowKeyMgr</code>，出现系统存储的用户名和密码窗口；</li>
<li>将 github 相关的条目删除；</li>
<li>重新执行命令：<code>$ git push -u origin master</code>，提示输入账户名及密码即可。</li>
</ol>
<h1 id="查看git信息存储位置"><a href="#查看git信息存储位置" class="headerlink" title="查看git信息存储位置"></a>查看git信息存储位置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git help -a | grep credential</span><br></pre></td></tr></table></figure>
<p>查看自己系统支持的crendential, cache 代表内存中的缓存，store 代表磁盘。</p>
<h1 id="查看cache、store等git配置信息"><a href="#查看cache、store等git配置信息" class="headerlink" title="查看cache、store等git配置信息"></a>查看cache、store等git配置信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config credential.helper</span><br></pre></td></tr></table></figure>
<p>命令可以看到 cache、store、osxkeychain(钥匙串)中是否还有git的配置信息</p>
<h1 id="配置全局用户名和邮箱"><a href="#配置全局用户名和邮箱" class="headerlink" title="配置全局用户名和邮箱"></a>配置全局用户名和邮箱</h1><p>一般配置方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global (--replace-all) user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global (--replace-all) user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>如果上述步骤没有效果，我们就需要清除缓存(<code>.gitconfig</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --local --unset credential.helper</span><br><span class="line">git config --global --unset credential.helper</span><br><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure>

<h1 id="git-revert-一次-revert-多个-commit"><a href="#git-revert-一次-revert-多个-commit" class="headerlink" title="git revert 一次 revert 多个 commit"></a>git revert 一次 revert 多个 commit</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假如git commit 链是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D</span><br></pre></td></tr></table></figure>
<p>如果想把B，C，D都给revert，除了一个一个revert之外，还可以使用range revert</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert B^..D</span><br></pre></td></tr></table></figure>
<p>这样就把B,C,D都给revert了，变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A-&gt; B -&gt;C -&gt; D -&gt; D&apos;-&gt; C&apos; -&gt; B&apos;</span><br></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><code>git revert OLDER_COMMIT^..NEWER_COMMIT</code></p>
<p>如果我们想把这三个revert不自动生成三个新的commit，而是用一个commit完成，可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git revert -n OLDER_COMMIT^..NEWER_COMMIT</span><br><span class="line">git commit -m &quot;revert OLDER_COMMIT to NEWER_COMMIT&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MVP架构的理解</title>
    <url>/MVP%E6%9E%B6%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>下面是本人对 MVP 架构 的一些理解。 </p>
</blockquote>
<a id="more"></a>

<p>首先，放两个网上关于MVP架构的图解，对比一下：</p>
<blockquote>
<p>图解一：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-b24fbbb7c5735801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>图解二：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-7919a1f8e616a804.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</blockquote>
<p>这里，本人会更加倾向与图解一。</p>
<h2 id="一、M、V、P的分析"><a href="#一、M、V、P的分析" class="headerlink" title="一、M、V、P的分析"></a>一、M、V、P的分析</h2><p>&emsp;M层，也就是Model层（也可以理解成：数据源层、持久层、Data层），是专门给外界提供数据的一层，这里<br>的‘外界’一般是指本应用的其他层（逻辑处理层和展示层）。<br>&emsp;V层，指的是View层（界面展示层、与用户交互的界面），是专门用于展示数据、与用户交互的层。<br>&emsp;P层，指的是Presenter层（逻辑处理层、主持层），是不同与MVC模式的一层，因为它分出来是为了将界面中所有较为复杂的逻辑操作工程分出来，减轻V层的负担，同时，让原本V层与M层的直接关系断开，达到解耦的效果。<br>&emsp;从M、V、P三者的分析，结合上面的图解可以看到，其实图解一比图解二更好的地方在于：Presenter与Model之间的交互，是可以双向的。而这一点，由于很多开源库或者框架已经实现了关于数据的一个异步获取或处理的过程，所以，在设计MVP架构的时候，很多MVP架构辅助库，并没有着重P和M之间通信的问题，而着重与P和V之间的通信问题，这本来没有错，因为MVP架构出来的初衷本来就是为了减轻View层的逻辑负担。然而这里，我们在遇到一些网络操作、异步处理过程时，可能需要对Presenter和Model间的监听和交互想一想怎么设计了。</p>
<h2 id="二、MVP架构优劣分析"><a href="#二、MVP架构优劣分析" class="headerlink" title="二、MVP架构优劣分析"></a>二、MVP架构优劣分析</h2><ul>
<li>优点：很容易看出来，就是：<ul>
<li>逻辑和展示的分离，Presenter减轻View的负担。【相当于：主持人负责主持好每一个表演的出场和开场白，表演者听命令直接做动作就好】</li>
<li>View层与Model层解耦，模块化，易于后期维护。</li>
</ul>
</li>
<li>缺点<ul>
<li>View负担小了，Presenter负担就大的。目前的MVP架构辅助库，大多考虑的是一个Activity/Fragment配一个Presenter，那么，意味着，一个界面，需要做的逻辑操作，全部交给一个Presenter去做，这样一来，Presenter的代码量就很大了。【这里，只能尽量保证每一个界面的功能相对单一，以减少Presenter代码量，但是功能一旦减少，代码本来就少了，还需要Presenter吗？这就存在一个矛盾了】</li>
<li>Presenter 与 Model层的交互，需要同样的一个异步处理过程，而这个过程，如果不借助第三方库，自己动手，则同样需要一个回调接口的设计。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MVP架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发细节--查漏补缺（二）：易忘难懂</title>
    <url>/Android%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82--%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%98%93%E5%BF%98%E9%9A%BE%E6%87%82/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章先汇总一下部分在平常容易遇到或可能遇到的一些难以理解或者容易忘记是什么的问题。</p>
</blockquote>
<a id="more"></a>

<hr>
<ol>
<li><p>android:supportsRtl=”true”是什么？<br><code>android:supportsRtl=&quot;true&quot;</code> 故名思义，“Rtl”就是“right to left” ，一般用于适配language文本方向，如切换系统语言为阿拉伯文时，actionbar布局要变为从右向左排列，就需要这个属性。</p>
<blockquote>
<p>注意：<br>此属性最低SDK版本为17（Android 4.2.x）<br>在使用这个属性时，尽量不适用<code>layout_marginRight</code>这类，而是使用<code>layout_marginEnd</code>这种。</p>
</blockquote>
<hr>
</li>
<li><p>Android res/menu/my_nemu.xml中不易记的属性：</p>
<ul>
<li>android:<strong>alphabeticShortcut</strong>=”n” ：表示快捷键为：Ctrl+n 、Alt+n</li>
<li>android:<strong>orderInCategory</strong> = “3”：表示在菜单列表中的排序，值可以为大于等于0的任何整数，数值越小，排序越前。</li>
<li>android:<strong>checkableBehavior</strong> = “single|all|none”：分别表示radio button、checkbox、checkable=false</li>
<li>&lt;group android:id=”xx”……&gt; <item android:id="yy"/>……</group>： 用一个组，包含几个menu_item，这样，组内部的item的顺序就可以重新定义。</li>
</ul>
<hr>
</li>
<li><p>Android中用Java代码设置菜单项快捷键的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu.setQwertyMode(true);</span><br><span class="line">menu.findItem(TWO_ID).setNumericShortcut(&apos;2&apos;);</span><br></pre></td></tr></table></figure>
<hr>
</li>
<li><p><RelativeLayout>中子view的属性：</p>
<ul>
<li><strong>android:below=”@+id/xx”</strong> ：表示本view在xx的下面</li>
<li><strong>android:above=”@+id/xx”</strong>：表示本view在xx的上面</li>
</ul>
<hr>
</li>
<li><p>implements Parcelable的对象的一般写法：（详见我的另一篇博文：<a href="http://www.jianshu.com/p/b1fcff2728bd" target="_blank" rel="noopener">Android AIDL基础 – Parcelable接口</a>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student implements Parcelable&#123;</span><br><span class="line">    ///-------------------------------</span><br><span class="line">    /// （1）：基本类型、String/CharSequence、Bundle、IBinder、Serializable、Parcelable 的成员</span><br><span class="line">    private T t;</span><br><span class="line">    ……</span><br><span class="line">    ///---------------------------------</span><br><span class="line">    ///（2）：构造方法（可选，怎么方便赋值成员变量值并构建实例，就怎么写）</span><br><span class="line">    public Student() &#123;</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">   //=========================================================</span><br><span class="line">   //  下面是Parcelable需要实现的方法</span><br><span class="line">   //=========================================================</span><br><span class="line">    protected Student(Parcel in) &#123;</span><br><span class="line">        ///建议：按成员变量顺序写【因为：需要与writeToParcel()方法中的写入顺序一致】</span><br><span class="line">        id = in.readInt();//如：基本数据类型成员</span><br><span class="line">        name = in.readString();//如：String类型成员</span><br><span class="line">        home = in.readParcelable(Address.class.getClassLoader());//如：Parcelable类型成员</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">    public static final Creator&lt;Student&gt; CREATOR = new Creator&lt;Student&gt;() &#123;</span><br><span class="line">        ///CREATOR成员，格式必须如下，‘CREATOR’变量名也固定。</span><br><span class="line">        @Override</span><br><span class="line">        public Student createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new Student(in);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Student[] newArray(int size) &#123;</span><br><span class="line">            return new Student[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        /// 描述标志，默认为0即可</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        ////写入Parcel的方法【需要与writeToParcel()方法中的写入顺序一致】</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeParcelable(home, flags);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Android Studio获取Android签名证书SHA1的简易步骤：</p>
<ul>
<li>Android Studio中打开terminal或者配置了全局变量之后直接打开终端输入：<br><strong><code>keytool -list -v -keystore 你的签名文件所在的路径</code></strong></li>
<li>输入密钥库密码</li>
<li>成功显示：MD5、SHA1、SHA256等信息<blockquote>
<p>想知道Eclipse的获取方式，更详细的地址可以看：<a href="http://lbs.amap.com/dev/ticket#/faq/86" target="_blank" rel="noopener">SHA1查看</a></p>
</blockquote>
</li>
</ul>
<hr>
</li>
<li><p>JSON封装库的效率对比：<br>如果对JSON的解析速度敏感：大文件用：<strong>Jackson</strong>，小文件用：<strong>Gson</strong>，两种文件都有用：<strong>JSON.simple</strong></p>
<hr>
</li>
<li><p>Java代码执行new一个类实例对象的过程中，static块、static方法、main方法的执行顺序：</p>
<ul>
<li>static块【最先执行，因为静态代码块属于类层次，在类编译时就执行】</li>
<li>-&gt; main方法</li>
<li>-&gt; 成员块</li>
<li>-&gt; 构造方法</li>
<li>-&gt; static方法【在被调用时才执行】<blockquote>
<p>详细可以看看本人的相关文章：<a href="http://www.jianshu.com/p/ace2aa692f96" target="_blank" rel="noopener">Java面试相关（一）– Java类加载全过程</a></p>
</blockquote>
</li>
</ul>
<hr>
</li>
<li><p>在写Fragment的时候，Fragment.onCreateView()方法中，一般是这样的一个结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">@Override</span><br><span class="line">public View onCreateView(LayoutInflater inflater,  ViewGroup container,  Bundle savedInstanceState) &#123;</span><br><span class="line">  if (rootLayout == null) &#123;</span><br><span class="line">    rootLayout = inflater.inflate(R.layout.fragment_reclist, null);///①</span><br><span class="line">    rootLayout = inflater.inflate(R.layout.fragment_reclist, container, false);///②</span><br><span class="line">    ///rootLayout = inflater.inflate(R.layout.fragment_reclist, container);///③这样不行！！</span><br><span class="line">    ……  </span><br><span class="line">  &#125;</span><br><span class="line">……</span><br><span class="line">return rootLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，要注意代码中注释掉的地方，这里有一个对于Fragment的知识点：<br><code>inflater.inflate(id, ViewGroup);</code><br>说明：<br> 这个方法传入：【目的布局的R.layout 的id】 + 【目的布局的父容器】。那么，对于Fragment的来说，Fragment的onCreateView()方式最终返回的View会自动判断本Fragment所在的父容器位置。<br> <strong>为什么上面代码③不行呢?</strong> 答：因为<code>inflater.inflate(id, ViewGroup);</code>最终会调用<code>inflater.inflate(id, ViewGroup,boolean);</code> 方法，当ViewGroup不为null时，这方法的第三个参数值会为true，表示的是‘inflate出来的布局自动加到它的父viewgroup中’，那么问题就来了，如果这个父布局是一个ViewPager或者其他不易确定子View放置位置的容器，那么，方法就会<strong>报错</strong>，因为找不到插入点！所以，对于Fragment的布局，一般情况不需要设置自动添加到父布局，所以，上述代码①和②二选一都可以。</p>
<hr>
</li>
<li><p>Fragment 与 它所在的Activity的生命周期方法执行次序：<br>下面用一个常用布局作为示例【FragmentActivity中用ViewPager装载两个Fragment 部分代码示例】来演示 ，看运行的Log就可以说明整个执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CommonTabActivity extends FragmentActivity &#123;</span><br><span class="line">……</span><br><span class="line">/// TabLayout + ViewPager的主界面容器</span><br><span class="line">PagerAdapter mPagerAdapter;</span><br><span class="line">ViewPager mViewPager;</span><br><span class="line">TabLayout mTabLayout;</span><br><span class="line">////两个 Fragment</span><br><span class="line">RecListFragment homeFragment;</span><br><span class="line">RecListFragment collectionFragment;</span><br><span class="line">……</span><br><span class="line"> @Override</span><br><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     super.onCreate(savedInstanceState);</span><br><span class="line">     setContentView(R.layout.activity_commontab);</span><br><span class="line">     initView();</span><br><span class="line"> &#125;</span><br><span class="line">  private void initView() &#123;</span><br><span class="line">    ///初始化ViewPager等控件</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">        mPagerAdapter = new FragmentPagerAdapter(getSupportFragmentManager()) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Fragment getItem(int position) &#123;</span><br><span class="line">                switch (position) &#123;</span><br><span class="line">/////////////////////////使用第一个Fragment</span><br><span class="line">                    case 0:</span><br><span class="line">                    default:  </span><br><span class="line">                        if(homeFragment==null)&#123;</span><br><span class="line">                            homeFragment = new RecListFragment();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return homeFragment;</span><br><span class="line">///////////////////////////使用第二个Fragment</span><br><span class="line">                    case 1:</span><br><span class="line">                        if (collectionFragment==null)&#123;</span><br><span class="line">                            collectionFragment =  new RecListFragment();</span><br><span class="line">                        &#125;</span><br><span class="line">                        return collectionFragment;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            …………</span><br><span class="line">        &#125;;</span><br><span class="line">        mViewPager.setAdapter(mPagerAdapter);</span><br><span class="line">        mTabLayout.setupWithViewPager(mViewPager);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的结构大家应该都比较熟悉，那么，我测试后给大家列出几种情况下Activity和两个Fragment的生命周期方法执行情况：</p>
<ul>
<li><p>本Activity被startActivity()等方式启动：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-0f3595eb8249ed44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>本Activity由于点击HOME、MENU等弹回桌面时：<br> 下图是Android N版本下点击MENU按键时的操作截图（类似平常我们长按HOME键弹出运行中程序）：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-c108a164f086f0f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/2369895-71511813a835a544.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>本Activity启动其他Activity，并被完全遮掩覆盖时：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-cd5b8e9ce86970d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>Activity退出时：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-9a0e6a728886c2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>总结：</p>
<ul>
<li>启动Activity时，由于ViewPager默认采用预加载的方式，所以，虽然默认显示第一个Fragment，第二个Fragment依然会被加载和初始化。</li>
<li>启动Activity时，Activity先执行了它本身的onCreate()-&gt;onStart()-&gt;onResume()，之后，ViewPager才真的开始运行起来并加载指定给他的Fragment，Fragment才开始它的生命周期。</li>
<li>不论Activity是被另一个Activity覆盖、还是App被返回桌面、或者是弹出启动中应用的界面遮掩Activity，此时，Activity都是被完全遮掩（弹出Dialog等不全屏的窗体时，Activity属于部分被遮掩），此时，Activity都会调用到onStop()方法，并且这种方式中Fragment与Activity的生命周期方法执行顺序都一样(如上面截图)。</li>
<li>当Activity退出时，①Fragment执行onStop()后，Activity再执行onStop() ②Fragment执行onDestroyView()和onDestroy()后，Activity才执行onDestroy()</li>
</ul>
</li>
<li><p>另外，如果到这里，忘了Fragment整个生命周期是怎么样的，这里，本人附上<strong>*<u>Fragment的生命周期图解</u>*</strong>：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-3cf75cc2042a2e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fragment的生命周期"></p>
</li>
</ul>
<hr>
</li>
<li><p>关于v4、v7、v13兼容包：</p>
<ul>
<li><strong>Android Support v4：</strong>为了兼容Android1.6及更高版本而设计的。（eclipse新建工程时，都默认带有v4包）</li>
<li><strong>Android Support v7：</strong>为了兼容Android2.1及以上版本而设计的，但不包含更低，故如果不考虑1.6,我们可以采用再加上这个包，另外注意，v7是要依赖v4这个包的，即，两个得同时被包含。</li>
<li><strong>Android Support v13：</strong>为了Android 3.2及更高版本的，一般我们都不常用，平板开发中能用到。</li>
</ul>
</li>
</ol>
<h3 id="感谢阅读～"><a href="#感谢阅读～" class="headerlink" title="感谢阅读～"></a>感谢阅读～</h3><p>本篇文章将持续更新～<br>喜欢的读者可以点个关注，本人将持续发布Android相关文章～</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试相关（一）-- Java类加载全过程</title>
    <url>/Java%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89--%20Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h6 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h6><p>&emsp;&emsp;我们知道，Java中我们写类的代码，是存在于一个个.java文件中的，而这个后缀名也是让JVM识别编译的基础。可能有些Android开发者对几个ClassLoader（如：AppClassLoader等）比较熟悉，那么，整个类的加载过程：从未进行编译的.java文件，到类的初始化完毕并等待被实例化使用的过程，具体是怎么样的。<br>&emsp;&emsp;收集Java资料、看了几篇本人觉得较好的博文后，总结以下关于Java类的加载过程，掌握此过程，能够更加理解Java类的各个方法的执行顺序，以及JVM的工作和Java类生成的原理。读者笑纳～</p>
<a id="more"></a>

<h2 id="类的加载过程分析"><a href="#类的加载过程分析" class="headerlink" title="类的加载过程分析"></a>类的加载过程分析</h2><hr>
<p>&emsp;&emsp;类<strong>从.java文件到实际加载到内存中</strong>，实际上是这样的一个<strong>过程</strong>：<br>&emsp;&emsp;.java文件 -&gt; 通过你的JDK环境相关指令编译 -&gt; .class文件 -&gt; JVM初始化之后，如果有类的执行、调用等相关操作，JVM就会将.class文件加载到内存中，并开始下面的一系列处理：（链接-&gt;初始化）</p>
<p><img src="/images/class_load_process/1.png" alt=""></p>
<h3 id="一、关于ClassLoader"><a href="#一、关于ClassLoader" class="headerlink" title="一、关于ClassLoader"></a>一、关于ClassLoader</h3><hr>
<p>&emsp;&emsp;首先我们要搞清楚一点，ClassLoader是Java用于加载类的一个机制。等到程序运行时，JVM先初始化，在JVM初始化的过程中，JVM生成几个ClassLoader，JVM调用指定的ClassLoader去加载.class文件等各类路径、文件的类。</p>
<ol>
<li><p>程序运行时类的加载实际过程</p>
<ul>
<li>JDK执行指令去寻找jre目录，寻找jvm.dll，并初始化JVM；</li>
<li>产生一个Bootstrap Loader（启动类加载器）；</li>
<li>Bootstrap Loader自动加载Extended Loader（标准扩展类加载器），并将其父Loader设为Bootstrap Loader。</li>
<li>Bootstrap Loader自动加载AppClass Loader（系统类加载器），并将其父Loader设为Extended Loader。</li>
<li>最后由AppClass Loader加载HelloWorld类。</li>
</ul>
</li>
<li><p>各种ClassLoader及其特点</p>
<ul>
<li><strong>Bootstrap Loader（启动类加载器）</strong>：加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar</li>
<li><strong>Extended Loader（标准扩展类加载器ExtClassLoader）</strong>：加载System.getProperty(“java.ext.dirs”)所指定的路径或jar。在使用Java运行程序时，也可以指定其搜索路径，例如：java -Djava.ext.dirs=d:\projects\testproj\classes HelloWorld</li>
<li><strong>AppClass Loader（系统类加载器AppClassLoader）</strong>：加载System.getProperty(“java.class.path”)所指定的路径或jar。在使用Java运行程序时，也可以加上-cp来覆盖原有的Classpath设置，例如： java -cp ./lavasoft/classes HelloWorld</li>
<li><strong>特点</strong><ul>
<li>ExtClassLoader和AppClassLoader在JVM启动后，会在JVM中保存一份，并且在程序运行中无法改变其搜索路径。如果想在运行时从其他搜索路径加载类，就要产生新的类加载器。</li>
<li>运行一个程序时，总是由AppClassLoader（系统类加载器）开始加载指定的类</li>
<li>在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载</li>
<li>BootstrapLoader（启动类加载器）是最顶级的类加载器了，其父加载器为null</li>
</ul>
</li>
</ul>
</li>
<li><p>各类ClassLoader的关系图解（帮助理解）<br><img src="/images/class_load_process/2.png" alt="各个ClassLoader的作用以及他们之间的关系.png"></p>
<blockquote>
<p>注意：图解中可得，执行代码<code>c.getClassLoader().getParent().getParent()</code>为<code>null</code>，由于get不到BootstrapLoader，因为BootstrapLoader是C层次实现的。</p>
</blockquote>
</li>
</ol>
<h3 id="二、类的加载方式"><a href="#二、类的加载方式" class="headerlink" title="二、类的加载方式"></a>二、类的加载方式</h3><hr>
<ol>
<li>方式一：命令行启动应用时候由JVM初始化加载</li>
<li>方式二：通过Class.forName()方法动态加载（默认会执行初始化块，但如果指定ClassLoader，初始化时不执行静态块  ）</li>
<li>方式三：通过ClassLoader.loadClass()方法动态加载（不会执行初始化块 ）</li>
</ol>
<p>解析：<br>  方式一其实就是通过以下几种主动引用类的方式所触发的JVM的类加载和初始化过程。然后，其实这三种类加载方式，在java 层面上都是JVM调用了ClassLoader去加载类的过程，只是：方式一相对与方式二和方式三而言，属于静态方式的加载；而方式二和方式三的区别，在于<code>Class.ForName</code>源码中：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///Class.forname(String name)</span><br><span class="line">public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123;</span><br><span class="line">    return forName(className, true, VMStack.getCallingClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">………………</span><br><span class="line">///实际调用：</span><br><span class="line">public static Class&lt;?&gt; forName(String className, boolean shouldInitialize,</span><br><span class="line">        ClassLoader classLoader) throws ClassNotFoundException &#123;</span><br><span class="line">    if (classLoader == null) &#123;</span><br><span class="line">        classLoader = BootClassLoader.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">      Class&lt;?&gt; result;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = classForName(className, shouldInitialize, classLoader);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        if (cause instanceof LinkageError) &#123;</span><br><span class="line">            throw (LinkageError) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  &emsp;在源码当中可以看到，参数<code>boolean shouldInitialize</code>，在默认情况下的Class.forName(String)此参数默认为<code>true</code>，则默认情况下会进行初始化，</p>
<p>那么，初始化到时是怎么个操作过程，此过程又是怎么样去触发的呢？下面我们通过分析类的加载流程以及整体图解，来帮助说明。</p>
<h3 id="三、详细分析整个类的加载流程"><a href="#三、详细分析整个类的加载流程" class="headerlink" title="三、详细分析整个类的加载流程"></a>三、详细分析整个类的加载流程</h3><hr>
<p>&emsp;下面分析一下类的几种加载方式、ClassLoader对类加载的背后，是怎么个原理：</p>
<h4 id="1-类从编译、被使用，到卸载的全过程："><a href="#1-类从编译、被使用，到卸载的全过程：" class="headerlink" title="1. 类从编译、被使用，到卸载的全过程："></a>1. 类从编译、被使用，到卸载的全过程：</h4><p><u>编译 -&gt; 加载 -&gt; 链接（验证+准备+解析）-&gt;初始化（使用前的准备）-&gt;使用-&gt; 卸载</u></p>
<h4 id="2-类的初始化之前"><a href="#2-类的初始化之前" class="headerlink" title="2. 类的初始化之前"></a>2. 类的初始化之前</h4><p>加载（除了自定义加载）和链接的过程是完全由jvm负责的，包括：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析</p>
<blockquote>
<p>这里的“自定义加载”可以理解为：自定义类加载器去实现自定义路径中类的加载，可以<a href="http://blog.csdn.net/huangbiao86/article/details/6910152" target="_blank" rel="noopener">参考这篇文章</a>。由于默认各个路径的类文件加载过程在JVM初始化的过程中就默认设定好了，也就是一般步骤下的加载过程，已经在JVM初始化过程中规定的AppClassLoader等加载器中规定了步骤，所以，按一般的加载步骤，就是按JVM规定的顺序，JVM肯定先负责了类的加载和链接处理，然后再进行类初始化。</p>
</blockquote>
<ol>
<li><p>首先是<strong>加载</strong>：</p>
<ul>
<li>这一块JVM要完成3件事：<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</li>
</ol>
</li>
<li>这一步很灵活,很多技术都是在这里切入，因为它并没有限定二进制流从哪里来，那么我们可以<u>用系统的类加载器，也可以用自己的方式写加载器来控制字节流的获取</u>：<ol>
<li>从class文件来-&gt;一般的文件加载</li>
<li>从zip包中来-&gt;加载jar中的类</li>
<li>从网络中来-&gt;Applet</li>
</ol>
</li>
<li>获取二进制流获取完成后会按照jvm所需的方式保存在方法区中，同时会在java堆中实例化一个java.lang.Class对象与堆中的数据关联起来。</li>
</ul>
</li>
<li><p>然后是<strong>验证</strong>（也称为<strong>检验</strong>）：</p>
<ul>
<li><em>主要经历几个步骤：文件格式验证-&gt;元数据验证-&gt;字节码验证-&gt;符号引用验证</em><ul>
<li><em>文件格式验证</em>：验证字节流是否符合Class文件格式的规范并 验证其版本是否能被当前的jvm版本所处理。ok没问题后，字节流就可以进入内存的方法区进行保存了。后面的3个校验都是在方法区进行的。</li>
<li><em>元数据验证</em>：对字节码描述的信息进行语义化分析，保证其描述的内容符合java语言的语法规范。</li>
<li><em>字节码检验</em>：最复杂，对方法体的内容进行检验，保证其在运行时不会作出什么出格的事来。</li>
<li><em>符号引用验证</em>：来验证一些引用的真实性与可行性，比如代码里面引了其他类，这里就要去检测一下那些来究竟是否存在；或者说代码中访问了其他类的一些属性，这里就对那些属性的可以访问行进行了检验。（这一步将为后面的解析工作打下基础）</li>
</ul>
</li>
<li>目的：确保class文件的字节流信息符合jvm的口味，不会让jvm感到不舒服。假如class文件是由纯粹的java代码编译过来的，自然不会出现类似于数组越界、跳转到不存在的代码块等不健康的问题，因为一旦出现这种现象，编译器就会拒绝编译了。但是，跟之前说的一样，Class文件流不一定是从java源码编译过来的，也可能是从网络或者其他地方过来的，甚至你可以自己用16进制写，假如jvm不对这些数据进行校验的话，可能一些有害的字节流会让jvm完全崩溃。<blockquote>
<p>验证阶段很重要，但也不是必要的，假如说一些代码被反复使用并验证过可靠性了，实施阶段就可以尝试用-Xverify:none参数来关闭大部分的类验证措施，以简短类加载时间。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>随后是<strong>准备</strong>：</p>
<ul>
<li>这阶段会为类变量（指那些静态变量）分配内存并设置类比那辆初始值的阶段，这些内存在方法区中进行分配。这里要说明一下，这一步只会给那些静态变量设置一个初始的值，而那些实例变量是在实例化对象时进行分配的。<br>例如：<ul>
<li><code>public static int value=123;</code>此时value的值为0，不是123。</li>
<li><code>private int i = 123;</code> 此时，i 还未进行初始化，因为这句代码还不能执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>最后是<strong>解析</strong>：</p>
<ul>
<li>是对类的字段，方法等东西进行转换，具体涉及到Class文件的格式内容。</li>
</ul>
</li>
</ol>
<h4 id="3-类的初始化条件-主动对类进行引用"><a href="#3-类的初始化条件-主动对类进行引用" class="headerlink" title="3. 类的初始化条件(主动对类进行引用)"></a>3. 类的初始化条件(主动对类进行引用)</h4><blockquote>
<p>说明：要对类进行<strong>初始化</strong>，代码上可以理解为<u><strong>‘为要初始化的类中的所有静态成员都赋予初始值、对类中所有静态块都执行一次，并且是按代码编写顺序执行’</strong></u>。<br>如下代码：输出的是‘1’。如果①和②顺序调换，则输出的是‘123’。<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(Super.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Super&#123;</span><br><span class="line">    //①</span><br><span class="line">    static&#123;</span><br><span class="line">        i = 123;</span><br><span class="line">    &#125;</span><br><span class="line">    //②</span><br><span class="line">    protected static int i = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>遇到new，getstatic，putstatic，invokestatic这4条字节码指令时，假如类还没进行初始化，则马上对其进行初始化工作。<br>其实就是3种情况：<ul>
<li>用new实例化一个类时</li>
<li>读取或者设置类的静态字段时（不包括被final修饰的静态字段，因为他们已经被塞进常量池了）</li>
<li>执行静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect.*的方法对类进行反射调用的时候，如果类还没有进行过初始化，马上对其进行。</li>
<li>初始化一个类的时候，如果他的父亲还没有被初始化，则先去初始化其父亲。</li>
<li>当jvm启动时，用户需要指定一个要执行的主类（包含static void main(String[] args)的那个类），则jvm会先去初始化这个类。</li>
<li>用Class.forName(String className);来加载类的时候，也会执行初始化动作。<br>【注意:ClassLoader的loadClass(String className);方法只会加载并编译某类，并不会对其执行初始化】</li>
</ol>
<blockquote>
<p>说明：“主动对类进行引用”指的就是以上五种JVM规定的判定初始化与否的预处理条件。<br>那么，其他的方式，都可归为‘类被动引用’的方式，这些方式是不会引起JVM去初始化相关类的：</p>
</blockquote>
<ol>
<li><u>子类调用父类</u>的静态变量（子类不会进行初始化，父类会初始化）</li>
<li>通过<u>数组</u>引用类的情况（类Main不会被初始化）<br>如：list = Main[10];</li>
<li>调用类中的<u>final静态常量</u>（类不会被初始化）</li>
</ol>
<h3 id="四、原理分析图解"><a href="#四、原理分析图解" class="headerlink" title="四、原理分析图解"></a>四、原理分析图解</h3><hr>
<p>&emsp;类加载中每个部分详细的原理说明，可以查看<a href="http://my.oschina.net/volador/blog/87194" target="_blank" rel="noopener">这篇文章</a>。以下的图解为本人总结，算比较全地对每个步骤的原理过程一目了然：</p>
<p><img src="/images/class_load_process/3.png" alt="Java类加载过程.png"></p>
<blockquote>
<p>说明： 图解左下角说的<code>&lt;clinit&gt;()</code>方法，概念上是一个方法块，这个<clinit>(){……}方法块在初始化过程中执行，可以用下面代码理解：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line"> public static int A=1;</span><br><span class="line"> static&#123;                            </span><br><span class="line"> A=2;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> ---相当于----&gt;</span><br><span class="line">class Parent&#123;</span><br><span class="line"> &lt;clinit&gt;()&#123;</span><br><span class="line">   public static int A=1;</span><br><span class="line">   static&#123;</span><br><span class="line">     A=2;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于把静态变量的赋值和静态代码块等操作顺序串连成一个方法。<br>注意：</p>
<ul>
<li>对于类，会生成<clinit>(){……}方法体：去包含静态变量的赋值和静态块代码</li>
<li>而对于接口，也会生成<clinit>(){……}方法体：去初始化接口中的成员变量</li>
<li>接口和类初始化过程的区别：类的初始化执行之前要求父类全部都初始化完成了，但接口的初始化貌似对父接口的初始化不怎么感冒，也就是说，子接口初始化的时候并不要求其父接口也完成初始化，只有在真正使用到父接口的时候它才会被初始化（比如引用接口上的常量的时候啦）</li>
</ul>
<h3 id="五、简单代码示例说明"><a href="#五、简单代码示例说明" class="headerlink" title="五、简单代码示例说明"></a>五、简单代码示例说明</h3><hr>
<p>这里，用一个java代码示例，来根据输出得到的各个方法和块的执行顺序，去更加形象地理解整个类的加载和运行过程：<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;我是main方法，我输出Super的类变量i：&quot;+Sub.i);</span><br><span class="line">        Sub sub  = new Sub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Super&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是Super成员块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Super()&#123;</span><br><span class="line">        System.out.println(&quot;我是Super构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        int j = 123;</span><br><span class="line">        System.out.println(&quot;我是Super成员块中的变量j：&quot;+j);</span><br><span class="line">    &#125;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;我是Super静态块&quot;);</span><br><span class="line">        i = 123;</span><br><span class="line">    &#125;</span><br><span class="line">    protected static int i = 1;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;我是Sub静态块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Sub()&#123;</span><br><span class="line">        System.out.println(&quot;我是Sub构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是Sub成员块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到结果为：<br><img src="/images/class_load_process/4.png" alt=""><br>说明：</p>
<ol>
<li>静态代码块和静态变量的赋值 是** 先于 **main方法的调用执行的。</li>
<li>静态代码块和静态变量的赋值是按顺序执行的。</li>
<li>子类调用父类的类变量成员，是不会触发子类本身的初始化操作的。</li>
<li>使用new方式创建子类，对于类加载而言，是先加载父类、再加载子类（注意：此时由于父类已经在前面初始化了一次，所以，这一步，就只有子类初始化，父类不会再进行初始化）</li>
<li>不论成员块放在哪个位置，它都 <strong>先于</strong> 类构造方法执行。</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><hr>
<p><a href="http://my.oschina.net/volador/blog/87194" target="_blank" rel="noopener">http://my.oschina.net/volador/blog/87194</a><br><a href="http://lavasoft.blog.51cto.com/62575/184547/" target="_blank" rel="noopener">http://lavasoft.blog.51cto.com/62575/184547/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android字典（二）-- 获取系统各个目录</title>
    <url>/Android%E5%AD%97%E5%85%B8%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>引言： 下面列出Android系统在编译打包后由镜像文件生成的Android系统各级主要目录，以及在App中获取各个目录的说明示例。</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Android系统目录结构"><a href="#一、Android系统目录结构" class="headerlink" title="一、Android系统目录结构"></a>一、Android系统目录结构</h2><hr>
<ul>
<li><strong>/init  【系统启动文件】</strong></li>
<li><strong>/system</strong><ul>
<li>app【系统应用安装目录】</li>
<li>bin【常用的系统本地命令（二进制），大部分是toolbar的链接（类似于嵌入式Linux中的busybox）】</li>
<li>etc【系统配置文件，如hosts】</li>
<li>font【字体目录】</li>
<li>framework【Java平台架构核心库，jar包和odex优化的文件】</li>
<li>lib【系统底层共享库，.so库文件】</li>
<li>xbin【不常用的系统管理工具，相当于linux 的/sbin】</li>
<li>media<ul>
<li>audio【铃声，提示音 等音频文件， .ogg】<ul>
<li>notifications【通知】</li>
<li>ui【界面】</li>
<li>alarms【警告】</li>
<li>ringtones【铃声】</li>
</ul>
</li>
</ul>
</li>
<li>usr【用户文件夹】<ul>
<li>keychars</li>
<li>keylayout</li>
<li>share</li>
<li>srec【配置】</li>
<li>等等</li>
</ul>
</li>
<li>vendor</li>
<li>build.prop【系统设置和变更属性】</li>
</ul>
</li>
<li>/etc –&gt; /system/etc</li>
<li>/vendor –&gt; /system/vendor</li>
<li>/dev【存放设备节点文件】</li>
<li>/proc【全局系统信息】</li>
<li><strong>/data</strong>【用户软件和各种数据】<ul>
<li>local/tmp【临时目录，无权限要求】</li>
<li>app【普遍程序安装目录】</li>
<li>system<ul>
<li>location【其中的location.gps记录最后的坐标，LocationManager.getLastKnownLocation()数据来自此处】</li>
</ul>
</li>
<li>data<ul>
<li><package_name>
* files【Context.getFilesDir()， Context.getFileOutput()】
* cache【Context.getCacheDir() , **系统会在内存不足或者目录大小达到特定数值时自动清理。**】
* shared_pref【Context.getSharedPreferences()建立的 SharedPreferences文件存放目录】</li>
</ul>
</li>
<li>anr【应用在发生ANR 时，Android将问题点的堆栈写入traces.txt文件中】</li>
<li>location<ul>
<li>gps【GPS location provider配置】</li>
</ul>
</li>
<li>property【其中persist.sys.timezone记录系统临时区】</li>
</ul>
</li>
<li><strong>/sdcard</strong> –&gt; /storage/emulated/legacy   【SD卡的FAT32文件系统挂载到这个目录】</li>
<li><strong>Android</strong><ul>
<li><strong>data</strong><ul>
<li><package_name>  【应用的额外数据，应用卸载时自动删除】<ul>
<li>files【Context.getExternalFilesDir()获取 。 设置 → 应用 → 具体应用详情→ <strong>清除数据</strong> 的操作对象】</li>
<li>cache【Context.getExternalCacheDir()获取 。 设置 → 应用 → 具体应用详情→ <strong>清除缓存</strong> 的操作对象】</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>lost+found<ul>
<li>yaffs文件系统固有的，类似于回收站的文件夹。</li>
</ul>
</li>
<li>ODEX<ul>
<li>从apk中提取出来的可运行文件，即原apk中classes.dex通过dex优化生成的一个单独存放的dex文件。启动应用时不需要再从apk包中提取dex，速度更快。还可以删除apk包中的dex减少体积。缺点是体积变大，而且升级某个给Odex的应用可能会出现问题。</li>
</ul>
</li>
</ul>
<h2 id="二、获取系统各个目录"><a href="#二、获取系统各个目录" class="headerlink" title="二、获取系统各个目录"></a>二、获取系统各个目录</h2><hr>
<blockquote>
<p>以包名为“com.androidjp.app”的应用示例实测得到以下结果，模拟器和真机结果一致。</p>
</blockquote>
<p><strong><em>Environment.getExternalStorageDirectory().getAbsolutePath():</em></strong><br>结果：/storage/emulated/0<br><strong>*Environment.getExternalStoragePublicDirectory(“”).getAbsolutePath(): *</strong><br>结果：/storage/emulated/0<br><strong>*MyAppl.getContext().getPackageName(): *</strong><br>结果：com.androidjp.app【你的app的包目录】<br><strong>*Environment.getDownloadCacheDirectory().getAbsolutePath(): *</strong><br>结果：/cache<br><strong>*Environment.getRootDirectory().getAbsolutePath(): *</strong><br>结果：/system<br><strong>*Environment.getDataDirectory().getAbsolutePath(): *</strong><br>结果：/data<br><strong>*MyAppl.getContext().getFilesDir().getAbsolutePath(): *</strong><br>结果：/data/user/0/com.androidjp.app/files<br><strong>*Environment.getExternalStoragePublicDirectory(“files”).getAbsolutePath(): *</strong><br>结果：/storage/emulated/0/files<br><strong>*MyAppl.getContext().getExternalFilesDir(“”).getAbsolutePath(): *</strong><br>结果：/storage/emulated/0/Android/data/com.androidjp.app/files<br><strong>*MyAppl.getContext().getCacheDir().getAbsolutePath(): *</strong><br>结果：/data/user/0/com.androidjp.app/cache<br><strong>*Environment.getExternalStoragePublicDirectory(“cache”).getAbsolutePath(): *</strong><br>结果：/storage/emulated/0/cache<br><strong>*MyAppl.getContext().getExternalCacheDir().getAbsolutePath(): *</strong><br>结果：/storage/emulated/0/Android/data/com.androidjp.app/cache</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>系统目录</category>
      </categories>
      <tags>
        <tag>Android系统目录</tag>
      </tags>
  </entry>
  <entry>
    <title>Android AIDL基础 -- Parcelable接口</title>
    <url>/Android%20AIDL%E5%9F%BA%E7%A1%80%20--%20Parcelable%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="什么是Parcelable接口"><a href="#什么是Parcelable接口" class="headerlink" title="什么是Parcelable接口"></a>什么是Parcelable接口</h2><hr>
<ul>
<li><p><strong>作用：</strong>给类设计的接口，类一旦实现这个接口，该类的对象即可进行一个“从对象存储为Parcel ， 从Parcel读取为对象”的一个读写过程。</p>
</li>
<li><p><strong>目的：</strong>实现序列化</p>
</li>
<li><p><strong>原因：</strong><br>  序列化，为了：<br>  1） 永久保存对象，保存对象的字节到本地文件中<br>  2） 通过序列化对象在网络中传递对象<br>  3） 通过序列化在进程间传递对象</p>
<a id="more"></a></li>
<li><p><strong>与Serializable对比：</strong><br>1）在使用Intent传递数据时：</p>
<ul>
<li>Serializable: Bundle.putSerializable(Key, <em>实现了Serializable的对象</em>);</li>
<li>Parcelable: Bundle.putParcelable(Key, <em>实现了Parcelable的对象</em>);</li>
</ul>
<p>2）内存使用性能上：</p>
<ul>
<li>Parcelable &gt; Serializable<blockquote>
<p>由于Serializable在序列化时会产生大量的临时变量，从而引起频繁的GC。   </p>
</blockquote>
</li>
</ul>
<p>3）数据存储在磁盘上的情况：</p>
<ul>
<li>Serialzable &gt; Parcelable<blockquote>
<p>Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable</p>
</blockquote>
</li>
</ul>
</li>
<li><p>支持的成员数据类型：<br>1） 普通数据类型【如：int、double等以及他们的封装类如Integer、Float等】以及他们的数组类型【如：int[]、double[]等】<strong><em>注意：不支持：List[Integer]类型等List类型</em></strong><br>2） String/CharSequence及其数组String[]、ArrayList[String]<br>3） Bundle 和 List<Bundle><br>4） Serializable <strong><em>注意：不支持List<Serializable></em></strong><br>5） Binder 和 List<Binder> ，IBinder 和 List<IBinder><br>6） Parcelable实现类</p>
<blockquote>
<p>重温：Intent/Bundle传递支持的数据类型有：</p>
</blockquote>
<ul>
<li>基本数据类型和它的数组类型</li>
<li>String/CharSequence和它的数组类型</li>
<li>Serializable</li>
<li>Parcelable</li>
</ul>
</li>
</ul>
<h2 id="实现Parcelable接口"><a href="#实现Parcelable接口" class="headerlink" title="实现Parcelable接口"></a>实现Parcelable接口</h2><hr>
<ul>
<li><p><strong>实现步骤</strong></p>
<ol>
<li><code>implements Parcelable</code></li>
<li>重写<code>writeToParcel</code>方法，将你的对象序列化为一个Parcel对象，即：将类的数据写入外部提供的Parcel中，打包需要传递的数据到Parcel容器保存，以便从 Parcel容器获取数据。</li>
<li>重写<code>describeContents</code>方法，内容接口描述，默认返回0就可以。</li>
<li>实例化静态内部对象<code>CREATOR</code>实现接口<code>Parcelable.Creator</code></li>
</ol>
</li>
<li><p><strong>没有Parcelable成员的Parcelable接口实现示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** * 测试：地址</span><br><span class="line"> * Created by androidjp on 16-7-22.</span><br><span class="line"> */</span><br><span class="line">public class Address implements Parcelable&#123;</span><br><span class="line">    ///（可以）一般数据类型和String，如：String、int、Integer、double、Float等</span><br><span class="line">    public String country;</span><br><span class="line">    public String city;</span><br><span class="line">    public String street;</span><br><span class="line">    ///（可以）Bindle类型【由于Bindle本身实现了Parcelable】</span><br><span class="line">    public Bundle bundle;</span><br><span class="line">    ///（可以）Serializable类型</span><br><span class="line">    public Serializable serializable;</span><br><span class="line">    ///（可以）Binder类型</span><br><span class="line">    public Binder binder;</span><br><span class="line">    public Integer i;</span><br><span class="line">    public int j;</span><br><span class="line">    public List&lt;String&gt; stringList;</span><br><span class="line">    public List&lt;Bundle&gt; bundleList;</span><br><span class="line">//    public List&lt;Serializable&gt; serializableList;</span><br><span class="line">    public ArrayList&lt;IBinder&gt; binderList;</span><br><span class="line">//    public List&lt;Integer&gt; integerList;</span><br><span class="line">    public int[] ints;</span><br><span class="line"></span><br><span class="line">    public Address(String country, String city, String street) &#123;</span><br><span class="line">        this.country = country;</span><br><span class="line">        this.city = city;</span><br><span class="line">        this.street = street;</span><br><span class="line">    &#125;</span><br><span class="line">   //=========================================================</span><br><span class="line">   //  下面是Parcelable需要实现的方法</span><br><span class="line">   //=========================================================</span><br><span class="line">    protected Address(Parcel in) &#123;</span><br><span class="line">        country = in.readString();</span><br><span class="line">        city = in.readString();</span><br><span class="line">        street = in.readString();</span><br><span class="line">        bundle = in.readBundle();</span><br><span class="line">        serializable = in.readSerializable();</span><br><span class="line">        binder = (Binder) in.readStrongBinder();</span><br><span class="line">        i = in.readInt();</span><br><span class="line">        j = in.readInt();</span><br><span class="line">        stringList = in.createStringArrayList();</span><br><span class="line">        bundleList = in.createTypedArrayList(Bundle.CREATOR);</span><br><span class="line">        binderList = in.createBinderArrayList();</span><br><span class="line">        ints = in.createIntArray();</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    * 读取接口，目的是要从Parcel中构造一个实现了Parcelable的类的实例处理。</span><br><span class="line">    * 因为实现类在这里还是不可知的，所以需要用到模板的方式，继承类名通过模板参数传入。</span><br><span class="line">    * 为了能够实现模板参数的传入，这里定义Creator嵌入接口,内含两个接口函数分别返回单个和多个继承类实例。</span><br><span class="line">    */</span><br><span class="line">    public static final Creator&lt;Address&gt; CREATOR = new Creator&lt;Address&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Address createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new Address(in);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Address[] newArray(int size) &#123;</span><br><span class="line">            return new Address[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   /////内容描述接口，基本不用管</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">   //写入接口函数，打包</span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeString(country);</span><br><span class="line">        dest.writeString(city);</span><br><span class="line">        dest.writeString(street);</span><br><span class="line">        dest.writeBundle(bundle);</span><br><span class="line">        dest.writeSerializable(serializable);</span><br><span class="line">        dest.writeStrongBinder(binder);</span><br><span class="line">        dest.writeInt(i);dest.writeInt(j);</span><br><span class="line">        dest.writeStringList(stringList);</span><br><span class="line">        dest.writeTypedList(bundleList);</span><br><span class="line">        dest.writeBinderList(binderList);</span><br><span class="line">        dest.writeIntArray(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>加上Parcelable成员的Parcelable接口实现示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试：学生</span><br><span class="line"> */</span><br><span class="line">public class Student implements Parcelable&#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Address home;////地址成员变量（已经实现了Parcelable接口）</span><br><span class="line">    public Student(int id, String name, Address home) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.home = home;</span><br><span class="line">    &#125;</span><br><span class="line">   //=========================================================</span><br><span class="line">   //  下面是Parcelable需要实现的方法</span><br><span class="line">   //=========================================================</span><br><span class="line">    protected Student(Parcel in) &#123;</span><br><span class="line">        id = in.readInt();</span><br><span class="line">        name = in.readString();</span><br><span class="line">        home = in.readParcelable(Address.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    public static final Creator&lt;Student&gt; CREATOR = new Creator&lt;Student&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Student createFromParcel(Parcel in) &#123;</span><br><span class="line">            return new Student(in);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public Student[] newArray(int size) &#123;</span><br><span class="line">            return new Student[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeParcelable(home, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><hr>
<ol>
<li><p>由于Parcelable对象不能向Serializable那样将对象保存到文件中等持久化操作，那么，我的对象要怎么做？<br> 答： <code>public class Student implements Parcelable,Serializable{……</code>，让类同时实现两个接口，即可使他能够序列化并存储到文件中。</p>
</li>
<li><p>什么是Parcel？<br> 答：简单来说，Parcel就是一个存放数据的容器。Android中以Binder机制方式实现来IPC，就是使用了Parcel来进行Client和Server间的数据交互，而且AIDL的数据也是通过Parcel来交互的。同样的，在Java中和C/C++中，都有Parcel的实现【Parcel在C/C++中，直接使用内存来读取数据，所以此时Parcel它更加快速】<br> 换句话理解Parcel：我们知道，类A和类B可能想要通信，那么，要进行交流，A肯定不想把自己的实例（包括成员变量、方法等）整个复制到B那边，并且，A和B在同一个线程、甚至同个进程的不同线程都好说，如果是不同进程呢？那得怎么传，通过网络之类的咯？所以，就有了Parcel这个“打包”一说，A把A的一些信息进行说明，将这些说明打包（而不同打包自己的具体东西），然后把信息传给B，B读了之后，根据A给的提示选择，将选择同样用Parcel打包传回给A，A收到就跑，跑完数据后，返回结果又同样Parcel装着给到B，整个通信过程类似这样。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>AIDL</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AIDL</tag>
        <tag>Parcelable</tag>
      </tags>
  </entry>
  <entry>
    <title>Android字典（一） -- permission权限说明</title>
    <url>/Android%E5%AD%97%E5%85%B8%EF%BC%88%E4%B8%80%EF%BC%89%20--%20permission%E6%9D%83%E9%99%90%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>引言：整理的权限列表以及动态获取权限、权限申请结果监听。</p>
</blockquote>
<a id="more"></a>

<h2 id="一、权限列表"><a href="#一、权限列表" class="headerlink" title="一、权限列表"></a>一、权限列表</h2><hr>
<ul>
<li>android.permission.<strong>ACCESS_CHECKIN_PROPERTIES</strong><br>允许读写访问”properties”表在checkin数据库中，改值可以修改上传</li>
<li>android.permission.<strong>ACCESS_COARSE_LOCATION</strong><br>允许一个程序访问CellID或WiFi热点来获取粗略的位置</li>
<li>android.permission.<strong>ACCESS_FINE_LOCATION</strong><br>允许一个程序访问精良位置(如GPS)</li>
<li>android.permission.<strong>ACCESS_LOCATION_EXTRA_COMMANDS</strong><br>允许应用程序访问额外的位置提供命令</li>
<li>android.permission.<strong>ACCESS_MOCK_LOCATION</strong><br>允许程序创建模拟位置提供用于测试</li>
<li>android.permission.<strong>ACCESS_NETWORK_STATE</strong><br>允许程序访问有关GSM网络信息</li>
<li>android.permission.<strong>ACCESS_SURFACE_FLINGER</strong><br>允许程序使用SurfaceFlinger底层特性</li>
<li>android.permission.<strong>ACCESS_WIFI_STATE</strong><br>允许程序访问Wi-Fi网络状态信息</li>
<li>android.permission.<strong>ADD_SYSTEM_SERVICE</strong><br>允许程序发布系统级服务</li>
<li>android.permission.<strong>BATTERY_STATS</strong><br>允许程序更新手机电池统计信息</li>
<li>android.permission.<strong>BLUETOOTH</strong><br>允许程序连接到已配对的蓝牙设备</li>
<li>android.permission.<strong>BLUETOOTH_ADMIN</strong><br>允许程序发现和配对蓝牙设备</li>
<li>android.permission.<strong>BRICK</strong><br>请求能够禁用设备(非常危险)</li>
<li>android.permission.<strong>BROADCAST_PACKAGE_REMOVED</strong><br>允许程序广播一个提示消息在一个应用程序包已经移除后</li>
<li>android.permission.<strong>BROADCAST_STICKY</strong><br>允许一个程序广播常用intents</li>
<li>android.permission.<strong>CALL_PHONE</strong><br>允许一个程序初始化一个电话拨号不需通过拨号用户界面需要用户确认</li>
<li>android.permission.<strong>CALL_PRIVILEGED</strong><br>允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认</li>
<li>android.permission.<strong>CAMERA</strong><br>请求访问使用照相设备</li>
<li>android.permission.<strong>CHANGE_COMPONENT_ENABLED_STATE</strong><br>允许一个程序是否改变一个组件或其他的启用或禁用</li>
<li>android.permission.<strong>CHANGE_CONFIGURATION</strong><br>允许一个程序修改当前设置，如本地化</li>
<li>android.permission.<strong>CHANGE_NETWORK_STATE</strong><br>允许程序改变网络连接状态</li>
<li>android.permission.<strong>CHANGE_WIFI_STATE</strong><br>允许程序改变Wi-Fi连接状态</li>
<li>android.permission.<strong>CLEAR_APP_USER_DATA</strong><br>允许一个程序清除用户设置</li>
<li>android.permission.<strong>CONTROL_LOCATION_UPDATES</strong><br>允许启用禁止位置更新提示从无线模块</li>
<li>android.permission.<strong>DELETE_CACHE_FILES</strong><br>允许程序删除缓存文件</li>
<li>android.permission.<strong>DELETE_PACKAGES</strong><br>允许一个程序删除包</li>
<li>android.permission.<strong>DEVICE_POWER</strong><br>允许访问底层电源管理</li>
<li>android.permission.<strong>DIAGNOSTIC</strong><br>允许程序RW诊断资源</li>
<li>android.permission.<strong>DISABLE_KEYGUARD</strong><br>允许程序禁用键盘锁</li>
<li>android.permission.<strong>DUMP</strong><br>允许程序返回状态抓取信息从系统服务</li>
<li>android.permission.<strong>EXPAND_STATUS_BAR</strong><br>允许一个程序扩展收缩在状态栏,Android开发网提示应该是一个类似Windows Mobile中的托盘程序</li>
<li>android.permission.<strong>FACTORY_TEST</strong><br>作为一个工厂测试程序，运行在root用户</li>
<li>android.permission.<strong>FLASHLIGHT</strong><br>访问闪光灯,Android开发网提示HTC Dream不包含闪光灯</li>
<li>android.permission.<strong>FORCE_BACK</strong><br>允许程序强行一个后退操作是否在顶层activities</li>
<li>android.permission.<strong>FOTA_UPDATE</strong><br>暂时不了解这是做什么使用的，Android开发网分析可能是一个预留权限</li>
<li>android.permission.<strong>GET_ACCOUNTS</strong><br>访问一个帐户列表在Accounts Service中</li>
<li>android.permission.<strong>GET_PACKAGE_SIZE</strong><br>允许一个程序获取任何package占用空间容量</li>
<li>android.permission.<strong>GET_TASKS</strong><br>允许一个程序获取信息有关当前或最近运行的任务，一个缩略的任务状态，是否活动等等</li>
<li>android.permission.<strong>HARDWARE_TEST</strong><br>允许访问硬件</li>
<li>android.permission.<strong>INJECT_EVENTS</strong><br>允许一个程序截获用户事件如按键、触摸、轨迹球等等到一个时间流，Android开发网提醒算是hook技术吧</li>
<li>android.permission.<strong>INSTALL_PACKAGES</strong><br>允许一个程序安装packages</li>
<li>android.permission.<strong>INTERNAL_SYSTEM_WINDOW</strong><br>允许打开窗口使用系统用户界面</li>
<li>android.permission.<strong>INTERNET</strong><br>允许程序打开网络套接字</li>
<li>android.permission.<strong>MANAGE_APP_TOKENS</strong><br>允许程序管理(创建、催后、z-order默认向z轴推移)程序引用在窗口管理器中</li>
<li>android.permission.<strong>MASTER_CLEAR</strong><br>目前还没有明确的解释，Android开发网分析可能是清除一切数据，类似硬格机</li>
<li>android.permission.<strong>MODIFY_AUDIO_SETTINGS</strong><br>允许程序修改全局音频设置</li>
<li>android.permission.<strong>MODIFY_PHONE_STATE</strong><br>允许修改话机状态，如电源，人机接口等</li>
<li>android.permission.<strong>MOUNT_UNMOUNT_FILESYSTEMS</strong><br>允许挂载和反挂载文件系统可移动存储</li>
<li>android.permission.<strong>PERSISTENT_ACTIVITY</strong><br>允许一个程序设置他的activities显示</li>
<li>android.permission.<strong>PROCESS_OUTGOING_CALLS</strong><br>允许程序监视、修改有关播出电话</li>
<li>android.permission.<strong>READ_CALENDAR</strong><br>允许程序读取用户日历数据</li>
<li>android.permission.<strong>READ_CONTACTS</strong><br>允许程序读取用户联系人数据</li>
<li>android.permission.<strong>READ_FRAME_BUFFER</strong><br>允许程序屏幕波或和更多常规的访问帧缓冲数据</li>
<li>android.permission.<strong>READ_INPUT_STATE</strong><br>允许程序返回当前按键状态</li>
<li>android.permission.<strong>READ_LOGS</strong><br>允许程序读取底层系统日志文件</li>
<li>android.permission.<strong>READ_OWNER_DATA</strong><br>允许程序读取所有者数据</li>
<li>android.permission.<strong>READ_SMS</strong><br>允许程序读取短信息</li>
<li>android.permission.<strong>READ_SYNC_SETTINGS</strong><br>允许程序读取同步设置</li>
<li>android.permission.<strong>READ_SYNC_STATS</strong><br>允许程序读取同步状态</li>
<li>android.permission.<strong>REBOOT</strong><br>请求能够重新启动设备</li>
<li>android.permission.<strong>RECEIVE_BOOT_COMPLETED</strong><br>允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动</li>
<li>android.permission.<strong>RECEIVE_MMS</strong><br>允许一个程序监控将收到MMS彩信,记录或处理</li>
<li>android.permission.<strong>RECEIVE_SMS</strong><br>允许程序监控一个将收到短信息，记录或处理</li>
<li>android.permission.<strong>RECEIVE_WAP_PUSH</strong><br>允许程序监控将收到WAP PUSH信息</li>
<li>android.permission.<strong>RECORD_AUDIO</strong><br>允许程序录制音频</li>
<li>android.permission.<strong>REORDER_TASKS</strong><br>允许程序改变Z轴排列任务</li>
<li>android.permission.<strong>RESTART_PACKAGES</strong><br>允许程序重新启动其他程序</li>
<li>android.permission.<strong>SEND_SMS</strong><br>允许程序发送SMS短信</li>
<li>android.permission.<strong>SET_ACTIVITY_WATCHER</strong><br>允许程序监控或控制activities已经启动全局系统中</li>
<li>android.permission.<strong>SET_ALWAYS_FINISH</strong><br>允许程序控制是否活动间接完成在处于后台时</li>
<li>android.permission.<strong>SET_ANIMATION_SCALE</strong><br>修改全局信息比例</li>
<li>android.permission.<strong>SET_DEBUG_APP</strong><br>配置一个程序用于调试</li>
<li>android.permission.<strong>SET_ORIENTATION</strong><br>允许底层访问设置屏幕方向和实际旋转</li>
<li>android.permission.<strong>SET_PREFERRED_APPLICATIONS</strong><br>允许一个程序修改列表参数PackageManager.addPackageToPreferred() 和PackageManager.removePackageFromPreferred()方法</li>
<li>android.permission.<strong>SET_PROCESS_FOREGROUND</strong><br>允许程序当前运行程序强行到前台</li>
<li>android.permission.<strong>SET_PROCESS_LIMIT</strong><br>允许设置最大的运行进程数量</li>
<li>android.permission.<strong>SET_TIME_ZONE</strong><br>允许程序设置时间区域</li>
<li>android.permission.<strong>SET_WALLPAPER</strong><br>允许程序设置壁纸</li>
<li>android.permission.<strong>SET_WALLPAPER_HINTS</strong><br>允许程序设置壁纸hits</li>
<li>android.permission.<strong>SIGNAL_PERSISTENT_PROCESSES</strong><br>允许程序请求发送信号到所有显示的进程中</li>
<li>android.permission.<strong>STATUS_BAR</strong><br>允许程序打开、关闭或禁用状态栏及图标</li>
<li>android.permission.<strong>SUBSCRIBED_FEEDS_READ</strong><br>允许一个程序访问订阅RSS Feed内容提供</li>
<li>android.permission.<strong>SUBSCRIBED_FEEDS_WRITE</strong><br>系统暂时保留改设置,Android开发网认为未来版本会加入该功能</li>
<li>android.permission.<strong>SYSTEM_ALERT_WINDOW</strong><br>允许一个程序打开窗口使用TYPE_SYSTEM_ALERT，显示在其他所有程序的顶层</li>
<li>android.permission.<strong>VIBRATE</strong><br>允许访问振动设备</li>
<li>android.permission.<strong>WAKE_LOCK</strong><br>允许使用PowerManager的WakeLocks保持进程在休眠时从屏幕消失</li>
<li>android.permission.<strong>WRITE_APN_SETTINGS</strong><br>允许程序写入APN设置</li>
<li>android.permission.<strong>WRITE_CALENDAR</strong><br>允许一个程序写入但不读取用户日历数据</li>
<li>android.permission.<strong>WRITE_CONTACTS</strong><br>允许程序写入但不读取用户联系人数据</li>
<li>android.permission.<strong>WRITE_GSERVICES</strong><br>允许程序修改Google服务地图</li>
<li>android.permission.<strong>WRITE_OWNER_DATA</strong><br>允许一个程序写入但不读取所有者数据</li>
<li>android.permission.<strong>WRITE_SETTINGS</strong><br>允许程序读取或写入系统设置</li>
<li>android.permission.<strong>WRITE_SMS</strong><br>允许程序写短信</li>
<li>android.permission.<strong>WRITE_SYNC_SETTINGS</strong><br>允许程序写入同步设置</li>
</ul>
<h2 id="二、实用技巧"><a href="#二、实用技巧" class="headerlink" title="二、实用技巧"></a>二、实用技巧</h2><hr>
<ol>
<li>动态获取某个权限（下面例子：动态获取<em>ACCESS_COARSE_LOCATION</em>权限）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//判断是否有权限</span><br><span class="line">if (ContextCompat.checkSelfPermission(this,</span><br><span class="line">        Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">//请求权限</span><br><span class="line">      ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.ACCESS_COARSE_LOCATION&#125;,</span><br><span class="line">            MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION);</span><br><span class="line">//判断是否需要 向用户解释，为什么要申请该权限</span><br><span class="line">    if(ActivityCompat.shouldShowRequestPermissionRationale(this,</span><br><span class="line">            Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class="line">        Toast.makeText(this, &quot;shouldShowRequestPermissionRationale&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>申请权限结果监听方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[]</span><br><span class="line">      grantResults) &#123;</span><br><span class="line">  super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>permission权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Android环境变量作用--命令行操作（ADB、AVD等）</title>
    <url>/Android%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8--%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%88ADB%E3%80%81AVD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>我们配置Android环境变量时，像SDK中的tools目录和platform-tools目录可以一同配置，这样就可以在终端使用命令行来使用这些Android SDK拥有的工具了。</p>
</blockquote>
<a id="more"></a>

<h2 id="Android环境变量配置"><a href="#Android环境变量配置" class="headerlink" title="Android环境变量配置"></a>Android环境变量配置</h2><hr>
<blockquote>
<p>这些我们应该自己配置过。</p>
</blockquote>
<ul>
<li><strong>Linux</strong>：<br>执行：<code>sudo gedit /etc/profile</code><br>然后：在/etc/profile 文件中添加如下配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#set java environment-------------------------------------------------</span><br><span class="line">JAVA_HOME=/home/androidjp/Android/jdk/jdk1.8.0_25</span><br><span class="line">export JRE_HOME=/home/androidjp/Android/jdk/jdk1.8.0_25/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br><span class="line">#set android environment--------------------------------------------</span><br><span class="line">#set &apos;tools&apos; and &apos;platform-tools&apos; are for android avd and adb logcat</span><br><span class="line">export ANDROID_HOME=/home/androidjp/Android/sdk/android_sdk</span><br><span class="line">export PATH=/home/androidjp/Android/sdk/android_sdk/tools:/home/androidjp/Android/sdk/android_sdk/platform-tools:$PATH</span><br><span class="line">#set android aapt enviorment-----------------------------------------</span><br><span class="line">export AAPT_HOME=$ANDROID_HOME/build-tools/21.1.0/aapt</span><br></pre></td></tr></table></figure></li>
<li><strong>Windows</strong>：<br>在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量” 中可以配置系统变量<em>Path</em>，加上几句，最终得到：<br>Path：<code>……; D:\Android\sdk;D:\Android\sdk\tools;D:\Android\sdk\platform-tools;</code></li>
</ul>
<h2 id="命令行管理模拟器设备（AVD）"><a href="#命令行管理模拟器设备（AVD）" class="headerlink" title="命令行管理模拟器设备（AVD）"></a>命令行管理模拟器设备（AVD）</h2><hr>
<ul>
<li>android list：列出机器上所有已经安装的Android版本和AVD设备</li>
<li><strong>android list avd</strong>：列出机器上所有已经安装的AVD设备；</li>
<li>android list target：列出机器上所有已经安装的Android版本</li>
<li>android create avd:创建一个AVD设备<br>格式：android create avd -n <code>&lt;</code>AVD名称<code>&gt;</code> -t <code>&lt;</code>SDK版本号<code>&gt;</code> -s <code>&lt;</code>AVD皮肤<code>&gt;</code> -p <code>&lt;</code>AVD保存路径<code>&gt;</code><br>如：android create avd -n 1.5 -t 3 -s HVGA</li>
<li>android delete avd:删除一个AVD设备</li>
<li>android update avd:升级一个AVD设备使其符合新的SDK环境</li>
<li>android create project：创建一个新的Android项目</li>
<li>android update project：更新一个已有的Android项目</li>
<li>android create test-project：创建一个新的Android测试项目</li>
<li>android update test-project：更新一个已有的Android测试项目</li>
</ul>
<h2 id="命令行启动模拟器"><a href="#命令行启动模拟器" class="headerlink" title="命令行启动模拟器"></a>命令行启动模拟器</h2><hr>
<p>  使用emulator.exe启动模拟器的两种方法：</p>
<ul>
<li>emulator -avd <code>&lt;</code>AVD名称<code>&gt;</code></li>
<li>emulator -data <code>&lt;</code>镜像文件名称<code>&gt;</code> 【镜像文件一般位于AVD设备保存位置的avd文件夹目录下】<blockquote>
<p>avd的默认路径（win）：C:\用户\Admin.android\avd\avd名.avd</p>
</blockquote>
</li>
</ul>
<h2 id="常用的ADB命令"><a href="#常用的ADB命令" class="headerlink" title="常用的ADB命令"></a>常用的ADB命令</h2><hr>
<blockquote>
<p>ADB是一个非常强大的工具，位于SDK安装目录的platform-tools子目录下，它既可以完成模拟器文件与电脑文件的相互复制，也可以安装apk应用，甚至直接切换到Android系统中执行Linux命令。</p>
</blockquote>
<ul>
<li><strong>adb -devices</strong>：查看当前运行的模拟器</li>
<li>adb push c:/123.doc /sdcard/：将电脑文件复制到模拟器中</li>
<li>adb push /sdcard/abc.txt c:/：将模拟器文件复制到电脑</li>
<li>adb shell：启动模拟器的shell窗口，此时就可以在模拟器的shell窗口中直接执行Linux命令</li>
<li><strong>adb install [-r] [-s] &lt;文件&gt;</strong>：安装apk文件，其中-r表示重装该apk，-s表示将apk安装到SD卡上，默认是安装到内部存储器上</li>
<li><strong>adb uninstall [packge] [-k]</strong>：从系统中卸载程序包，-k表示只删除该应用程序，但保留该应用程序所有的数据和缓存目录</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下杀死占用某个端口的进程</title>
    <url>/Windows%E4%B8%8B%E6%9D%80%E6%AD%BB%E5%8D%A0%E7%94%A8%E6%9F%90%E4%B8%AA%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>很多情况下，例如：开发Java有关Socket等网络通信的程序时，我们利用某个Port进行调试连接是否成功的过程中，会出现java.net.BindException: Address already in use: JVM_Bind 的错误。<br>  下面，简单说明整个解放某个端口的过程（<a href="http://jingyan.baidu.com/article/4dc40848b4fac8c8d946f1eb.html" target="_blank" rel="noopener">原文章</a>）：</p>
</blockquote>
<a id="more"></a>

<h2 id="一、简单除暴"><a href="#一、简单除暴" class="headerlink" title="一、简单除暴"></a>一、简单除暴</h2><hr>
<ol>
<li>方法一：重启电脑（麻烦）（实际上关联着：重置所有相关的虚拟器）</li>
<li>方法二：重启编译器（有时会失效）</li>
</ol>
<h2 id="二、命令行方法"><a href="#二、命令行方法" class="headerlink" title="二、命令行方法"></a>二、命令行方法</h2><hr>
<ol>
<li>首先，调出终端：<ul>
<li>方法一：Windows键+r,输入cmd</li>
<li>方法二：开始–&gt;搜素“cmd”,点击运行</li>
<li>方法三：开始–&gt;运行，输入cmd</li>
</ul>
</li>
<li>终端输入：<strong><em>netstat -ano</em></strong><br>   目的：输出所有被占用的端口<br>   每一列分别表示：<em>协议 | 本地地址 | 外部地址 | 状态 | PID</em></li>
<li>终端输入：<strong><em>netstat -ano | findstr 1234</em></strong><br>   目的：输出所有的1234端口，从而<strong>查看最后一列它的PID是多少</strong>。<br>   注意：有的电脑会提示：“’netstat ‘不是内部或外部命令，也不是可运行的程序或者批处理文件”<br>   解决方法：那是因为操作不在系统system32文件夹下，所以只需要输入：<br>   <strong><em>cd c:\windows\system32\</em></strong><br>   回车，然后再接着输入即可</li>
<li>终端输入：<strong><em>taskkill  /f /pid  4567</em></strong>【1234端口对应的PID】</li>
<li>成功杀死进程。</li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
        <category>bug解决</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>进程杀死</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发细节--查漏补缺（一）：UI篇</title>
    <url>/Android%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82--%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AUI%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>引言：一开始，先和大家可能从最开始接触Android开发时就存在的一些我们用过但不太关注的UI部件相关知识。第一篇，先说一下有关：Menu、标题栏 和 Android主题（Theme）的相关知识。</p>
</blockquote>
<a id="more"></a>

<h2 id="Android-Theme（主题）"><a href="#Android-Theme（主题）" class="headerlink" title="Android Theme（主题）"></a>Android Theme（主题）</h2><hr>
<blockquote>
<p>注意：一般我们使用或者自定义style等，大多用于单个View，称为View的样式。而样式也能用于Activity或整个Application，这时就需要在相应<activity>或<application>标签中设置android:theme<em>属性，引用的其实也是style</em>，但一般称为主题。</p>
</blockquote>
<ul>
<li><p>themes.xml: 低版本的主题，目标API level一般在10以下</p>
</li>
<li><p>themes_hole.xml: 从 API level 11添加的主题</p>
<p>  <img src="https://app.yinxiang.com/shard/s49/res/fe5bdb86-3dc5-48b7-b3a1-4cdebb49c0b3.png" alt=""></p>
</li>
</ul>
<p><strong>一、 support v7库</strong><br>   作用：用于某些控件和主题等兼容至Android2.1版本（API 7）<br>   对于Theme主题的影响：Theme.AppCompat系列兼容主题，在引用到v7包之后，就要求使用，而android3.0以上系统带有的Theme.Holo系列主题，则是未引用兼容包时注意使用。</p>
<ul>
<li>Android3.0及以上的版本的Style一般写法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;XXX&quot; parent=&quot;@android:style/Theme.Holo&quot;&gt;</span><br><span class="line">   &lt;item name=&quot;android:xxx&quot;&gt;yyy&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li>Android2.1及以上兼容版本的Style一般写法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;XXX&quot; parent=&quot;@style/Theme.AppCompat&quot;&gt;</span><br><span class="line">   &lt;item name=&quot;xxx&quot;&gt;yyy&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>二、 theme测试示例</strong></p>
<ol>
<li><p>无ActionBar</p>
<ul>
<li>白色背景： <code>Activity</code>+ <code>android:theme=&quot;@style/Theme.AppCompat.Light&quot;</code></li>
<li>黑色背景： <code>Activity</code>+ <code>android:theme=&quot;@style/Theme.AppCompat&quot;</code></li>
<li>自定义默认背景：<code>Activity</code>  或者 <code>Activity</code>+<code>android:theme=&quot;@style/AppTheme&quot;</code></li>
</ul>
</li>
<li><p>有ActionBar</p>
<ol>
<li>旧版本：继承ActionBarActivity<ul>
<li>全白色背景：<code>ActionBarActivity</code>+<code>android:theme=&quot;@style/Theme.AppCompat.Light&quot;</code></li>
<li>全黑色背景：<code>ActionBarActivity</code>+<code>android:theme=&quot;@style/Theme.AppCompat&quot;</code></li>
<li>白色背景黑色ActionBar：<code>ActionBarActivity</code>+<code>android:theme=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot;</code></li>
<li>自定义默认背景：<code>ActionBarActivity</code>  或者<code>ActionBarActivity</code>+<code>android:theme=&quot;@style/AppTheme&quot;</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><hr>
<blockquote>
<p> Android Menu 主要是两种：①OptionMenu【点击ActionBar的菜单选项或者手机硬件MENU按键触发显示菜单】 ②ContextMenu【指定的View或ViewGroup的长按触发】</p>
</blockquote>
<p><strong>一、 OptionMenu</strong></p>
<ol>
<li><p>方法执行流程<br><img src="http://upload-images.jianshu.io/upload_images/2369895-06df515625ff68b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OptionsMenu.png"></p>
</li>
<li><p>具体实现代码示例</p>
<ul>
<li>Activity代码中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      @Override</span><br><span class="line">    public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">        //方式一（java）</span><br><span class="line">         /*第一个参数是groupId，如果不需要可以设置为Menu.NONE。</span><br><span class="line">将若干个menu item都设置在同一个Group中，可以使用setGroupVisible()，setGroupEnabled()，setGroupCheckable()这样的方法，</span><br><span class="line">而不需要对每个item都进行setVisible(), setEnable(), setCheckable()这样的处理，这样对我们进行统一的管理比较方便</span><br><span class="line">       * 第二个参数就是item的ID，我们可以通过menu.findItem(id)来获取具体的item</span><br><span class="line">       * 第三个参数是item的顺序，一般可采用Menu.NONE，具体看本文最后MenuInflater的部分</span><br><span class="line">       * 第四个参数是显示的内容，可以是String，或者是引用Strings.xml的ID</span><br><span class="line">       */</span><br><span class="line">        menu.add(Menu.NONE,ONE_ID,Menu.NONE,&quot;1 Pixel&quot;);</span><br><span class="line">        menu.add(Menu.NONE, TWO_ID, Menu.NONE, &quot;2 Pixels&quot;);</span><br><span class="line">        menu.add(Menu.NONE, EIGHT_ID, Menu.NONE, &quot;8 Pixels&quot;);</span><br><span class="line">        ……</span><br><span class="line">         ///方式二（xml）</span><br><span class="line">        MenuInflater mi = getMenuInflater();</span><br><span class="line">        mi.inflate(R.menu.activity_actionbar,menu);</span><br><span class="line"></span><br><span class="line">        // 子菜单设置</span><br><span class="line">        //通过addSubMenu设置子菜单，作为item加入Menu。参数和addMenu一致，为了简单，我们这里的ID直接采用数字表示</span><br><span class="line">        SubMenu submenu = menu.addSubMenu(Menu.NONE, 100, Menu.NONE, &quot;子菜单测试&quot;);</span><br><span class="line">        //在SubMenu中增加子菜单的item</span><br><span class="line">        submenu.add(Menu.NONE,101,Menu.NONE,&quot;sub One&quot;);</span><br><span class="line">        submenu.add(Menu.NONE,102,Menu.NONE,&quot;sub Two&quot;);</span><br><span class="line">        submenu.add(Menu.NONE,103,Menu.NONE,&quot;sub Three&quot;);</span><br><span class="line">        submenu.add(Menu.NONE,104,Menu.NONE,&quot;sub Four&quot;);</span><br><span class="line">        return super.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onPrepareOptionsMenu(Menu menu) &#123;</span><br><span class="line">        ///----------实现每次Menu打开时的操作---------------</span><br><span class="line">        return super.onPrepareOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onOptionsItemSelected(MenuItem item) &#123;</span><br><span class="line">        switch (item.getItemId())&#123;</span><br><span class="line">            case R.id.action_search:</span><br><span class="line">                Toast.makeText(this, &quot;搜索&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">               break;</span><br><span class="line">            case R.id.action_settings:</span><br><span class="line">                Toast.makeText(this, &quot;设置&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onOptionsItemSelected(item);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义的res/menu/activity_actionbar.xml：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:yourapp=&quot;http://schemas.android.com/apk/res-auto&quot; &gt;</span><br><span class="line">    &lt;!-- 搜索, 应该展示为动作按钮 --&gt;</span><br><span class="line">    &lt;!--不使用v7兼容库，那么，就可以使用android:showAsAction属性，否则，无法使用,但是能用自己指定的yourapp:showAction--&gt;</span><br><span class="line">    &lt;!--下面的属性：‘ifRoom’表示如果ActionBar有空间，就显示这个item项；‘never’表示默认不显示--&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/action_search&quot;</span><br><span class="line">        android:icon=&quot;@android:drawable/ic_menu_search&quot;</span><br><span class="line">        android:title=&quot;@android:string/search_go&quot;</span><br><span class="line">        yourapp:showAsAction=&quot;ifRoom&quot;  /&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/action_settings&quot;</span><br><span class="line">        android:title=&quot;设置&quot;</span><br><span class="line">        yourapp:showAsAction=&quot;never&quot;  /&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>二、 ContextMenu</strong></p>
<ol>
<li>方法执行流程：<br> 每次长按指定的View，自动在所按的位置处弹出menu。</li>
<li>设置流程：<ul>
<li>Activity中获取一个组件，如一个Button：<br><code>private Button btn;</code></li>
<li>让这个Button进行初始化并让其注册到ContextMenu中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btn  = (Button) findViewById(R.id.btn_actionbar);</span><br><span class="line">registerForContextMenu(btn);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>重写ContextMenu相关方法，让此方法触发时，弹出指定的ContextMenu【注意是ContextMenu类型的，不是Menu类型】：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123;</span><br><span class="line">    super.onCreateContextMenu(menu, v, menuInfo);</span><br><span class="line">    MenuInflater mi = getMenuInflater();</span><br><span class="line">    ///R.menu.activity_actionbar与上面OptionsMenu的一样!</span><br><span class="line">    mi.inflate(R.menu.activity_actionbar,menu);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public boolean onContextItemSelected(MenuItem item) &#123;</span><br><span class="line">    return super.onContextItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ActionBar"><a href="#ActionBar" class="headerlink" title="ActionBar"></a>ActionBar</h2><hr>
<ol>
<li><p>ActionBar的基本使用：</p>
<ol>
<li>Android 版本 &gt;= 3.0 ，所有使用Theme.Holo主题（及其子类）的Activity都包含了ActionBar，当<code>targetSdkVersion</code> 或 <code>minSdkVersion</code>属性被设置成“11”或者更大时，他是默认主题</li>
<li>Android版本&gt;=2.1 ，要添加ActionBar，需要加载Android Support库：<code>v7 appcompat</code>库（现在AS在新建项目时，基本都会为我们添加这个库）。然后：①让<code>Activity</code>继承<code>ActionBarActivity</code> ②在manifast.xml文件中，给<activity>添加一句：<code>&lt;activity android:theme=&quot;@style/Theme.AppCompat.Light&quot; ... &gt;</code></li>
</ol>
</li>
<li><p>xml中设定每个Activity的ActionBar上显示的标题（Label）：<br> 通过设置清单文件中Activity标签中的label属性，如：<code>&lt;activity android:name=&quot;.actionbar.MyActionBarActivity&quot;    android:label=&quot;ActionBar活动&quot; ……/&gt;</code><br><img src="http://upload-images.jianshu.io/upload_images/2369895-3a277f9988102697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</li>
<li><p>ActionBar从创建到行为实现</p>
<ul>
<li>创建相应的Activity：ActionBarActivity、AppCompatActivity（均位于v7 support库中，用于兼容到Android2.1版本，即API 7）</li>
<li>创建Menu菜单：<ul>
<li>方式一：java代码<br>在<strong>onCreateOptionsMenu(Menu menu)</strong>方法中，加入如下示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">  menu.add(Menu.NONE,ONE_ID,Menu.NONE,&quot;1 Pixel&quot;);</span><br><span class="line">        menu.add(Menu.NONE, TWO_ID, Menu.NONE, &quot;2 Pixels&quot;);</span><br><span class="line">        menu.add(Menu.NONE, EIGHT_ID, Menu.NONE, &quot;8 Pixels&quot;);</span><br><span class="line">       ……</span><br><span class="line">        return super.onCreateOptionsMenu(menu);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>方式二：xml定义后再引用<br>先创建xml菜单布局文件<strong>res/menu/my_menu.xml</strong>：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:yourapp=&quot;http://schemas.android.com/apk/res-auto&quot; &gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/action_search&quot;</span><br><span class="line">        android:icon=&quot;@android:drawable/ic_menu_search&quot;</span><br><span class="line">        android:title=&quot;@android:string/search_go&quot;</span><br><span class="line">        yourapp:showAsAction=&quot;ifRoom&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">    &lt;item android:id=&quot;@+id/action_settings&quot;</span><br><span class="line">        android:title=&quot;设置&quot;</span><br><span class="line">        yourapp:showAsAction=&quot;never&quot;</span><br><span class="line">  /&gt;</span><br><span class="line">…………</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure>
  此时，ActionBar已经有了菜单列表了！</li>
</ul>
</li>
<li>完善ActionBar信息：<br>  在Java代码中完善ActionBar信息  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getSupportActionBar().setIcon(R.mipmap.ic_launcher);</span><br><span class="line">getSupportActionBar().setSubtitle(&quot;我是subTitle&quot;);</span><br><span class="line">getSupportActionBar().setCustomView(R.layout.view_custom);</span><br><span class="line">getSupportActionBar().setLogo(R.mipmap.ic_launcher);</span><br><span class="line">getSupportActionBar().setElevation(50);</span><br></pre></td></tr></table></figure></li>
<li>最终截图<br><img src="http://upload-images.jianshu.io/upload_images/2369895-e076b6dc075cb7c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
</li>
<li><p>ActionBar的自定义背景<br>完整示例：<code>res/values/themes.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;  </span><br><span class="line">  &lt;!-- 应用于程序或者活动的主题 --&gt;   </span><br><span class="line"> &lt;style name=&quot;CustomActionBarTheme&quot;</span><br><span class="line">      parent=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot;&gt;  </span><br><span class="line">      &lt;item name=&quot;android:actionBarStyle&quot;&gt;@style/MyActionBar&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;android:actionBarTabTextStyle&quot;&gt;@style/MyActionBarTabText&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;android:actionMenuTextColor&quot;&gt;@android:color/holo_blue_bright&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;android:windowActionBarOverlay&quot;&gt;true&lt;/item&gt;</span><br><span class="line">       &lt;!-- 支持库兼容 --&gt;</span><br><span class="line">       &lt;item name=&quot;actionBarStyle&quot;&gt;@style/MyActionBar&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;actionBarTabTextStyle&quot;&gt;@style/MyActionBarTabText&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;actionMenuTextColor&quot;&gt;@android:color/holo_blue_bright&lt;/item&gt;</span><br><span class="line">       &lt;!--ActionBar的层次覆盖模式--&gt;</span><br><span class="line">        &lt;item name=&quot;windowActionBarOverlay&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">   &lt;!-- ActionBar 样式 --&gt;</span><br><span class="line">    &lt;style name=&quot;MyActionBar&quot;</span><br><span class="line">       parent=&quot;@style/Widget.AppCompat.ActionBar&quot;&gt;</span><br><span class="line">       &lt;item name=&quot;android:background&quot;&gt;@android:color/holo_green_dark&lt;/item&gt;</span><br><span class="line">       &lt;item name=&quot;android:titleTextStyle&quot;&gt;@style/MyActionBarTitleText&lt;/item&gt;</span><br><span class="line">        &lt;!-- 支持库兼容 --&gt;</span><br><span class="line">       &lt;item name=&quot;background&quot;&gt;@android:color/holo_green_dark&lt;/item&gt;</span><br><span class="line">        &lt;item name=&quot;titleTextStyle&quot;&gt;@style/MyActionBarTitleText&lt;/item&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">   &lt;!-- ActionBar 标题文本 --&gt;</span><br><span class="line">    &lt;style name=&quot;MyActionBarTitleText&quot;</span><br><span class="line">        parent=&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:textColor&quot;&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">        &lt;!-- 文本颜色属性textColor是可以配合支持库向后兼容的 --&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;!-- ActionBar Tab标签文本样式 --&gt;</span><br><span class="line">    &lt;style name=&quot;MyActionBarTabText&quot;</span><br><span class="line">        parent=&quot;@style/Widget.AppCompat.ActionBar.TabText&quot;&gt;</span><br><span class="line">        &lt;item name=&quot;android:textColor&quot;&gt;@android:color/holo_blue_light&lt;/item&gt;</span><br><span class="line">        &lt;!-- 文本颜色属性textColor是可以配合支持库向后兼容的 --&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用ActionBar快速构造返回上级的按钮<br>截图：<br><img src="http://upload-images.jianshu.io/upload_images/2369895-c87d204f1f047b1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>设置步骤：</p>
<ol>
<li>ActionBarActivity或者AppCompatActivity的onCreate()方法中设置：<ul>
<li><code>getSupportActionBar().setDisplayHomeAsUpEnabled(true);</code>  v7库兼容下使用</li>
<li><code>getActionBar().setDisplayHomeAsUpEnabled(true);</code>  非兼容形式，minSdkVersion&gt;=11时使用</li>
</ul>
</li>
<li>在想要设置此功能的Activity的<activity>标签中设置如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        &lt;activity android:name=&quot;.xxxx.SecondActivity&quot;</span><br><span class="line">    android:label=&quot;ActionBar活动&quot;</span><br><span class="line">    android:parentActivityName=&quot;.MyToolBarActivity&quot;    &gt;</span><br><span class="line">    &lt;!--meta-data用于兼容support4.0以下，指明上级活动--&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.PARENT_ACTIVITY&quot;</span><br><span class="line">        android:value=&quot;com.xxxxx.xxxxx.MainActivity&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><hr>
<p><strong>一、背景</strong></p>
<ul>
<li>Android5.0推出的一个MD风格的导航栏。</li>
<li>旨在取代ActionBar</li>
</ul>
<p><strong>二、优势</strong></p>
<ul>
<li>比ActionBar更加灵活：<ul>
<li>设置导航栏图标</li>
<li>设置App的logo</li>
<li>支持设置标题和子标题</li>
<li>支持添加一个或多个的自定义控件</li>
<li>支持Action Menu</li>
</ul>
</li>
<li>可以放置任何位置</li>
</ul>
<p><strong>三、用法</strong></p>
<ol>
<li><p>导入<strong>appcompat-v7</strong> 的兼容包，使用 <strong>android.support.v7.widget.Toolbar</strong> 进行开发。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///基本格式</span><br><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">         android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">         android:layout_width=&quot;match_parent&quot;</span><br><span class="line">         android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;/android.support.v7.widget.Toolbar&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>设置属性</p>
<ol>
<li><p>方式一：xml中设置（* 注意：v7兼容包的缘故，toolbar的属性不在系统中而需要额外查找导入，所有不能用<code>android:xxx</code>，而需要自定义<code>xmlns:toolbar=&quot;http://schemas.android.com/apk/res-auto&quot;</code>，另外，这种方式难以绑定menu菜单 *）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">        android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:background=&quot;@color/colorAccent&quot;</span><br><span class="line">        toolbar:navigationIcon=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        toolbar:logo=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">        toolbar:title=&quot;Title&quot;</span><br><span class="line">        toolbar:subtitle=&quot;subTitle&quot;</span><br><span class="line">        toolbar:titleTextColor=&quot;@color/colorPrimary&quot;</span><br><span class="line">        toolbar:subtitleTextColor=&quot;@color/colorPrimaryDark&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;!--引入普通View--&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_margin=&quot;20dp&quot;</span><br><span class="line">           android:text=&quot;点击&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">    &lt;!--引入自定义View--&gt;</span><br><span class="line">    &lt;include</span><br><span class="line">            layout=&quot;@layout/view_custom&quot;/&gt;</span><br><span class="line">    &lt;/android.support.v7.widget.Toolbar&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2369895-395aa3bbd52008a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方式一截图"></p>
</li>
<li><p>方式二：Java中设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Toolbar toolbar  = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">toolbar.setNavigationIcon(R.mipmap.ic_launcher);///导航icon</span><br><span class="line">toolbar.setLogo(android.R.drawable.ic_menu_search);///logo</span><br><span class="line">toolbar.setTitle(&quot;Title&quot;);///标题</span><br><span class="line">toolbar.setSubtitle(&quot;subTitle&quot;);///子标题</span><br><span class="line">toolbar.addView(new Button(this));//可自己动态加CustomView</span><br><span class="line">toolbar.inflateMenu(R.menu.activity_actionbar);///设置menu</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2369895-c4e559b8db4a60ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方式二截图"></p>
</li>
</ol>
</li>
<li><p>扩展</p>
<ul>
<li><p>改变menu item的文字颜色</p>
<ul>
<li>首先，在themes.xml文件中添加一个<style>，注意parent为<strong>parent=”Theme.AppCompat.Light.NoActionBar”</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style name=&quot;MyToolbarStyle&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/holo_red_light&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li>然后，给toolbar加上属性：** toolbar:popupTheme=”@style/MyToolbarStyle”**<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v7.widget.Toolbar</span><br><span class="line">  android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">  android:layout_width=&quot;match_parent&quot;</span><br><span class="line">  android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">  android:background=&quot;@color/colorAccent&quot;</span><br><span class="line">  toolbar:popupTheme=&quot;@style/MyToolbarStyle&quot;/&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2369895-e016baae7a52bd44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 改变menu item的文字颜色截图"></p>
</li>
</ul>
</li>
</ol>
<h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><hr>
<p>点击进入：<a href="http://androidjp.cn" target="_blank" rel="noopener">我的博客</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveX 和 RxJava 学习笔记</title>
    <url>/ReactiveX%20%E5%92%8C%20RxJava%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>引言：<br>学习了一下RxJava，理解其是一个以升级版的观察者模式为核心的异步处理库。旨在以更加简介、可读性更强的代码去实现数据异步处理和线程前通信。<br>下面，是本人对RxJava基础的学习笔记和总结，算是入门级别。</p>
</blockquote>
<a id="more"></a>

<h2 id="Rx介绍"><a href="#Rx介绍" class="headerlink" title="Rx介绍"></a>Rx介绍</h2><hr>
<p>  ReactiveX 简称 Rx。<br>  Rx = Observables【用于表示异步数据流】 + LINQ【用它的操作符查询异步数据流】 + Schedules【参数化异步数据流的并发处理】<br>  Rx用到的设计模式精华：观察者模式、迭代器模式<br>  RxJava中最重要的是：Observable【被观察者，事件源】+ Subscriber【观察者，订阅者】</p>
<h2 id="RxJava图解"><a href="#RxJava图解" class="headerlink" title="RxJava图解"></a>RxJava图解</h2><hr>
<p>  可先通过图解总览大概：<br>  RxJava之观察者模式的基本运作过程，如下：<br>  <img src="http://i2.piimg.com/567571/e01494ea59380277.png" alt="RxJava之观察者模式的基本运作过程"><br>  RxJava观察者模式顺序图，如下：<br>  <img src="http://i4.piimg.com/567571/1c2b91be67aab8a5.png" alt="RxJava观察者模式顺序图"></p>
<blockquote>
<p>注意：<code>Subscribe&lt;T&gt;</code> 是实现 <code>Observable&lt;T&gt;</code> 和 <code>Subscription</code> 的一个抽象类，在调用<code>subscribe(params)</code>方法时，如果这个<code>params</code>类型为<code>Observer&lt;T&gt;</code>，则最终它会转成<code>Subscriber&lt;T&gt;</code>，同时，此方法会返回一个<code>Subscription</code>对象，用于调用<code>unsubscribe()</code>方法解绑。</p>
</blockquote>
<h2 id="单线程中RxJava基本用法和例子"><a href="#单线程中RxJava基本用法和例子" class="headerlink" title="单线程中RxJava基本用法和例子"></a>单线程中RxJava基本用法和例子</h2><hr>
<h3 id="1-RxJava的几种基本写法（观察者模式）"><a href="#1-RxJava的几种基本写法（观察者模式）" class="headerlink" title="1. RxJava的几种基本写法（观察者模式）"></a>1. RxJava的几种基本写法（观察者模式）</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>  原始的观察者模式写法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///被观察者</span><br><span class="line">Observable&lt;String&gt; myObservable = Observable.create(</span><br><span class="line">                new Observable.OnSubscribe&lt;String&gt;()&#123;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</span><br><span class="line">                        subscriber.onNext(&quot;hello world&quot;);</span><br><span class="line">                        subscriber.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">///观察者</span><br><span class="line">Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onCompleted() &#123;&#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onError(Throwable e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onNext(String s) &#123;</span><br><span class="line">                Toast.makeText(MainActivity.this, s, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">///订阅（让两者产生关联,并启动）</span><br><span class="line"> myObservable.subscribe(mySubscriber);</span><br></pre></td></tr></table></figure>
<h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>  相对方式一，化简定义方法体的部分，使用Action来实现不完整回调，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//被观察者</span><br><span class="line">//等价于： call(String) -&gt; onNext(String)过程只调用一次 -&gt;onCompleted()/onError()</span><br><span class="line">Observable&lt;String&gt; myObservable = Observable.just(&quot;Hello world&quot;);</span><br><span class="line"></span><br><span class="line">///观察者</span><br><span class="line">///调用subscribe()时自动生成Subscriber并调用onNext()</span><br><span class="line">Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void call(String s) &#123;</span><br><span class="line">          Toast.makeText(MainActivity.this, s, Toast.LENGTH_SHORT).show();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">///观察者</span><br><span class="line">///调用subscribe()时自动生成Subscriber并调用onError()</span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    // onError()</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Throwable throwable) &#123;</span><br><span class="line">        // Error handling</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">///观察者</span><br><span class="line">///调用subscribe()时自动生成Subscriber并调用onCompleted()</span><br><span class="line">Action0 onCompletedAction = new Action0() &#123;</span><br><span class="line">    // onCompleted()</span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        Log.d(tag, &quot;completed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//////订阅（让两者产生关联,并启动）</span><br><span class="line"> myObservable.subscribe(onNextAction);</span><br><span class="line"> // myObservable.subscribe(onErrorAction);</span><br><span class="line"> // myObservable.subscribe(onCompletedAction);</span><br></pre></td></tr></table></figure>
<h4 id="方式三："><a href="#方式三：" class="headerlink" title="方式三："></a>方式三：</h4><p>  相对方式二，进行链式调用，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///省略Obervable对象的创建</span><br><span class="line">Observable.just(&quot;this is your sign：&quot;)</span><br><span class="line">                ///省略Action1对象的创建，直接匿名内部类方式添加订阅</span><br><span class="line">                .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void call(String s) &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.this, s, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：方式三中加了map这个RxJava的映射方法，用于将事件处理的复杂过程给被观察者来做，尽可能地减少观察者的工作。<br>知识点：</p>
</blockquote>
<ol>
<li>just：如果只是调用:  onNext() 【一到多次】 –&gt; onCompleted()这个过程，那么，可以使用just()快速创建Observable</li>
</ol>
<h3 id="2-基本应用"><a href="#2-基本应用" class="headerlink" title="2. 基本应用"></a>2. 基本应用</h3><h4 id="1-打印字符串数组"><a href="#1-打印字符串数组" class="headerlink" title="1. 打印字符串数组"></a>1. 打印字符串数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">Observable.from(names)</span><br><span class="line">    .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(String name) &#123;</span><br><span class="line">            Log.d(tag, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Observable.from(params) : params是数组类型的参数，在执行时，会调用Subscriber的onNext方法多次，每次处理一个item，之后，调用onCompleted()或者onError().</p>
</blockquote>
<h4 id="2-通过id获取图片并显示"><a href="#2-通过id获取图片并显示" class="headerlink" title="2. 通过id获取图片并显示"></a>2. 通过id获取图片并显示</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Drawable drawable) &#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="多线程中RxJava的使用"><a href="#多线程中RxJava的使用" class="headerlink" title="多线程中RxJava的使用"></a>多线程中RxJava的使用</h2><hr>
<blockquote>
<p>在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。</p>
</blockquote>
<h3 id="1-基本写法"><a href="#1-基本写法" class="headerlink" title="1. 基本写法"></a>1. 基本写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">                ///指定 subscribe() 发生在 IO 线程</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                // 指定 Subscriber 的回调发生在主线程</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .map(new Func1&lt;Integer, String&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public String call(Integer integer) &#123;</span><br><span class="line">                        Log.e(&quot;TestActivity&quot;, &quot;当前线程：&quot;+ Thread.currentThread());</span><br><span class="line">                        String res = &quot;字符串：&quot;+integer;</span><br><span class="line">                        return res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onCompleted() &#123;</span><br><span class="line">                        Toast.makeText(TestActivity.this,&quot;完成&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onError(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void onNext(String s) &#123;</span><br><span class="line">                        Log.e(&quot;TestActivity&quot;, &quot;当前线程：&quot;+ Thread.currentThread());</span><br><span class="line">                        Toast.makeText(TestActivity.this,s,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点：</p>
</blockquote>
<ol>
<li>just((1,2,3,4):<br>前者等价于如下代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</span><br><span class="line">            Log.e(&quot;TestActivity&quot;, &quot;call当前线程：&quot;+ Thread.currentThread());</span><br><span class="line">            subscriber.onNext(1);</span><br><span class="line">            subscriber.onNext(2);</span><br><span class="line">            subscriber.onNext(3);</span><br><span class="line">            subscriber.onNext(4);</span><br><span class="line">            subscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></li>
<li>Scheduler：<ul>
<li>背景：在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 <code>subscribe()</code>，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。</li>
<li>概念：调度器（线程控制器）</li>
<li>作用：切换线程传递事件，达到异步的目的</li>
<li>RxJava内置的Scheduler：（文章下面会详细总结）<ul>
<li><code>Schedulers.immediate()</code>:默认模式。直接使用当前线程运行。</li>
<li><code>Schedulers.newThread()</code>:总是启动新线程，并在新线程中运行。</li>
<li><code>Sched.io()</code>:I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。</li>
<li><code>Schedulers.computation()</code>: 计算所使用的 Scheduler。</li>
<li><code>AndroidSchedulers.mainThread()</code>:它指定的操作将在 Android 主线程运行。</li>
</ul>
</li>
</ul>
</li>
<li>Obervable.subscribeOn(Scheduler):让call方法以及之前的操作，发生在指定的线程中运行</li>
<li>Obervable.observeOn(Scheduler):让call之后的回调操作例如map、onNext等操作，发生在指定的线程中运行。</li>
</ol>
<h2 id="RxJava常用操作–数据转换处理"><a href="#RxJava常用操作–数据转换处理" class="headerlink" title="RxJava常用操作–数据转换处理"></a>RxJava常用操作–数据转换处理</h2><hr>
<blockquote>
<p>在事件传递过程中，如果观察者有需要，还可以通过数据转换处理，将传入的数据进行加工或调用，得到更多不同类型的信息。<br>RxJava提供给我们：map，flatMap来支持数据的‘一对一’和’一对多‘的转换。</p>
</blockquote>
<ol>
<li>map<br>作用：实现数据的一对一转化过程<br>以下例子可以说明：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///省略Obervable对象的创建</span><br><span class="line">Observable.just(&quot;this is your sign：&quot;)</span><br><span class="line">                ///将传入的参数由String变成String[]</span><br><span class="line">                .map(new Func1&lt;String, String[]&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public String[] call(String s) &#123;</span><br><span class="line">                        String[] strings = s.split(&quot; &quot;);</span><br><span class="line">                        return strings;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                ///将传入的参数由String[]变成Integer</span><br><span class="line">                .map(new Func1&lt;String[], Integer&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Integer call(String[] strings) &#123;</span><br><span class="line">                        int len = strings.length;</span><br><span class="line">                        return len;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                ///将传入的参数由Integer变成String</span><br><span class="line">                .map(new Func1&lt;Integer, String&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public String call(Integer integer) &#123;</span><br><span class="line">                        return integer+&quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                ///省略Action1对象的创建，直接匿名内部类方式添加订阅</span><br><span class="line">                .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void call(String s) &#123;</span><br><span class="line">                        Toast.makeText(MainActivity.this, s, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li>
<li>flatMap<br>作用：实现数据的一对多转换过程<br>先看如下具体例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void testFlatMap() throws CloneNotSupportedException &#123;</span><br><span class="line">      List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</span><br><span class="line">      ///测试：构建两个Student对象</span><br><span class="line">      Student xiaoming = new Student();</span><br><span class="line">      Student honghong = new Student();</span><br><span class="line">      ///测试：构建Course对象集</span><br><span class="line">      Course chinese = new Course(&quot;语文&quot;);</span><br><span class="line">      Course english = new Course(&quot;英语&quot;);</span><br><span class="line">      Course math  = new  Course(&quot;数学&quot;);</span><br><span class="line"></span><br><span class="line">      ///进行赋值操作，这样一来：</span><br><span class="line">      /// xiaoming：id为“2222”，并有两门课程：语文和英语</span><br><span class="line">      /// honghong：id为“007” ，并有两门课程：英语和数学</span><br><span class="line">      xiaoming.id= &quot;2222&quot;;</span><br><span class="line">      honghong.id= &quot;007&quot;;</span><br><span class="line">      xiaoming.courseList = new ArrayList&lt;&gt;();</span><br><span class="line">      xiaoming.courseList.add(chinese.clone());</span><br><span class="line">      xiaoming.courseList.add(english.clone());</span><br><span class="line">      honghong.courseList = new ArrayList&lt;&gt;();</span><br><span class="line">      honghong.courseList.add(english.clone());</span><br><span class="line">      honghong.courseList.add(math.clone());</span><br><span class="line"></span><br><span class="line">      studentList.add(xiaoming);</span><br><span class="line">      studentList.add(honghong);</span><br><span class="line"></span><br><span class="line">      ///下面的过程，就是提取：列表中的列表</span><br><span class="line">      Observable.from(studentList)</span><br><span class="line">              .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Observable&lt;Course&gt; call(Student student) &#123;</span><br><span class="line">                      Log.e(&quot;学生信息&quot;, student.id);</span><br><span class="line">                      return Observable.from(student.courseList);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .map(new Func1&lt;Course, String&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public String call(Course course) &#123;</span><br><span class="line">                      return course.name;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void call(String s) &#123;</span><br><span class="line">                      Log.e(&quot;course信息&quot;,s);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
最终得到结果为：<br><img src="http://i1.piimg.com/567571/6f2f3e1300243da9.png" alt=""></li>
</ol>
<blockquote>
<p>知识点：</p>
</blockquote>
<ol>
<li>flatMap：<ul>
<li>作用：实现传递数据的一对多变换（比如：我想要对一个列表中每一个item都进行一个数据类型转换并输出的操作）</li>
<li>原理：<ul>
<li>1)使用传入的事件对象创建一个 Observable 对象</li>
<li>2)并不发送这个 Observable, 而是将它激活，于是它开始发送事件</li>
<li>3)每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法</li>
<li>结果：把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</li>
</ul>
</li>
</ul>
</li>
<li>Funx 和 Actionx：<ul>
<li>‘x’的意义：从0开始，表示有x个参数的Fun()和Action()方法。</li>
</ul>
</li>
</ol>
<h2 id="RxJava各方法汇总"><a href="#RxJava各方法汇总" class="headerlink" title="RxJava各方法汇总"></a>RxJava各方法汇总</h2><hr>
<h3 id="1-用于创建Observable的操作符："><a href="#1-用于创建Observable的操作符：" class="headerlink" title="1. 用于创建Observable的操作符："></a>1. 用于创建Observable的操作符：</h3><ul>
<li>filter() —输出和输入相同的元素，并且会过滤掉那些不满足检查条件的。</li>
<li>take() —输出最多指定数量的结果。</li>
<li>Delay() —让发射数据的时机延后一段时间</li>
<li>Create — 通过调用观察者的方法从头创建一个Observable</li>
<li>Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable</li>
<li>Empty/Never/Throw — 创建行为受限的特殊Observable</li>
<li>From — 将其它的对象或数据结构转换为Observable</li>
<li>Interval — 创建一个定时发射整数序列的Observable</li>
<li>Just — 将对象或者对象集合转换为一个会发射这些对象的Observable</li>
<li>Range — 创建发射指定范围的整数序列的Observable</li>
<li>Repeat — 创建重复发射特定的数据或数据序列的Observable</li>
<li>Start — 创建发射一个函数的返回值的Observable</li>
<li>Timer — 创建在一个指定的延迟之后发射单个数据的Observable</li>
</ul>
<h3 id="2-用于对Observable发射的数据进行变换的操作符："><a href="#2-用于对Observable发射的数据进行变换的操作符：" class="headerlink" title="2. 用于对Observable发射的数据进行变换的操作符："></a>2. 用于对Observable发射的数据进行变换的操作符：</h3><ul>
<li>Buffer — 缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个</li>
<li>FlatMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。</li>
<li>GroupBy — 分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据</li>
<li>Map — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项</li>
<li>Scan — 扫描，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射这些值</li>
<li>Window — 窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集</li>
</ul>
<h3 id="3-线程切换和控制相关操作符："><a href="#3-线程切换和控制相关操作符：" class="headerlink" title="3. 线程切换和控制相关操作符："></a>3. 线程切换和控制相关操作符：</h3><ul>
<li>subscribeOn(Scheduler) — 指定事件的call方法以及以前的操作到一个线程中</li>
<li>observeOn(Scheduler) — 指定事件的call方法之后的操作（如：map(),onNext(),onCompleted(),onError()）到一个线程中【注意：不包括Subscriber.onStart()方法，该方法在默认它所在的线程中执行】</li>
<li>参数Scheduler有：<ul>
<li>Schedulers.immediate():默认模式。直接使用当前线程运行。</li>
<li>Schedulers.newThread():总是启动新线程，并在新线程中运行。</li>
<li>Sched.io():I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程</li>
<li>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>AndroidSchedulers.mainThread():它指定的操作将在 Android 主线程运行。</li>
</ul>
</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><hr>
<ul>
<li><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="noopener">http://blog.csdn.net/lzyzsd/article/details/41833541</a></li>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Observables.html" target="_blank" rel="noopener">https://mcxiaoke.gitbooks.io/rxdocs/content/Observables.html</a></li>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">http://gank.io/post/560e15be2dca930e00da1083</a></li>
</ul>
]]></content>
      <categories>
        <category>Rx</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>透侧理解-Android事件分发</title>
    <url>/%E9%80%8F%E4%BE%A7%E7%90%86%E8%A7%A3-Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>网上看过不少文章，也看过书籍“Android群英传”中有关事件分发的片段，发现，其实总结起来，Android的事件分发机制并不难，下面，给大家分享一个简介易懂的Android事件分发过程。并通过一个简单实际的Demo，来加以说明</p>
</blockquote>
<a id="more"></a>
<h2 id="事件分发过程简单图解"><a href="#事件分发过程简单图解" class="headerlink" title="事件分发过程简单图解"></a>事件分发过程简单图解</h2><hr>
<blockquote>
<p>滑动、点击、长按、松开等，归根结底都是触摸事件，而像点击“Back”或者“Home”等，那就归为 onKeyDown事件处理中。</p>
</blockquote>
<h3 id="View的事件分发过程"><a href="#View的事件分发过程" class="headerlink" title="View的事件分发过程"></a>View的事件分发过程</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p>  <img src="http://i2.piimg.com/567571/d4392bae47c97773.png" alt="View的事件分发过程"></p>
<h4 id="简单过程"><a href="#简单过程" class="headerlink" title="简单过程"></a>简单过程</h4><ol>
<li><p>View接收到触摸事件，直接执行onDispatchTouchEvent</p>
<ul>
<li>①判断View本身是否处于enabled状态（enable为true与否？）：是，到②</li>
<li>②onTouchListener是否为null，否，到③</li>
<li>③执行onTouchListener.onTouch(),如果返回为true，则事件被消费了，整个过程结束</li>
</ul>
</li>
<li><p>上面三个小步骤中：①View的enabled为true 或者 ② onTouchListener为null 或者 onTouch()返回为false，那么，都执行onTouchEvent(event)</p>
<ul>
<li>判断View是否可点击或长按，可以，那么，onTouchEvent一定返回true，事件一定在这里被消耗</li>
<li>查看是否有代理，有，就把事件给代理去处理，onTouchEvent一定返回true，事件一定在这里被消耗</li>
<li>如果不能点击、不能长按，那么，事件无法在这里就被消费，还要最后给回父ViewGroup处理</li>
<li>如果可以点击或者长按，那么，过了clickable和代理（mTouchDelegate）的判断后，开始了不同ACTION的处理：<ul>
<li>如果view的enabled为true，并且DOWN事件持续了一定时间，那么，onLongClickListener.onLongClick()执行</li>
<li>如果view的enabled为true，并且onLongClickListener.onLongClick()方法返回值为false，并且UP事件处理时，那么，onClickListener.onClick()执行</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
</blockquote>
<ol>
<li>当View的enabled为false时，所有与触摸事件的相关的Listener的方法都不会执行</li>
<li>不论View是否可点击，默认情况下【onTouch()方法返回false时】View的onTouchEvent()总会执行</li>
<li>只要View是可点击或可长按的，onTouchEvent()一定会返回true，表示事件一定会在此被消耗。</li>
</ol>
</li>
</ol>
<h3 id="ViewGroup配合子View的事件分发过程"><a href="#ViewGroup配合子View的事件分发过程" class="headerlink" title="ViewGroup配合子View的事件分发过程"></a>ViewGroup配合子View的事件分发过程</h3><h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p>  <img src="http://i4.piimg.com/567571/d3e0a34d6ebfa732.png" alt="ViewGroup配合子View的事件分发过程"></p>
<h4 id="简单过程-1"><a href="#简单过程-1" class="headerlink" title="简单过程"></a>简单过程</h4><ol>
<li><p>每个触摸事件产生，都会首先从根布局开始，将事件进行分发，可以它自己处理这个事件（把他拦截，不给子View），也可以分发给它的子View/ViewGroup去处理</p>
</li>
<li><p>执行ViewGroup的dispatchTouchEvent，对于每一个ACTION，都会有一个IF块，每个事件都会做两个判断：①是否允许自身去拦截 ②是否拦截</p>
</li>
<li><p>在上述的“②是否拦截”中，就是执行ViewGroup的onInterceptTouchEvent 方法，看其返回值是否为true，是，则进行事件拦截</p>
</li>
<li><p>如果不拦截该事件，那么：</p>
<ul>
<li>DOWN事件：获取当前x、y坐标的子View，赋值给mMotionTarget , 然后执行mMotionTarget.dispatchTouchEvent (也就是找到可以处理该事件的子View<br>，然后递归地让子View做事件分发)</li>
<li>MOVE事件：如果mMotionTarget不为null，直接执行mMotionTarget.dispatchTouchEvent 让他去分发这个MOVE事件</li>
<li>UP事件：在给子View分发事件前，修改坐标系统，把当前触摸位置的x、y分别减去child.left 和 child.top,再传给child【此过程将点击的位置的相对对象，从当前ViewGroup换成子View】</li>
</ul>
</li>
<li><p>如果拦截该事件，则自己执行onTouchEvent进行事件处理</p>
<blockquote>
<p>注意：实际的View上的点击事件，如果整个经过过程，是从父ViewGroup的事件分发，到子View上的事件分发处理，再返回到父ViewGroup的过程【V形】</p>
</blockquote>
</li>
</ol>
<h2 id="事件的拦截"><a href="#事件的拦截" class="headerlink" title="事件的拦截"></a>事件的拦截</h2><hr>
<h3 id="ViewGroup-如何实现拦截"><a href="#ViewGroup-如何实现拦截" class="headerlink" title="ViewGroup 如何实现拦截"></a>ViewGroup 如何实现拦截</h3><p>ViewGroup.onInterceptTouchEvent(MotionEvent ev)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int action = ev.getAction();  </span><br><span class="line">        switch (action)  </span><br><span class="line">        &#123;  </span><br><span class="line">        case MotionEvent.ACTION_DOWN:  </span><br><span class="line">            //如果你觉得需要拦截  </span><br><span class="line">            return true ;   </span><br><span class="line">        case MotionEvent.ACTION_MOVE:  </span><br><span class="line">            //如果你觉得需要拦截  </span><br><span class="line">            return true ;   </span><br><span class="line">        case MotionEvent.ACTION_UP:  </span><br><span class="line">            //如果你觉得需要拦截  </span><br><span class="line">            return true ;   </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        return false;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于此方法返回true时，倒置mMotionTarget为null，无法往子View传递事件。<br>优先级：DOWN -&gt; MOVE -&gt; UP</p>
<ul>
<li><p>在DOWN return true:子View的 DOWN,MOVE,UP过程都不会捕获事件</p>
</li>
<li><p>在MOVE return true：子View的MOVE，UP过程都不会捕获事件</p>
<p>子View如何让父ViewGroup不去拦截某个事件：</p>
<p>通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requestDisallowInterceptTouchEvent(boolean)</span><br></pre></td></tr></table></figure>
<p>设置是否允许父ViewGroup拦截，具体写法如下。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event)  </span><br><span class="line">    &#123;  </span><br><span class="line">        getParent().requestDisallowInterceptTouchEvent(true);    </span><br><span class="line">        int action = event.getAction();  </span><br><span class="line"></span><br><span class="line">        switch (action)  </span><br><span class="line">        &#123;  </span><br><span class="line">        case MotionEvent.ACTION_DOWN:  </span><br><span class="line">            Log.e(TAG, &quot;dispatchTouchEvent ACTION_DOWN&quot;);  </span><br><span class="line">            break;  </span><br><span class="line">        case MotionEvent.ACTION_MOVE:  </span><br><span class="line">            Log.e(TAG, &quot;dispatchTouchEvent ACTION_MOVE&quot;);  </span><br><span class="line">            break;  </span><br><span class="line">        case MotionEvent.ACTION_UP:  </span><br><span class="line">            Log.e(TAG, &quot;dispatchTouchEvent ACTION_UP&quot;);  </span><br><span class="line">            break;  </span><br><span class="line"></span><br><span class="line">        default:  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return super.dispatchTouchEvent(event);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>这是ViewGroup MOVE 和 UP 拦截的部分源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;  </span><br><span class="line">            ………………</span><br><span class="line"></span><br><span class="line">            return true;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，当子View中设置了不允许父ViewGroup去拦截，那么，相当于设置了这里的disallowIntercept 为 true，于是，上面源码的if块直接被忽略了，从而实现了不拦截。</p>
<blockquote>
<p>注意： 如果在父ViewGroup的 onInterceptTouchEvent(event) 方法中，关于ACTION_DOWN 的事件判断，直接返回true，那么，子View是无法获取到ACTION_DOWN 的事件的。</p>
</blockquote>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>当ViewGroup找不到分发事件的子View：</p>
<ul>
<li>情况：当ViewGroup的dispatchTouchEvent()中的ACTION_DOWN事件的方法过程如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (child.dispatchTouchEvent(ev))  &#123;  </span><br><span class="line">                              // Event handled, we have a target now.  </span><br><span class="line">                              mMotionTarget = child;  </span><br><span class="line">                              return true;  </span><br><span class="line">                          &#125;</span><br></pre></td></tr></table></figure>
这里，如果子View的dispatchTouchEvent(ev)为false，也就是没有子View去接收这个DOWN事件或者说子View不可点击和长按，于是，这个DOWN事件就没有处理掉，那么，ViewGroup本身的dispatchTouchEvent对于这个DOWN事件，也返回false，表示需要再给到ViewGroup的父类去做，那么，我们知道，ViewGroup父类是View，于是，最终，这个DOWN事件，还是给到了ViewGroup本身来做。<br>（我们没有找到做这个事件的target，就意味着我们自己处理了～～）<blockquote>
<p>当子View可点击或长按，那么，就必定能够自己消费这些事件。</p>
</blockquote>
</li>
</ul>
<h2 id="Demo下载"><a href="#Demo下载" class="headerlink" title="Demo下载"></a>Demo下载</h2><hr>
<p>  本人上传了一个简单的测试Demo，用于测试事件分发过程，还有疑惑的朋友可以下载Demo来跑跑，看看整个log过程，会更加理解整个Android事件分发过程。<br>  Demo github地址：<a href="https://github.com/androidjp/jp-event-demo" target="_blank" rel="noopener">https://github.com/androidjp/jp-event-demo</a></p>
<blockquote>
<p> Demo项目中gradle版本为2.2.1，插件版本为1.5.0，另外，demo导入了库：com.jakewharton:butterknife:7.0.1</p>
</blockquote>
<p>  Demo主界面如下：<br>  <img src="http://i1.piimg.com/567571/453e3e2a3c8da57d.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr>
<ul>
<li>触摸事件的分发处理过程：父ViewGroup去分发事件(分发当中想拦截就拦截) –&gt; 子View接收到事件 –&gt; 子View看看自己是否可以做这个事（是否可点击/长按等） –&gt; 子View去尝试做了这个事（有监听，看onTouchListener.onTouch返回值） –&gt;最后，如果子View可以搞定（listener.onTouch或者onTouchEvent返回true），事件就被消费 ，否则，将事件抛回给父ViewGroup</li>
<li>onLongClickListener.onLongClick() 和 onClickListener.onClick() 是在onTouchEvent中进行判断和调用的</li>
<li>如果ViewGroup找到了能够处理该事件的子View，则直接给子View处理，自己的onTouchEvent不会被触发。</li>
<li>如果ViewGroup重写自己的onInterceptTouchEvent(event),并去拦截了一些事件（onInterceptTouchEvent返回true），那么，ViewGroup则自己去处理这些事件，执行自己的onTouchEvent方法</li>
<li>子View 通过调用getParent().requestDisallowInterceptTouchEvent(true); 阻止ViewGroup对其MOVE或者UP事件进行拦截</li>
<li>子View不管可不可以点击（是否clickable），只要手势触摸到它的范围，就会激发其onTouchEvent事件</li>
<li>当子View的enabled为false时，无论如何都不会执行onTouchListener.onTouch()方法、onClickListener.onClick()方法、onLongClickListener.onLongClick()方法等</li>
</ul>
<h2 id="细节与注意点"><a href="#细节与注意点" class="headerlink" title="细节与注意点"></a>细节与注意点</h2><hr>
<ol>
<li>消费了Down事件的view称为‘目标View’，目标View可接收后续事件（此时，非目标view只要不去拦截它的后续事件，那非目标view不会接收后续事件）</li>
<li>view或者viewGroup想要处理后续事件，就必须消费DOWN事件。当DOWN事件没有从父传到子的过程中没有被消耗过，那么他的后续MOVE事件和UP事件都将经过一个轮“V”字形传递过程后，回到Activity处，这时由Activity自己来接收和处理【也就是说，Activity自己觉得，我找不到一开始消耗DOWN事件的目标view，那我的后续事件肯定也找不到，所以我也不需要再往下分发MOVE和UP事件了，直接我自己来吧，处理得了就处理，处理不了就不管啦，dispatch到天上去】</li>
<li>DOWN事件被子view消费了，但后续的MOVE事件被view的父亲viewgroup拦截，此时，ViewGroup将代替子view称为新一代目标view。【因为，有DOWN事件被消费过， 那么Activity就知道有个TargetView存在，那么，在外界有后续事件传进来时，Activity会将事件分发到下面来，让这个TargetView（Activity不知道它是谁，只知道它存在）去获取并消费它，此时，ViewGroup去拦截这些后续事件，那么，首先：①targetView是子View，是事件要去找的目标，但是，找不到（因为它被拦截了），②于是，它选择暂时让拦截了它的父ViewGroup充当起TargetView】</li>
<li>UP事件与MOVE事件等都属于DOWN的后续事件，情况与总结三类似。</li>
<li>如果总结三的“拦截”不存在，那么，子View就会一直被当做TargetView，不管它处不处理后续事件，这些后续事件都不会给别人处理了（“V”过程，就算返回给上层ViewGroup（不包括Activity），这时，也是路过而已，上层不会去处理它的）</li>
<li>从<u>第二点</u>和<u>第五点</u>中得出的，只要子view没有消费touch事件，在分发调用返回时，最终会给回Activity本身，让Activity自己来处理，不管Activity有没有能力消费此事件。</li>
<li>子view调用 <code>getParent().requestDisallowInterceptTouchEvent(true)</code>方法请求父类禁止拦截事件，那么这个方法会递归地请求所有的父类都禁止拦截事件（也就是让上层都收手）。而如果在Down事件的时候只是请求父View禁止拦截但子view本身又不消费Down事件（相当于，我叫爸爸别去管这件事，而我自己又不想管这件事，最终，这件事和后续的事都不会再给爸爸和我管了，Activity一怒之下自己管了），虽然父View不再拦截了，但后续事件也接收不到了(这个拦不拦截没有多大的意义，因为没有消费down事件，所以并不是目标view了，事件也就传递不到它了)。</li>
<li>如果两个View不是包含关系，而是重叠关系，比如：viewA压在viewB上面， 那么，上层的ViewA先拿到事件，如果消费了，那么事件不会传给viewB，否则，事件返回给调用处，接着再传递给viewB。</li>
<li><ul>
<li>父类的onTouchEvent方法要想执行，要么是等所有的子View都不消费Down事件，要么是父View把事件拦截。</li>
<li>如果子类消费了Down事件，而父View又想处理这个事件，则父View可以在dispatchTouchEvent方法处理touch事件</li>
<li>如果子View请求了禁止父View拦截，且父View还想要拦截的话，可在父View的dispatchTouchEvent方法中不调用super.dispatchTouchEvent则把事件拦截了</li>
</ul>
</li>
</ol>
<h2 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h2><hr>
<ol>
<li>比如你需要写一个类似slidingmenu的左侧隐藏menu，主Activity上有个Button、ListView或者任何可以响应点击的View，你在当前View上死命的滑动，菜单栏也出不来；因为MOVE事件被子View处理了~ 你需要这么做：在ViewGroup的dispatchTouchEvent中判断用户是不是想显示菜单，如果是，则在onInterceptTouchEvent(ev)拦截子View的事件；自己进行处理，这样自己的onTouchEvent就可以顺利展现出菜单栏了</li>
<li>如果你需要用到 （左右滑动切换Tab界面+上下滑动界面内列表） 时，这里很可能就出现滑动卡卡顿顿或者滑动失灵的问题，就需要根据你手势滑动的总体角度是横向还是纵向，来判断是切换tab页面还是滚动列表。</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><hr>
<p><a href="http://www.jianshu.com/p/2be492c1df96" target="_blank" rel="noopener">可能是讲解Android事件分发最好的文章</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/39102591" target="_blank" rel="noopener">鸿洋的ViewGroup事件分发</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>事件分发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统的.apk文件和.dex文件</title>
    <url>/Android%E7%B3%BB%E7%BB%9F%E7%9A%84-apk%E6%96%87%E4%BB%B6%E5%92%8C-dex%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>给大家简单介绍下 apk 和 dex 两种文件的概念以及他们的联系。</p>
</blockquote>
<a id="more"></a>

<h2 id="apk文件"><a href="#apk文件" class="headerlink" title=".apk文件"></a>.apk文件</h2><ol>
<li><p>概念<br>&emsp;&emsp;apk，全称Android Package，即Android安装包。<br>（通过apk文件直接传到Android模拟器或Android手机中执行即可安装。）<br>apk文件本质上是jar或zip文件</p>
</li>
<li><p>apk文件目录结构</p>
</li>
</ol>
<p><img src="http://i1.piimg.com/567571/f2e012e7f1fa25c5.png" alt=""></p>
<pre><code>* META-INF -- Jar文件
* res -- 资源文件
* AndroidManifest -- 应用全局配置文件
* .dex -- Dalvik虚拟机字节码文件
* resource.arsc -- 编译后的二进制资源文件</code></pre><ol start="3">
<li>apk被调用的过程<p>
Android在运行程序时首先需要解压apk文件，然后获取编译后的androidmanifest.xml文件中配置信息，执行dex程序。</p>


</li>
</ol>
<h2 id="dex文件"><a href="#dex文件" class="headerlink" title=".dex文件"></a>.dex文件</h2><ol>
<li><p>概念</p>
<p>
Dex是Dalvik VM executes的全称，即Android Dalvik执行程序，本身是将app的除了界面通常执行时都进行优化 。优化后的文件大小会有所增加。 优化发生的时机有两个：对于预置应用，可以在系统编译后，生成优化文件，以ODEX结尾。这样在发布时除APK文件（不包含DEX）以外，还有一个相应的Android DEX文件；对于非预置应用，包含在APK文件里的DEX文件会在运行时被优化，优化后的文件将被保存在缓存中。</p>
</li>
<li><p>关于Zygote虚拟机进程</p>
<p>
&emsp;Zygote是一个虚拟机进程，同时也是一个虚拟机实例的孵化器，每当系统要求执行一个 Android应用程序，Zygote就会FORK出一个子进程来执行该应用程序。这样做的好处显而易见：Zygote进程是在系统启动时产生的，它会完成虚拟机的初始化，库的加载，预置类库的加载和初始化等等操作，而在系统需要一个新的虚拟机实例时。<br/>
&emsp;Zygote通过复制自身，最快速的提供个系统。另外，对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域，大大节省了内存开销。
</p>
</li>
<li><p>dex文件格式</p>
</li>
</ol>
<p><img src="http://i2.piimg.com/567571/f7db349234a76ce0.png" alt=""></p>
<h2 id="apk文件-与-dex文件-的关系"><a href="#apk文件-与-dex文件-的关系" class="headerlink" title="apk文件 与 dex文件 的关系"></a>apk文件 与 dex文件 的关系</h2><ol>
<li><p>通过Android打包工具（appt） ： dex文件 +  资源文件 +  AndroidManifest.xml ==  apk文件</p>
</li>
<li><p>Apk打包过程</p>
<ol>
<li><p>打包.class文件为单一DEX文件并运行于Dalvik虚拟机</p>
</li>
<li><p>DEX文件打包进APK文件中（本质上是jar或zip文件）</p>
<p><img src="http://i2.piimg.com/567571/a13ff962c727a7cb.png" alt=""></p>
</li>
</ol>
</li>
<li><p>Apk安装过程</p>
<ol>
<li><p>安装时，系统提取DEX文件进行检查和验证。</p>
</li>
<li><p>第一次运行时，系统完成DEX优化，转换成odex文件。</p>
</li>
<li><p>odex文件存放在/data/dalvik-cache目录并在执行时加载进内存执行。</p>
<p><img src="http://i2.piimg.com/567571/f34896093441f353.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<hr>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="http://blog.163.com/yglzz_163/blog/static/388555201242762822593/" target="_blank" rel="noopener">http://blog.163.com/yglzz_163/blog/static/388555201242762822593/</a><br><br/><br><a href="http://blog.chinaunix.net/uid-24439730-id-355883.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-24439730-id-355883.html</a><br><br/><br><a href="http://bbs.pediy.com/showthread.php?t=177114" target="_blank" rel="noopener">http://bbs.pediy.com/showthread.php?t=177114</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>apk相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Android代码检测工具</title>
    <url>/Android%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>引言：努力提高代码质量是每一个开发人员必须具备的素质和自我要求。<br>但是靠自己总会不小心遗漏一些细节，所以引入代码检测工具，应用到软件工程中，以此帮助大家养成良好的编程习惯，提升技能。<br>  接下来，和大家一起分析Android相关的代码检测工具的用法。</p>
</blockquote>
<a id="more"></a>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>IDE：Android Studio</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>操作系统：Ubuntu</em></p>
<h3 id="代码检测工具分类"><a href="#代码检测工具分类" class="headerlink" title="代码检测工具分类"></a>代码检测工具分类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前常用的Java代码检测工具有：AndroidLint、CheckStyle、FindBugs、PDM</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，AndroidLint 已经作为插件被集成到Android Studio中；CheckStyle 可以作为插件安装使用；FindBugs 和 PDM 对Android Studio的支持较差，没有可用的插件或插件存在一些问题，但可以利用Gradle生成代码检测报告。</p>
<h3 id="代码检测工具的工作方式、功能"><a href="#代码检测工具的工作方式、功能" class="headerlink" title="代码检测工具的工作方式、功能"></a>代码检测工具的工作方式、功能</h3><h5 id="一、什么是静态代码分析"><a href="#一、什么是静态代码分析" class="headerlink" title="一、什么是静态代码分析"></a>一、什么是静态代码分析</h5><p>静态代码分析是指无需运行被测代码，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性，找出代码隐藏的错误和缺陷，如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等。
在软件开发过程中，静态代码分析往往先于动态测试之前进行，同时也可以作为制定动态测试用例的参考。统计证明，在整个软件开发生命周期中，30% 至 70% 的代码逻辑设计和编码缺陷是可以通过静态代码分析来发现和修复的。
但是，由于静态代码分析往往要求大量的时间消耗和相关知识的积累，因此对于软件开发团队来说，使用静态代码分析工具自动化执行代码检查和分析，能够极大地提高软件可靠性并节省软件开发和测试成本。</p>

<h5 id="二、静态代码分析工具的优势"><a href="#二、静态代码分析工具的优势" class="headerlink" title="二、静态代码分析工具的优势"></a>二、静态代码分析工具的优势</h5><ol>
<li>帮助程序开发人员自动执行静态代码分析，快速定位代码隐藏错误和缺陷。</li>
<li>帮助代码设计人员更专注于分析和解决代码设计缺陷。</li>
<li>显著减少在代码逐行检查上花费的时间，提高软件可靠性并节省软件开发和测试成本。</li>
</ol>
<h5 id="三、Java-静态代码分析理论基础和主要技术"><a href="#三、Java-静态代码分析理论基础和主要技术" class="headerlink" title="三、Java 静态代码分析理论基础和主要技术"></a>三、Java 静态代码分析理论基础和主要技术</h5><ul>
<li><p>缺陷模式匹配：缺陷模式匹配事先从代码分析经验中收集足够多的共性缺陷模式，将待分析代码与已有的共性缺陷模式进行模式匹配，从而完成软件的安全分析。这种方式的优点是简单方便，但是要求内置足够多缺陷模式，且容易产生误报。</p>
</li>
<li><p>类型推断：类型推断技术是指通过对代码中运算对象类型进行推理，从而保证代码中每条语句都针对正确的类型执行。这种技术首先将预定义一套类型机制，包括类 型等价、类型包含等推理规则，而后基于这一规则进行推理计算。类型推断可以检查代码中的类型错误，简单，高效，适合代码缺陷的快速检测。</p>
</li>
<li><p>模型检查：模型检验建立于有限状态自动机的概念基础之上，这一理论将被分析代码抽象为一个自动机系统，并且假设该系统是有限状态的、或者是可以通过抽象归 结为有限状态。模型检验过程中，首先将被分析代码中的每条语句产生的影响抽象为一个有限状态自动机的一个状态，而后通过分析有限状态机从而达到代码分析的 目的。模型检验主要适合检验程序并发等时序特性，但是对于数据值域数据类型等方面作用较弱。</p>
</li>
<li><p>数据流分析：数据流分析也是一种软件验证技术，这种技术通过收集代码中引用到的变量信息，从而分析变量在程序中的赋值、引用以及传递等情况。对数据流进行 分析可以确定变量的定义以及在代码中被引用的情况，同时还能够检查代码数据流异常，如引用在前赋值在后、只赋值无引用等。数据流分析主要适合检验程序中的 数据域特性。</p>
</li>
</ul>
<h3 id="四种工具简介-及其-特点"><a href="#四种工具简介-及其-特点" class="headerlink" title="四种工具简介 及其 特点"></a>四种工具简介 及其 特点</h3><h4 id="AndroidLint"><a href="#AndroidLint" class="headerlink" title="AndroidLint"></a>AndroidLint</h4><h6 id="nbsp-nbsp-1-简介"><a href="#nbsp-nbsp-1-简介" class="headerlink" title="&nbsp;&nbsp;1.简介"></a>&nbsp;&nbsp;1.简介</h6><p>
&nbsp;&nbsp;&nbsp;&nbsp;“Android lint工具是一个静态代码分析工具，它能检查安卓项目源文件的潜在缺陷和优化改进的正确性，安全性，性能，可用性，可访问性和国际化。”
正如官方网站所说，Android Lint是另一种静态分析工具，专门为Android服务。它是非常强大的，能给你大量的建议以提高你的代码质量。
</p>

<h6 id="nbsp-nbsp-2-使用方法"><a href="#nbsp-nbsp-2-使用方法" class="headerlink" title="&nbsp;&nbsp;2.使用方法"></a>&nbsp;&nbsp;2.使用方法</h6><div>
<p>&nbsp;&nbsp;&nbsp;&nbsp;点击Android studio工具栏 ——>Analyze ——>Inspect Code</p>
![](http://i2.piimg.com/567571/85bea3be27ae47b3.png)
<p>&nbsp;&nbsp;&nbsp;&nbsp;选择分析的文件范围</p>
![](http://i4.piimg.com/567571/c5cebf5f8a3f34e4.png)
<p>&nbsp;&nbsp;&nbsp;&nbsp;点击OK, 顶部会出现分析报告</p>
![](http://i2.piimg.com/567571/ec998783ca446c66.png)
</div>

<hr>
<h4 id="CheckStyle"><a href="#CheckStyle" class="headerlink" title="CheckStyle"></a>CheckStyle</h4><h6 id="nbsp-nbsp-1-简介-1"><a href="#nbsp-nbsp-1-简介-1" class="headerlink" title="&nbsp;&nbsp;1.简介"></a>&nbsp;&nbsp;1.简介</h6><p>
&nbsp;&nbsp;&nbsp;&nbsp;“Checkstyle是一个开发工具用来帮助程序员编写符合代码规范的Java代码。它能自动检查Java代码为空闲的人进行这项无聊(但重要)的任务。”
正如Checkstyle的开发者所言，这个工具能够帮助你在项目中定义和维持一个非常精确和灵活的代码规范形式。当你启动CheckStyle，它会根据所提供的配置文件分析你的Java代码并告诉你发现的所有错误。
Checkstyle会发现大量的问题，特别是在你运用了大量的规则配置，如同你设置了一个非常精确的语法。尽管我通过Gradle使用checkstyle，例如在我进行推送之前，我仍然推荐你为IntellJ/Android Studio使用checkstyle插件(你可以通过Android Studio的工作面板文件/设置/插件直接安装插件)。这种方式下，你可以根据那些为Gradle配置的相同文件在你的工程中使用checkstyle，但是远不止这些，你可以直接在Android Studio中获取带有超链接结果，这些结果通过超链接在你的代码中对应，这是非常有用的(Gradle的这种方式仍然很重要的，因为你可以使用它自动构建系统，如Jenkins)。
</p>

<h6 id="nbsp-nbsp-2-使用方法-1"><a href="#nbsp-nbsp-2-使用方法-1" class="headerlink" title="&nbsp;&nbsp;2.使用方法"></a>&nbsp;&nbsp;2.使用方法</h6><p>1) 首先进入设置页面进入Plugin页面，如图所示<br/><br><img src="http://i1.piimg.com/567571/9b310e60b1722877.png" alt="图一"></p>
<p>2) 点击Browse repositories进入选择页面，输入checkstyle即可选择安装，如图所示<br/><br><img src="http://i1.piimg.com/567571/be225c0df57aacc2.png" alt=""></p>
<p>3) 安装完成后点击Other Settings中的checkstyle进入选择文件页面，点击右上方的“+”选择你自己的checkstyle文件并应用即可。<br/><br><img src="http://i4.piimg.com/567571/4d7c24e4ceabc6e9.png" alt=""></p>
<div>
&nbsp;&nbsp;&nbsp;&nbsp;这里可以选择本地的checkstyle配置文件，也可以选择SVN等远程的配置文件
![](http://i4.piimg.com/567571/d43084f5d5da26b1.png)
</div>

<div>
&nbsp;&nbsp;&nbsp;&nbsp;安装完成后点击你自己写的java文件，再点击左边绿色箭头,点击“运行”，插件会根据你的checkstyle文件指明你代码的一些不规范的地方，如下图所示
![](http://i4.piimg.com/567571/e6cf59c8f4668370.png)
<p>&nbsp;&nbsp;&nbsp;&nbsp;按照提示修改代码即可</p>
</div>

<blockquote>
<p>注意：如果找不到或者install失败的情况下，可以去 此网站等下载 CheckStyle的zip包到本地，然后让Android Studio 的 “install plugin from disk”获取本地插件<br/><img src="http://i1.piimg.com/567571/2bf16b96058d09a4.png" alt=""></p>
</blockquote>
<hr>
<h4 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h4><h6 id="nbsp-nbsp-1-简介-2"><a href="#nbsp-nbsp-1-简介-2" class="headerlink" title="&nbsp;&nbsp;1.简介"></a>&nbsp;&nbsp;1.简介</h6><p>
&nbsp;&nbsp;&nbsp;&nbsp;Findbugs是否需要一个简介呢？我想它的名称已经让人顾名思义了。“FindBugs使用静态分析方法为出现bug模式检查Java字节码”。FindBugs基本上只需要一个程序来做分析的字节码，所以这是非常容易使用。它能检测到常见的错误，如错误的布尔运算符。FindBugs也能够检测到由于误解语言特点的错误，如Java参数调整（这不是真的有可能因为它的参数是传值）。
</p>

<h6 id="nbsp-nbsp-2-使用方法-2"><a href="#nbsp-nbsp-2-使用方法-2" class="headerlink" title="&nbsp;&nbsp;2.使用方法"></a>&nbsp;&nbsp;2.使用方法</h6><p>
&nbsp;&nbsp;&nbsp;&nbsp;详见下面的Gradle生成代码检测报告
</p>

<hr>
<h4 id="PDM"><a href="#PDM" class="headerlink" title="PDM"></a>PDM</h4><h6 id="nbsp-nbsp-1-简介-3"><a href="#nbsp-nbsp-1-简介-3" class="headerlink" title="&nbsp;&nbsp;1.简介"></a>&nbsp;&nbsp;1.简介</h6><p>
&nbsp;&nbsp;&nbsp;&nbsp;这个工具有个有趣的事实：PMD不存在一个准确的名称。(所以)在官网上你可以发现很有有趣的名称，例如:
* Pretty Much Done
* Project Meets Deadline

<p>&nbsp;&nbsp;&nbsp;&nbsp;事实上，PMD是一个工作有点类似Findbugs的强大工具，但是(PMD)直接检查源代码而不是检查字节码(顺便说句，PMD适用很多语言)。 (PMD和Findbugs)的核心目标是相同的，通过静态分析方法找出哪些模式引起的bug。因此为什么同时使用Findbugs和PMD呢？好吧！尽管Findbugs和PMD拥有相同的目标，(但是)他们的检查方法是不同的。所以PMD有时检查出的bug但是Findbugs却检查不出来，反之亦然。</p>
</p>

<h6 id="nbsp-nbsp-2-使用方法-3"><a href="#nbsp-nbsp-2-使用方法-3" class="headerlink" title="&nbsp;&nbsp;2.使用方法"></a>&nbsp;&nbsp;2.使用方法</h6><p>
&nbsp;&nbsp;&nbsp;&nbsp;详见下面的Gradle生成代码检测报告
</p>

<hr>
<h4 id="Gradle-命令生成代码检测报告"><a href="#Gradle-命令生成代码检测报告" class="headerlink" title="Gradle 命令生成代码检测报告"></a>Gradle 命令生成代码检测报告</h4><blockquote>
<p>相关Github示例 ：<strong>我强烈建议你拷贝下这个<a href="https://github.com/vincentbrison/vb-android-app-quality" target="_blank" rel="noopener">项目工程</a></strong>，尽管我将介绍的案例都是来自它。与此同时，你将能够测试下自己对这些工具的了解情况。</p>
</blockquote>
<h5 id="nbsp-nbsp-1-关于Gradle任务"><a href="#nbsp-nbsp-1-关于Gradle任务" class="headerlink" title="&nbsp;&nbsp;1.关于Gradle任务"></a>&nbsp;&nbsp;1.关于Gradle任务</h5><p>Gradle任务的概念(在Gradle中的含义)是理解该篇文章(以及如何以一种通用的方式写Gradle脚本)的基础。<strong>我强烈建议你去看下这两篇关于Gradle任务的文档（<a href="https://docs.gradle.org/current/userguide/tutorial_using_tasks.html" target="_blank" rel="noopener">Gradle文档第14章</a>和<a href="https://docs.gradle.org/current/userguide/writing_build_scripts.html" target="_blank" rel="noopener">Gradle文档第17章</a>）。这个文档包含了大量的例子，因此它非常容易开始学习。如果不想看英文原版，这里我推荐极客学院wiki更新的<a href="http://wiki.jikexueyuan.com/project/gradleIn-action/install-gradle.html" target="_blank" rel="noopener">Gradle中文指南</a></strong>现在，我假定你拷贝了我的Repo，你导入这个工程到你的Android Studio，并且你熟悉Gradle任务。如果不是，别担心，我将尽我最大的努力让我的讲解更有意义。</p>
<h5 id="nbsp-nbsp-2-示例各个检测工具的Gradle任务结构"><a href="#nbsp-nbsp-2-示例各个检测工具的Gradle任务结构" class="headerlink" title="&nbsp;&nbsp;2.示例各个检测工具的Gradle任务结构"></a>&nbsp;&nbsp;2.示例各个检测工具的Gradle任务结构</h5><p>
&nbsp;&nbsp;&nbsp;&nbsp;在上面的示例项目中，这几个检测工具的Gradle形式如图所示：
![](http://i4.piimg.com/567571/2c9c9f4ab702e286.png)
&nbsp;&nbsp;&nbsp;&nbsp;这里的config文件完全与Android项目解耦，如果你的项目要用到Gradle进行项目的代码检测并生成错误报告，直接复制此文件夹到你的项目根目录下即可
</p>

<h5 id="nbsp-nbsp-3-生成文档流程"><a href="#nbsp-nbsp-3-生成文档流程" class="headerlink" title="&nbsp;&nbsp;3.生成文档流程"></a>&nbsp;&nbsp;3.生成文档流程</h5><p>
&emsp;显然，如果我们能同时使用这四个工具会更好。你可以添加你的gradle任务之间的依赖，比如当你执行一个任务，其他任务则是第一个完成后执行。通常在Gradle中，通过让工具具有“check”任务来达到工具之间的相互关系：
check.dependsOn 'checkstyle', 'findbugs', 'pmd', 'lint'
<br/>
&emsp;现在，当执行“check” 任务的时候，Checkstyle, Findbugs, PMD, and Android Lint将会同时执行。在你执行/ commiting / pushing / ask merge request 之前进行质量检查是一个很棒的方式。
</p>


<p>&nbsp;&nbsp;&nbsp;&nbsp;1)首先，将示例项目中的这个config文件夹拷贝到你的项目根目录（或者可以参考它的写法，自己定制一个Gradle任务集）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2）打开终端，命令行执行Gradle任务：
`gradle check`
![](http://i4.piimg.com/567571/e1565a327d606735.png)
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3）任务执行完后，就可以在指定的输出目录下找到文档：（示例是输出在<your_buildPath>/reports目录下）
![](http://i4.piimg.com/567571/f275090129e02125.png)
</p>


<h5 id="nbsp-nbsp-4-各个工具的具体Gradle表现形式以及使用技巧"><a href="#nbsp-nbsp-4-各个工具的具体Gradle表现形式以及使用技巧" class="headerlink" title="&nbsp;&nbsp;4.各个工具的具体Gradle表现形式以及使用技巧"></a>&nbsp;&nbsp;4.各个工具的具体Gradle表现形式以及使用技巧</h5><h6 id="nbsp-nbsp-nbsp-nbsp-CheckStyle"><a href="#nbsp-nbsp-nbsp-nbsp-CheckStyle" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp; CheckStyle"></a>&nbsp;&nbsp;&nbsp;&nbsp; CheckStyle</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;1) Gradle任务形式<br><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码向你展示了在你的项目中使用Checkstyle的最基本的配置(如Gradle任务):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task checkstyle(type: Checkstyle) &#123;</span><br><span class="line">  configFile file(&quot;$&#123;project.rootDir&#125;/config/quality/checkstyle/checkstyle.xml&quot;)</span><br><span class="line">  configProperties.checkstyleSuppressionsPath = file(&quot;$&#123;project.rootDir&#125;/config/quality/checkstyle/suppressions.xml&quot;).absolutePath</span><br><span class="line">  source &apos;src&apos;</span><br><span class="line">  include &apos;**/*.java&apos;</span><br><span class="line">  exclude &apos;**/gen/**&apos;</span><br><span class="line">  classpath = files()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2) CheckStyle使用技巧</p>
<p>
&emsp;&emsp;Checkstyle会发现大量的问题，特别是在你运用了大量的规则配置，如同你设置了一个非常精确的语法。尽管我通过Gradle使用 checkstyle，例如在我进行推送之前，我仍然推荐你为IntellJ/Android Studio使用checkstyle插件(你可以通过Android Studio的工作面板文件/设置/插件直接安装插件)。这种方式下，你可以根据那些为Gradle配置的相同文件在你的工程中使用 checkstyle，但是远不止这些，你可以直接在Android Studio中获取带有超链接结果，这些结果通过超链接在你的代码中对应，这是非常有用的(Gradle的这种方式仍然很重要的，因为你可以使用它自动构建系统，如Jenkins)。
</p>



<h6 id="nbsp-nbsp-nbsp-nbsp-FindBugs"><a href="#nbsp-nbsp-nbsp-nbsp-FindBugs" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp; FindBugs"></a>&nbsp;&nbsp;&nbsp;&nbsp; FindBugs</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;1) Gradle任务形式<br><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码向你展示了在你的项目中使用Findbugs的最基本的配置(以Gradle任务为例):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task findbugs(type: FindBugs, dependsOn: assembleDebug) &#123;</span><br><span class="line">    ignoreFailures = false</span><br><span class="line">    effort = &quot;max&quot;</span><br><span class="line">    reportLevel = &quot;high&quot;</span><br><span class="line">    excludeFilter = new File(&quot;$&#123;project.rootDir&#125;/config/quality/findbugs/findbugs-filter.xml&quot;)</span><br><span class="line">    classes = files(&quot;$&#123;project.rootDir&#125;/app/build/intermediates/classes&quot;)</span><br><span class="line">    source &apos;src&apos;</span><br><span class="line">    include &apos;**/*.java&apos;</span><br><span class="line">    exclude &apos;**/gen/**&apos;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled = false</span><br><span class="line">        html.enabled = true</span><br><span class="line">        xml &#123;</span><br><span class="line">            destination &quot;$project.buildDir/reports/findbugs/findbugs.xml&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        html &#123;</span><br><span class="line">            destination &quot;$project.buildDir/reports/findbugs/findbugs.html&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    classpath = files()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;它是如此的像一个Checkstyle任务。尽管Findbugs支持HTML和XML两种报告形式，我选择HTML形式，因为这种形式更具有可读性。而且，你只需要把报告的位置设置为书签就可以快速访问它的位置。这个任务也会失败如果发现Findbgus错误失败(同样生成报告)。执行 FindBugs任务，就像执行CheckStyle任务（除了任务的名称是“FindBugs”）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2) FindBugs使用技巧</p>
<p>
&emsp;&emsp;由于Android项目是从Java项目略有不同，我强烈推荐使用FindBugs过滤器(规则配置)。你可以在这一个例子（例如项目之一）。它基本上忽略了R文件和你的Manifest文件。顺便说一句，由于(使用)FindBugs分析你的代码，你至少需要编译一次你的代码才能够测试它。
</p>

<h6 id="nbsp-nbsp-nbsp-nbsp-PMD"><a href="#nbsp-nbsp-nbsp-nbsp-PMD" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp; PMD"></a>&nbsp;&nbsp;&nbsp;&nbsp; PMD</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;1) Gradle任务形式<br><br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的代码向你展示了在你的项目中使用PMD的最基本的配置(以Gradle任务为例):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task pmd(type: Pmd) &#123;</span><br><span class="line">    ignoreFailures = false</span><br><span class="line">    ruleSetFiles = files(&quot;$&#123;project.rootDir&#125;/config/quality/pmd/pmd-ruleset.xml&quot;)</span><br><span class="line">    ruleSets = []</span><br><span class="line">    source &apos;src&apos;</span><br><span class="line">    include &apos;**/*.java&apos;</span><br><span class="line">    exclude &apos;**/gen/**&apos;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled = false</span><br><span class="line">        html.enabled = true</span><br><span class="line">        xml &#123;</span><br><span class="line">            destination &quot;$project.buildDir/reports/pmd/pmd.xml&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        html &#123;</span><br><span class="line">            destination &quot;$project.buildDir/reports/pmd/pmd.html&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;&emsp;&emsp;就PMD来说，它几乎与Findbugs相同。PMD支持HTML和XML两种报告形式，所以我再次选择HTML形式。我强烈建议你使用自己的通用配置集文件，正如同我在这个例子(check this file)中一样。所以，你当然应该去看下这些通用配置集文件。我建议你，因为PMD可比FindBugs更有争议的很多，例如：如果你不声明”if statement”或”if statement”为空，它基本上会给你警告信息。如果这些规则是正确的，或这对于您的项目(来说是正确的)，我真的认可你和你队友的工作。我不希望程序因为”if statement”崩溃，我认为这样程序的可读性很差。执行PMD任务，就像是(执行)CheckStyle任务（除了任务的名称是“PMD”）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2) FindBugs使用技巧</p>
<p>
&emsp;&emsp;我建议你不要使用默认的规则配置集，你需要添加这行代码(已经加上)：
ruleSets = [ ]
<br/>
否则，因为默认值是这些基本的规则配置集，基本的规则配置集会和你定义的规则集一起执行。所以，如果你的自定义规则集不在那些基本配置集中，他们仍然会执行。
</p>

<h5 id="nbsp-nbsp-5-Gradle任务执行方式检测的总结"><a href="#nbsp-nbsp-5-Gradle任务执行方式检测的总结" class="headerlink" title="&nbsp;&nbsp;5.Gradle任务执行方式检测的总结"></a>&nbsp;&nbsp;5.Gradle任务执行方式检测的总结</h5><p>
&emsp;配置好后，利用Gradle对Android使用代码质量检查工具是非常容易。比使用质量工具局部检查您的项目在您自己的计算机上，这些工具可以用于自动构建如Jenkins/Hudson这样的平台，让你自动进行质量检查，同时自动建立过程。执行所有我从CLI展现的测试，如同在 Jenkins/Hudson上执行，简单地执行：
gradle check
</p>

<hr>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.oschina.net/question/129540_23043?fromerr=C4u4jrna" target="_blank" rel="noopener">常用 Java 静态代码分析工具的分析与比较</a><br/><br><a href="http://www.devtf.cn/?p=790" target="_blank" rel="noopener">如何提高你的代码质量</a><br/><br><a href="http://blog.csdn.net/maritimesun/article/details/7668966" target="_blank" rel="noopener">Checkstyle的检查项配置详解</a><br/><br><a href="http://gudong.name/2016/04/07/checkstyle.html" target="_blank" rel="noopener">使用 CheckStyle 检查代码</a><br/><br>优秀的开源项目的checkstyle配置文件：<br/><br><a href="https://gist.github.com/yoxin/d55c5d178290ed44763123a796de7ce6" target="_blank" rel="noopener">https://gist.github.com/yoxin/d55c5d178290ed44763123a796de7ce6</a><br/><br><a href="https://github.com/JakeWharton/butterknife/blob/master/checkstyle.xml" target="_blank" rel="noopener">https://github.com/JakeWharton/butterknife/blob/master/checkstyle.xml</a><br/><br><a href="https://github.com/square/picasso/blob/master/checkstyle.xml" target="_blank" rel="noopener">https://github.com/square/picasso/blob/master/checkstyle.xml</a><br/><br>使用Gralde集成错误报告的github地址：<br/><br><a href="https://github.com/vincentbrison/vb-android-app-quality" target="_blank" rel="noopener">https://github.com/vincentbrison/vb-android-app-quality</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>代码检测</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>代码检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu搭建Hexo环境简易步骤（实测）</title>
    <url>/Ubuntu%E6%90%AD%E5%BB%BAHexo%E7%8E%AF%E5%A2%83%E7%AE%80%E6%98%93%E6%AD%A5%E9%AA%A4%EF%BC%88%E5%AE%9E%E6%B5%8B%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>个人实测，以Ubuntu14.04LTS 为例，实现Hexo+github博客的搭建（<strong>当中包含各种有用的小技巧哦！</strong>）</p>
</blockquote>
<a id="more"></a>

<h2 id="Ubuntu环境"><a href="#Ubuntu环境" class="headerlink" title="Ubuntu环境"></a>Ubuntu环境</h2><p>Ubuntu14.04LTS</p>
<hr>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="搭建Nodejs环境"><a href="#搭建Nodejs环境" class="headerlink" title="搭建Nodejs环境"></a>搭建Nodejs环境</h3><ol>
<li><p>解压4.4.4版本的Node.js<br><br/>（<a href="http://nodejs.cn/" target="_blank" rel="noopener">中文网</a>或者<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载压缩包直接右键解压<br><br/>或者：<br><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①tar.gz包： 命令行：</p>
<pre><code>tar -zxvf node-xxxx.tar.gz</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②tar.xz包：命令行：</p>
<pre><code>xz -d node-xxxx.tar.xz
  tar xvf node-xxxx.tar</code></pre></li>
<li><p>设置node.js的环境变量：(为了全局使用node和npm等命令)</p>
<br/>
1) sudo gedit /etc/profile
<br/>2) 编辑profile文件，加入下列命令：
     #set nodejs environment
       export HOME=/home/androidjp
       export NODE_HOME=$HOME/Nodejs/node-v4.4.4-linux-x64
       export PATH=$NODE_HOME/bin:$PATH
       export NODE_PATH=$NODE_HOME/lib/node_modules

<p>3) 保存，退出<br><br/>4) 命令行执行：source /etc/profile<br/></p>
</li>
<li><p>安装npm（一般node.js会带有npm工具，先执行“npm -v”查看是否存在npm，没有时，再执行以下这步）</p>
<p> 推荐这样：<br/></p>
<pre><code>sudo apt-get install apmd</code></pre><p><br/>也可以：<br/></p>
<pre><code>sudo apt-get install curl&lt;br/&gt;
curl http://npmjs.org/install.sh | sudo sh</code></pre><p> 可选：给npm加个镜像（这里选择淘宝NPM镜像，<a href="https://npm.taobao.org/" target="_blank" rel="noopener">参考网址</a>）</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre></li>
<li><p>最后查看 node 和 npm 的版本，检查是否安装成功，否则重复以上步骤：</p>
<pre><code>[cd 你的node安装目录下]{配好了系统环境变量后，这步可以忽略}
node -v
npm -v</code></pre><p>结果输出版本号时，表示Node.js 和 npm的环境就搭好了！</p>
</li>
</ol>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><pre><code>一般方式：
sudo apt-get update
sudo apt-get install git    
git --version 或 git -v</code></pre><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><ol>
<li><p>cd 到你要本地写博客的根目录，比如在用户主目录创建一个目录为‘blog’：</p>
<pre><code>mkdir blog</code></pre></li>
<li><p>cd到blog这个目录</p>
<pre><code>cd blog</code></pre></li>
<li><p>在这个目录中安装复制生成 hexo 的配置信息 （以下总有一条可以）<br>   npm install hexo-cli -g 或者  sudo npm install -g hexo  或者 npm install -g hexo</p>
<blockquote>
<p>注意：遇到 “npm ERROR！-13” 等错误信息，首先看看错误信息中是否存在“.npm/xxx/xxx  权限不足”的情况，如果有，则可以在用户主目录下找到 .npm 文件夹，将其删除，再执行 hexo的安装操作</p>
</blockquote>
</li>
<li><p>初始化 hexo</p>
<pre><code>hexo init</code></pre></li>
<li><p>生成静态页面</p>
<pre><code>hexo g    或者    hexo generate</code></pre></li>
<li><p>本地开启服务</p>
<pre><code>hexo server</code></pre></li>
<li><p>浏览器输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 测试是否出现hexo页面</p>
</li>
<li><p>github 创建一个新的仓库（repository），命名为：</p>
<pre><code>your_user_name.github.io</code></pre><p>这里，选择这个新仓库的地址，可以用https ，也可以用 ssh。</p>
</li>
<li><p>返回到本地你的blog目录中</p>
</li>
<li><p>blog本目录下命令行打开_config.yml进行配置</p>
<pre><code>gedit \_config.yml  或   vi \_config.yml</code></pre><p>在文件的最后的 ‘deploy’ 处，添加如下命令（注意：每个冒号（：）后面跟一个空格，不然会失效！）</p>
<pre><code>deploy:
type: git
repo: https://github.com/yourUserName/your_user_name.github.io.git
branch: master</code></pre></li>
<li><p>保存配置        </p>
<pre><code>npm install hexo-deployer-git --save</code></pre></li>
<li><p>部署到github</p>
<pre><code>hexo deploy</code></pre></li>
<li><p>完成！此时可以输入 <a href="http://your_user_name.github.io/" target="_blank" rel="noopener">http://your_user_name.github.io/</a>  看是否成功部署～</p>
</li>
</ol>
<h3 id="hexo每次部署步骤（注意cd到blog根目录）"><a href="#hexo每次部署步骤（注意cd到blog根目录）" class="headerlink" title="hexo每次部署步骤（注意cd到blog根目录）"></a>hexo每次部署步骤（注意cd到blog根目录）</h3><pre><code>hexo clean
hexo g
hexo deploy</code></pre><h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><pre><code>hexo new&quot;postName&quot; #新建文章
hexo new page&quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help # 查看帮助
hexo version #查看Hexo的版本</code></pre><blockquote>
<p>额外可能用到的linux命令：<br>    sudo apt-get remove softwareName   卸载指定的软件</p>
</blockquote>
<h3 id="使用Atom编辑器编辑md文件"><a href="#使用Atom编辑器编辑md文件" class="headerlink" title="使用Atom编辑器编辑md文件"></a>使用Atom编辑器编辑md文件</h3><p>关于 markdown 的各种语法，可参考文章：<a href="http://www.jianshu.com/p/4Q3aay" target="_blank" rel="noopener">markdown学习笔记</a></p>
<ol>
<li>安装编辑器（推荐命令行下载安装）</li>
</ol>
<p>–&gt; 可选择直接下载安装<a href="https://atom.io/" target="_blank" rel="noopener">编辑器下载地址</a><br>        sudo add-apt-repository ppa:webupd8team/atom<br>        sudo apt-get update<br>        sudo apt-get install atom<br>2. 打开项目(File  –&gt;  Open Folder –&gt; 选择 _posts 目录导入)<br>3. 安装插件<br>  一般插件安装方式：</p>
<p>  方式一：通过atom菜单的setting直接搜索project进行install（本人做法：’ctrl+shift+p’，输入框输入“welcome” –&gt; Welcome Guide –&gt; Install a project –&gt; 输入你要找的插件名 –&gt; 点击安装）<br>  <br/>方式二：上 Github 下载插件,放在 atom 目录下的 package,重开打开软件会自动识别<br>  <br/>方式三：使用 apm 命令安装,例:apm install run-in-browser</p>
<ol start="4">
<li><p>图片上传辅助<br>利用<a href="http://yotuku.cn/" target="_blank" rel="noopener">七牛云</a>等上传图片，获取链接<br>或者参考<img src="http://www.tuicool.com/articles/umEBVfI" alt="此网站">,辅助图片上传</p>
<p>例如：安装rib网页预览插件<br><br/><img src="http://i4.piimg.com/567571/ad8a58ed6f05aacc.png" alt="pic_install_rib"></p>
</li>
</ol>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ol>
<li>github绑定自己的域名（这里示例为：腾讯云域名，绑定github.io）<br><br/>  1.1 首先，在你的github.io 仓库根目录，新建一个文件‘CNAME’，里面填入你的域名<br><br/><img src="http://i1.piimg.com/567571/2ed1bbbca456965a.png" alt=""><br/>
<br/>![](http://i1.piimg.com/567571/ddc8c57535459f1d.png)
<br/>  1.2 接着，在你的域名平台上，加入两个解析（解析github IP）
<br/>![](http://i1.piimg.com/567571/569aef773709826f.png)


</li>
</ol>
<hr>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://segmentfault.com/a/1190000002665530" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002665530</a><br/><br><a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="noopener">http://blog.fens.me/hexo-blog-github/</a><br/><br><a href="http://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">http://www.jianshu.com/p/465830080ea9</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
